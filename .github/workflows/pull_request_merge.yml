name: Pull Request - Merge

concurrency:
  group: pull_request_merge_queue
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to merge"
        required: true

jobs:
  merge:
    runs-on: macos-14
    name: Merge PR
    env:
      GITHUB_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
    steps:
      - name: Setup GIT
        uses: raycast/github-actions/setup-git@master
      - name: Get changed extensions
        id: get_changed_extensions
        uses: raycast/github-actions/get-changed-extensions@master
        with:
          pull_request_number: "${{ inputs.pr_number }}"
      - name: Checkout PR
        run: gh pr checkout ${{ github.event.inputs.pr_number }}
      - name: Update CHANGELOG.md
        id: update_changelog
        run: |
          changelog_updated=false
          updated_count=0
          changelogs=$(gh pr view ${{ github.event.inputs.pr_number }} --json files --jq '.files.[].path' | grep -i CHANGELOG.md || true)
          for changelog in $changelogs
          do
            echo "$changelog:"
            if [[ -f "$changelog" ]]; then
              pattern="{PR_MERGE_DATE}"
              replacement=$(date '+%Y-%m-%d')
              if grep -q $pattern $changelog; then
                echo "  pattern found"
                sed -i "" "s/$pattern/$replacement/g" $changelog
                # ubuntu: sed -i "s/$pattern/$replacement/g" $changelog
                echo "  updated to $replacement"
                updated_count=$((updated_count+1))
              else
                echo "  pattern not found - skipping"
              fi
            else
              echo "  skipping (file not existing)"
            fi
          done
          if [[ $updated_count -gt 0 ]]; then
            changelog_updated=true
          fi
          echo "changelog_updated=$changelog_updated" >> $GITHUB_OUTPUT

      - name: Add platforms field to package.json
        id: add_platforms_field
        run: |
          platforms_added=false
          modified_count=0
          changed_extensions="${{ steps.get_changed_extensions.outputs.paths }}"
          if [[ -n "$changed_extensions" ]]; then
            echo "Changed extensions: $changed_extensions"
            IFS=',' read -ra extension_paths <<< "$changed_extensions"
            for extension_path in "${extension_paths[@]}"; do
              package_json="$extension_path/package.json"
              echo "Checking: $package_json"
              if [[ -f "$package_json" ]]; then
                # Check if platforms field exists
                if ! jq -e '.platforms' "$package_json" > /dev/null 2>&1; then
                  echo "  Adding platforms field to $package_json"
                  # Add platforms field with ["macOS"] as default
                  jq '. + {"platforms": ["macOS"]}' "$package_json" > "${package_json}.tmp" && mv "${package_json}.tmp" "$package_json"
                  modified_count=$((modified_count+1))
                else
                  echo "  platforms field already exists in $package_json"
                fi
              else
                echo "  package.json not found in $extension_path"
              fi
            done
          else
            echo "No changed extensions found"
          fi
          if [[ $modified_count -gt 0 ]]; then
            platforms_added=true
          fi
          echo "platforms_added=$platforms_added" >> $GITHUB_OUTPUT

      - name: Optimise images
        id: optimise_images
        run: |
          images_optimized=false
          images=$(gh pr view ${{ github.event.inputs.pr_number }} --json files | jq -r '.files[].path | select(endswith("png") or endswith("jpeg") or endswith("jpg"))')
          images_array=()
          if [[ -n "$images" ]]; then
            echo "Images: $images"
            while IFS= read -r image; do
              if [[ -f "$image" ]]; then
                images_array+=("$image")
              fi
            done <<< "$images"
          fi
          count=${#images_array[@]}
          echo "Found images: $count"
          if [ $count -gt 0 ]; then
            brew update
            brew install imageoptim
            npm install -g imageoptim-cli
            batch_size=30
            batch_number=1
            total_batches=$(( (count + batch_size - 1) / batch_size ))
            for ((i = 0; i < count; i += batch_size)); do
                batch=("${images_array[@]:i:batch_size}")
                echo "Processing batch: $batch_number / $total_batches"
                imageoptim "${batch[@]}"
                ((batch_number++))
            done
            images_optimized=true
          fi
          echo "images_optimized=$images_optimized" >> $GITHUB_OUTPUT
      - name: Commit changes
        id: commit_changes
        run: |
          pr_info=$(gh pr view ${{ github.event.inputs.pr_number }} --json headRefName,headRepository,headRepositoryOwner,maintainerCanModify,url)
          echo $pr_info

          can_modify=$(echo $pr_info | jq -r .maintainerCanModify)
          pr_branch=$(echo $pr_info | jq -r .headRefName)
          pr_repo_name=$(echo $pr_info | jq -r .headRepository.name)
          pr_repo_owner=$(echo $pr_info | jq -r .headRepositoryOwner.login)

          if ! [[ -z $(git status -s .) ]] ; then
            if [[ "$can_modify" == "false" ]]; then
              error="Edits from maintainers are disabled."
              echo $error
              echo "error=$error" >> $GITHUB_OUTPUT
              exit 1
            fi

            # Build a dynamic commit message based on previous steps
            parts=()
            if [[ "${{ steps.update_changelog.outputs.changelog_updated }}" == "true" ]]; then
              parts+=("Update CHANGELOG.md")
            fi
            if [[ "${{ steps.add_platforms_field.outputs.platforms_added }}" == "true" ]]; then
              parts+=("add platforms field")
            fi
            if [[ "${{ steps.optimise_images.outputs.images_optimized }}" == "true" ]]; then
              parts+=("optimise images")
            fi

            # Join parts with commas and 'and' for the last item
            if [[ ${#parts[@]} -eq 0 ]]; then
              commit_msg="Automated maintenance updates"
            else
              commit_msg="${parts[0]}"
              for (( i=1; i<${#parts[@]}; i++ )); do
                if [[ $i -eq $((${#parts[@]}-1)) ]]; then
                  commit_msg+=" and ${parts[$i]}"
                else
                  commit_msg+=", ${parts[$i]}"
                fi
              done
            fi

            git add .
            git status .
            git commit --message "$commit_msg"

            git push https://${{ env.GITHUB_TOKEN }}@github.com/$pr_repo_owner/$pr_repo_name.git HEAD:$pr_branch
            echo "Pushed changes."
            echo "changes_pushed=true" >> $GITHUB_OUTPUT
          else
            echo "No changes."
            echo "changes_pushed=false" >> $GITHUB_OUTPUT
          fi
      - name: Sleep for 30 seconds
        if: steps.commit_changes.outputs.changes_pushed == 'true'
        run: sleep 30 # sleep 30s for ubuntu
        shell: bash
      - name: Merge
        run: gh pr merge ${{ github.event.inputs.pr_number }} --squash --delete-branch
      - name: Notify Failure to Slack
        if: failure()
        uses: raycast/github-actions/slack-send@master
        with:
          webhook: ${{ secrets.SLACK_STREAM_ERRORS_STORE_PUBLIC }}
          color: "danger"
          text: |
            PR ${{ github.event.inputs.pr_number }} merge failed. ${{ steps.commit_changes.outputs.error }}
            Check <${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}|action logs>
