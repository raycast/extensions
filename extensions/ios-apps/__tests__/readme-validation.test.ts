import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { extractScreenshotsFromShoeboxJson } from "../src/utils/app-store-scraper";

describe("README.md Generation Validation", () => {
  let tempDir: string;
  let spotifyFixture: any;
  let spotifyScreenshots: Array<{ url: string; type: string; index: number }>;

  beforeAll(() => {
    // Create temporary directory for testing
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "readme-test-"));
    
    // Load Spotify fixture
    const spotifyPath = path.join(__dirname, "../tests/fixtures/shoebox_spotify.json");
    const spotifyData = fs.readFileSync(spotifyPath, "utf8");
    spotifyFixture = JSON.parse(spotifyData);
    
    // Extract screenshots for testing
    const html = createShoeboxHtml(spotifyFixture);
    spotifyScreenshots = extractScreenshotsFromShoeboxJson(html);
  });

  afterAll(() => {
    // Clean up temporary directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  // Helper function to create HTML with shoebox JSON
  function createShoeboxHtml(shoeboxJson: any): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <title>App Store</title>
      </head>
      <body>
        <script type="fastboot/shoebox" id="shoebox-media-api-cache-apps">
          ${JSON.stringify(shoeboxJson)}
        </script>
      </body>
      </html>
    `;
  }

  // Helper function to create a mock README
  function createMockReadme(appName: string, bundleId: string, appStoreId: string, platformCounts: Record<string, number>): string {
    const totalScreenshots = Object.values(platformCounts).reduce((sum, count) => sum + count, 0);
    
    let platformSections = "";
    Object.entries(platformCounts).forEach(([platform, count]) => {
      if (count > 0) {
        const pluralSuffix = count === 1 ? "" : "s";
        platformSections += `- ${platform} (${count} screenshot${pluralSuffix})\n`;
      }
    });

    return `# ${appName} Screenshots

Downloaded on ${new Date().toISOString().split('T')[0]}

## App Information

- **Bundle ID:** ${bundleId}
- **App Store ID:** ${appStoreId}
- **Developer:** Spotify AB
- **Version:** 8.9.84
- **Price:** Free
- **Size:** 350MB

## Screenshots

Total: ${totalScreenshots} screenshot${totalScreenshots === 1 ? "" : "s"}

### Platforms

${platformSections}

---

Generated by iOS App Screenshot Downloader
`;
  }

  describe("Spotify app README validation", () => {
    it("should validate README structure for Spotify app", () => {
      // Calculate platform counts from actual extraction
      const platformCounts = spotifyScreenshots.reduce((counts, screenshot) => {
        counts[screenshot.type] = (counts[screenshot.type] || 0) + 1;
        return counts;
      }, {} as Record<string, number>);

      // Create mock README
      const readmeContent = createMockReadme(
        "Spotify: Music and Podcasts",
        "com.spotify.client",
        "324684580",
        platformCounts
      );

      // Create README file in temp directory
      const readmePath = path.join(tempDir, "README.md");
      fs.writeFileSync(readmePath, readmeContent, "utf8");

      // Verify README was created
      expect(fs.existsSync(readmePath)).toBe(true);

      // Read and validate content
      const actualContent = fs.readFileSync(readmePath, "utf8");
      
      // Verify main sections
      expect(actualContent).toContain("# Spotify: Music and Podcasts Screenshots");
      expect(actualContent).toContain("## App Information");
      expect(actualContent).toContain("## Screenshots");
      
      // Verify app details
      expect(actualContent).toContain("com.spotify.client");
      expect(actualContent).toContain("324684580");
      expect(actualContent).toContain("Spotify AB");
      
      // Verify platform counts are correct
      expect(actualContent).toContain(`iPhone (${platformCounts["iPhone"]} screenshot`);
      expect(actualContent).toContain(`iPad (${platformCounts["iPad"]} screenshot`);
      expect(actualContent).toContain(`AppleWatch (${platformCounts["AppleWatch"]} screenshot`);
      expect(actualContent).toContain(`AppleTV (${platformCounts["AppleTV"]} screenshot`);
      
      // Verify total count
      const totalScreenshots = Object.values(platformCounts).reduce((sum, count) => sum + count, 0);
      expect(actualContent).toContain(`Total: ${totalScreenshots} screenshot`);
    });

    it("should assert correct platform screenshot counts for Spotify", () => {
      // This test validates the specific counts we expect for the Spotify fixture
      const platformCounts = spotifyScreenshots.reduce((counts, screenshot) => {
        counts[screenshot.type] = (counts[screenshot.type] || 0) + 1;
        return counts;
      }, {} as Record<string, number>);

      // Assert the exact counts we determined from the fixture analysis
      expect(platformCounts["iPhone"]).toBe(26);
      expect(platformCounts["iPad"]).toBe(13);
      expect(platformCounts["AppleWatch"]).toBe(6);
      expect(platformCounts["AppleTV"]).toBe(5);
      
      // Total should be 50
      const total = Object.values(platformCounts).reduce((sum, count) => sum + count, 0);
      expect(total).toBe(50);
    });

    it("should validate directory structure creation expectations", () => {
      const { PlatformDirectories } = require('../src/types');
      
      // Create mock directories for platforms with screenshots
      const screenshotsDir = path.join(tempDir, "Spotify Music and Podcasts Screenshots");
      const platformDirs = PlatformDirectories(screenshotsDir);
      
      // Calculate which platforms have screenshots
      const platformCounts = spotifyScreenshots.reduce((counts, screenshot) => {
        counts[screenshot.type] = (counts[screenshot.type] || 0) + 1;
        return counts;
      }, {} as Record<string, number>);

      // Create directories only for platforms with screenshots
      fs.mkdirSync(screenshotsDir, { recursive: true });
      
      Object.entries(platformCounts).forEach(([platformType, count]) => {
        if (count > 0) {
          const platformDir = platformDirs[platformType as keyof typeof platformDirs];
          if (platformDir) {
            fs.mkdirSync(platformDir, { recursive: true });
            
            // Create mock screenshot files
            for (let i = 1; i <= Math.min(count, 3); i++) { // Limit to 3 for testing
              fs.writeFileSync(path.join(platformDir, `${i}.png`), "fake-png-data");
            }
          }
        }
      });

      // Verify directories exist for platforms with screenshots
      expect(fs.existsSync(platformDirs["iPhone"])).toBe(true);
      expect(fs.existsSync(platformDirs["iPad"])).toBe(true);
      expect(fs.existsSync(platformDirs["AppleWatch"])).toBe(true);
      expect(fs.existsSync(platformDirs["AppleTV"])).toBe(true);
      
      // Verify directories don't exist for platforms without screenshots
      expect(fs.existsSync(platformDirs["Mac"])).toBe(false);
      expect(fs.existsSync(platformDirs["VisionPro"])).toBe(false);
      expect(fs.existsSync(platformDirs["iMessage"])).toBe(false);
      
      // Verify files exist in created directories
      const iPhoneFiles = fs.readdirSync(platformDirs["iPhone"]);
      expect(iPhoneFiles.length).toBeGreaterThan(0);
      expect(iPhoneFiles.every(file => file.endsWith(".png"))).toBe(true);
    });
  });

  describe("End-to-end validation summary", () => {
    it("should validate complete Spotify scraping pipeline requirements", () => {
      // Verify all components for end-to-end testing are available
      
      // 1. Screenshots extracted successfully
      expect(spotifyScreenshots.length).toBe(50);
      
      // 2. Device types mapped correctly to platforms
      const platformTypes = new Set(spotifyScreenshots.map(s => s.type));
      expect(platformTypes).toEqual(new Set(["iPhone", "iPad", "AppleWatch", "AppleTV"]));
      
      // 3. Platform counts are as expected
      const platformCounts = spotifyScreenshots.reduce((counts, screenshot) => {
        counts[screenshot.type] = (counts[screenshot.type] || 0) + 1;
        return counts;
      }, {} as Record<string, number>);
      
      expect(platformCounts).toEqual({
        iPhone: 26,
        iPad: 13,
        AppleWatch: 6,
        AppleTV: 5
      });
      
      // 4. All URLs are valid
      spotifyScreenshots.forEach(screenshot => {
        expect(() => new URL(screenshot.url)).not.toThrow();
      });
      
      // 5. Sequential indexing is correct
      spotifyScreenshots.forEach((screenshot, index) => {
        expect(screenshot.index).toBe(index);
      });
      
      // 6. No duplicate URLs
      const urls = spotifyScreenshots.map(s => s.url);
      const uniqueUrls = new Set(urls);
      expect(urls.length).toBe(uniqueUrls.size);
      
      console.log("âœ… All Spotify end-to-end validation requirements met:");
      console.log(`   - ${spotifyScreenshots.length} screenshots extracted`);
      console.log(`   - ${platformTypes.size} platform types: ${Array.from(platformTypes).join(", ")}`);
      console.log(`   - Platform distribution: ${JSON.stringify(platformCounts)}`);
    });
  });
});
