"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAsyncFunction = void 0;
const react_1 = require("react");
const useLatest_1 = require("./useLatest");
/**
 * Wraps an asynchronous function or a function that returns a promise and returns the {@link AsyncState} corresponding to the execution of the function with the callback to trigger the execution of the function.
 *
 * You can specify an initial state (default being `{ isLoading: false }`) and a reference to an AbortController to cancel a previous call when triggering a new one.
 *
 * @example
 * ```
 * import { useAsyncFunction } from '@raycast/utils';
 *
 * const Demo = ({url}) => {
 * const abortable = useRef<AbortController>();
 * const [state, doFetch] = useAsyncFunction(async (url: string) => {
 *   const response = await fetch(url, { signal: abortable.current?.signal });
 *   const result = await response.text();
 *   return result
 * }, {
 *   abortable
 * });
 *
 * useEffect(() => {
 *   if (state.error) {
 *     showToast({ style: Toast.Style.Failure, title: state.error.message })
 *   }
 * }, [state.error])
 *
 * return (
 *   <Detail
 *     isLoading={state.isLoading}
 *     markdown={state.value}
 *     actions={
 *       <ActionPanel>
 *         <Action title="Start Loading" onAction={() => doFetch(url)} />
 *       </ActionPanel>
 *     }
 *   />
 * );
};
 * ```
 */
function useAsyncFunction(fn, config) {
    const lastCallId = (0, react_1.useRef)(0);
    const [state, set] = (0, react_1.useState)(config?.initialState ?? { isLoading: false });
    const fnRef = (0, useLatest_1.useLatest)(fn);
    const configRef = (0, useLatest_1.useLatest)(config);
    const callback = (0, react_1.useCallback)((...args) => {
        const callId = ++lastCallId.current;
        if (configRef.current?.abortable) {
            configRef.current.abortable.current?.abort();
            configRef.current.abortable.current = new AbortController();
        }
        set((prevState) => ({ ...prevState, loading: true }));
        return fnRef.current(...args).then((value) => {
            if (callId === lastCallId.current) {
                set({ value, isLoading: false });
            }
            return value;
        }, (error) => {
            if (error.name == "AbortError") {
                return error;
            }
            if (callId === lastCallId.current) {
                set({ error, isLoading: false });
            }
            return error;
        });
    }, [configRef, fnRef]);
    return [state, callback];
}
exports.useAsyncFunction = useAsyncFunction;
