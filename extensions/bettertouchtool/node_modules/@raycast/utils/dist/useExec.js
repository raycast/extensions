"use strict";
/*
 * Inspired by Execa
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useExec = void 0;
const node_child_process_1 = __importDefault(require("node:child_process"));
const react_1 = require("react");
const useCachedPromise_1 = require("./useCachedPromise");
const useLatest_1 = require("./useLatest");
const exec_utils_1 = require("./exec-utils");
const SPACES_REGEXP = / +/g;
function parseCommand(command, args) {
    if (args) {
        return [command, ...args];
    }
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)) {
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
            // Merge previous token with current one
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        }
        else {
            tokens.push(token);
        }
    }
    return tokens;
}
function stripFinalNewline(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt(0);
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt(0);
    if (input[input.length - 1] === LF) {
        // @ts-expect-error we are doing some nasty stuff here
        input = input.slice(0, -1);
    }
    if (input[input.length - 1] === CR) {
        // @ts-expect-error we are doing some nasty stuff here
        input = input.slice(0, -1);
    }
    return input;
}
function handleOutput(options, value) {
    if (options.stripFinalNewline) {
        return stripFinalNewline(value);
    }
    return value;
}
const getErrorPrefix = ({ timedOut, timeout, signal, exitCode, }) => {
    if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
    }
    if (signal !== undefined) {
        return `was killed with ${signal}`;
    }
    if (exitCode !== undefined) {
        return `failed with exit code ${exitCode}`;
    }
    return "failed";
};
const makeError = ({ stdout, stderr, error, signal, exitCode, command, timedOut, options, }) => {
    const prefix = getErrorPrefix({ timedOut, timeout: options?.timeout, signal, exitCode });
    const execaMessage = `Command ${prefix}: ${command}`;
    const shortMessage = error ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (error) {
        // @ts-expect-error not on Error
        error.originalMessage = error.message;
        error.message = message;
    }
    else {
        error = new Error(message);
    }
    // @ts-expect-error not on Error
    error.shortMessage = shortMessage;
    // @ts-expect-error not on Error
    error.command = command;
    // @ts-expect-error not on Error
    error.exitCode = exitCode;
    // @ts-expect-error not on Error
    error.signal = signal;
    // @ts-expect-error not on Error
    error.stdout = stdout;
    // @ts-expect-error not on Error
    error.stderr = stderr;
    if ("bufferedData" in error) {
        delete error["bufferedData"];
    }
    return error;
};
function defaultParsing({ stdout, stderr, error, exitCode, signal, timedOut, command, options, }) {
    if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            command,
            timedOut,
            options,
        });
        throw returnedError;
    }
    return stdout;
}
function useExec(command, optionsOrArgs, options) {
    const { parseOutput, input, onData, onWillExecute, initialData, execute, keepPreviousData, onError, ...execOptions } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};
    const useCachedPromiseOptions = {
        initialData,
        execute,
        keepPreviousData,
        onError,
        onData,
        onWillExecute,
    };
    const abortable = (0, react_1.useRef)();
    const parseOutputRef = (0, useLatest_1.useLatest)(parseOutput || defaultParsing);
    const fn = (0, react_1.useCallback)(async (_command, _args, _options, input) => {
        const [file, ...args] = parseCommand(_command, _args);
        const command = [file, ...args].join(" ");
        const options = {
            stripFinalNewline: true,
            ..._options,
            signal: abortable.current?.signal,
            encoding: _options?.encoding === null ? "buffer" : _options?.encoding || "utf8",
            env: { ...process.env, ..._options?.env },
        };
        const spawned = node_child_process_1.default.spawn(file, args, options);
        const spawnedPromise = (0, exec_utils_1.getSpawnedPromise)(spawned, options);
        if (input) {
            spawned.stdin.end(input);
        }
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await (0, exec_utils_1.getSpawnedResult)(spawned, options, spawnedPromise);
        const stdout = handleOutput(options, stdoutResult);
        const stderr = handleOutput(options, stderrResult);
        return parseOutputRef.current({
            // @ts-expect-error too many generics, I give up
            stdout,
            // @ts-expect-error too many generics, I give up
            stderr,
            error,
            exitCode,
            signal,
            timedOut,
            command,
            options,
        });
    }, [parseOutputRef]);
    // @ts-expect-error T can't be a Promise so it's actually the same
    return (0, useCachedPromise_1.useCachedPromise)(fn, [command, Array.isArray(optionsOrArgs) ? optionsOrArgs : [], execOptions, input], {
        ...useCachedPromiseOptions,
        abortable,
    });
}
exports.useExec = useExec;
