import { FunctionReturningPromise, UseCachedPromiseReturnType } from "./types";
import { PromiseOptions } from "./usePromise";
export declare type CachedPromiseOptions<T extends FunctionReturningPromise, U> = PromiseOptions<T> & {
    /**
     * The initial data if there aren't any in the Cache yet.
     */
    initialData?: U;
    /**
     * Tells the hook to keep the previous results instead of returning the initial value
     * if there aren't any in the cache for the new arguments.
     * This is particularly useful when used for data for a List to avoid flickering.
     */
    keepPreviousData?: boolean;
};
/**
 * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.
 *
 * @remark The value needs to be JSON serializable.
 * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).
 *
 * @example
 * ```
 * import { useCachedPromise } from '@raycast/utils';
 *
 * const Demo = () => {
 *   const abortable = useRef<AbortController>();
 *   const { isLoading, data, revalidate } = useCachedPromise(async (url: string) => {
 *     const response = await fetch(url, { signal: abortable.current?.signal });
 *     const result = await response.text();
 *     return result
 *   },
 *   ['https://api.example'],
 *   {
 *     abortable
 *   });
 *
 *   return (
 *     <Detail
 *       isLoading={isLoading}
 *       markdown={data}
 *       actions={
 *         <ActionPanel>
 *           <Action title="Reload" onAction={() => revalidate()} />
 *         </ActionPanel>
 *       }
 *     />
 *   );
 * };
 * ```
 */
export declare function useCachedPromise<T extends FunctionReturningPromise<[]>>(fn: T): UseCachedPromiseReturnType<Awaited<ReturnType<T>>, undefined>;
export declare function useCachedPromise<T extends FunctionReturningPromise, U = undefined>(fn: T, args: Parameters<T>, options?: CachedPromiseOptions<T, U>): UseCachedPromiseReturnType<Awaited<ReturnType<T>>, U>;
//# sourceMappingURL=useCachedPromise.d.ts.map