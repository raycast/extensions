"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCachedAsync = void 0;
const react_1 = require("react");
const object_hash_1 = __importDefault(require("object-hash"));
const api_1 = require("@raycast/api");
const useAsyncFunction_1 = require("./useAsyncFunction");
const useCachedState_1 = require("./useCachedState");
const useLatest_1 = require("./useLatest");
// Symbol to differentiate an empty cache from `undefined`
const emptyCache = Symbol();
function useCachedAsync(fn, args, config) {
    const [cachedData, mutateCache] = (0, useCachedState_1.useCachedState)(createCacheKey(args || []), emptyCache, {
        cacheNamespace: createCacheKey(fn),
    });
    const [state, revalidate] = (0, useAsyncFunction_1.useAsyncFunction)(fn, {
        initialState: { isLoading: true },
        abortable: config?.abortable,
    });
    const data = cachedData !== emptyCache ? cachedData : config?.initialValue;
    // Use a ref to store previous returned data. Use the inital data as its inital value.
    const laggyDataRef = (0, react_1.useRef)(data);
    const returnedData = config?.keepPreviousData
        ? cachedData !== emptyCache
            ? cachedData
            : laggyDataRef.current
        : data;
    const latestData = (0, useLatest_1.useLatest)(returnedData);
    const latestArgs = (0, useLatest_1.useLatest)(args || []);
    const latestOnError = (0, useLatest_1.useLatest)(config?.onError);
    const mutate = (0, react_1.useCallback)(async (asyncUpdate, options) => {
        try {
            if (options?.optimisticUpdate) {
                mutateCache(options.optimisticUpdate(latestData.current));
            }
            return await asyncUpdate;
        }
        catch (err) {
            if (options?.rollbackOnError) {
                mutateCache(options.rollbackOnError(latestData.current));
            }
            throw err;
        }
        finally {
            if (options?.revalidate !== false) {
                revalidate(...latestArgs.current);
            }
        }
    }, [mutateCache, revalidate, latestData, latestArgs]);
    // revalidate when the args change
    (0, react_1.useEffect)(() => {
        if (config?.execute !== false) {
            revalidate(...(args || []));
        }
    }, [...(args || []), config?.execute, revalidate]);
    // update the cache when we fetch new values
    (0, react_1.useEffect)(() => {
        if (typeof state.value !== "undefined") {
            mutateCache(state.value);
            laggyDataRef.current = state.value;
        }
    }, [state.value, mutateCache, laggyDataRef]);
    (0, react_1.useEffect)(() => {
        if (state.error) {
            if (latestOnError.current) {
                latestOnError.current(state.error);
            }
            else {
                console.error(state.error);
                (0, api_1.showToast)({
                    style: api_1.Toast.Style.Failure,
                    title: "Failed to fetch latest data",
                    message: state.error.message,
                    primaryAction: {
                        title: "Retry",
                        onAction(toast) {
                            toast.hide();
                            revalidate(...latestArgs.current);
                        },
                    },
                    secondaryAction: {
                        title: "Copy Logs",
                        onAction(toast) {
                            toast.hide();
                            api_1.Clipboard.copy(state.error?.stack || state.error?.message || "");
                        },
                    },
                });
            }
        }
    }, [state.error, latestArgs, revalidate, latestOnError]);
    return {
        data: returnedData,
        mutate,
        isLoading: state.isLoading,
        error: state.error,
    };
}
exports.useCachedAsync = useCachedAsync;
function createCacheKey(args) {
    return (0, object_hash_1.default)(args);
}
