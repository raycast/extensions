# Detailed Execution Plan: Fix "Missing required property 'title' for Unknown" Error

## Problem Summary

The Raycast extension for n8n displays the error "Missing required property 'title' for Unknown" when using the "search triggerable workflows" feature. This error occurs consistently and persists even after resetting all data.

## Root Cause Analysis

After examining the codebase, we've identified several potential causes:

1. **EmptyView Component Issues**: The EmptyView component in `src/components/empty-view.tsx` may not be properly handling Action components.
2. **ActionPanel Structure**: There may be issues with how ActionPanel and Action components are structured in `src/search-webhook-workflows.tsx`.
3. **Filter-Related Components**: The issue might be related to the persistent filter action.

## Execution Plan

### Phase 1: Add Diagnostic Logging (Day 1, Morning)

#### Step 1.1: Add Detailed Logging to EmptyView Component

File: `src/components/empty-view.tsx`

```typescript
export function EmptyView(props: { title: string; extensionPreferences: boolean; actions?: React.ReactNode }) {
  const { title, extensionPreferences, actions } = props;
  
  // Add detailed logging
  console.log("EmptyView rendering with title:", title);
  console.log("EmptyView actions type:", actions ? typeof actions : "undefined");
  
  if (actions) {
    console.log("EmptyView actions isValidElement:", React.isValidElement(actions));
    if (React.isValidElement(actions)) {
      console.log("EmptyView actions type:", actions.type);
      console.log("EmptyView actions props:", JSON.stringify(actions.props, null, 2));
    }
  }
  
  // Rest of the component...
}
```

#### Step 1.2: Add Logging to search-webhook-workflows.tsx

File: `src/search-webhook-workflows.tsx`

Add logging before rendering EmptyView components:

```typescript
// Before line 131
console.log("Rendering EmptyView for error state");

// Before line 201
console.log("Rendering EmptyView for empty workflows");
```

#### Step 1.3: Run and Analyze Logs

1. Run the extension with `npm run dev`
2. Trigger the error by using the "search triggerable workflows" feature
3. Analyze the logs to identify which component is causing the issue

### Phase 2: Fix EmptyView Component (Day 1, Afternoon)

#### Step 2.1: Improve ActionPanel Detection

File: `src/components/empty-view.tsx`

```typescript
// Replace the isActionPanel function (around line 18)
const isActionPanel = (node: React.ReactNode): boolean => {
  if (!React.isValidElement(node)) return false;
  
  // Check if it's directly an ActionPanel
  if (node.type === ActionPanel) return true;
  
  // Check if it's a function component named ActionPanel
  if (typeof node.type === 'function') {
    return node.type.name === 'ActionPanel' || 
           node.type.displayName === 'ActionPanel';
  }
  
  // Check if it has an ActionPanel as a child
  if (node.props && node.props.children) {
    const children = Array.isArray(node.props.children) 
      ? node.props.children 
      : [node.props.children];
    
    return children.some(child => isActionPanel(child));
  }
  
  return false;
};
```

#### Step 2.2: Add Action Component Validation

File: `src/components/empty-view.tsx`

```typescript
// Add this function after isActionPanel
const ensureActionHasTitle = (node: React.ReactNode): React.ReactNode => {
  if (!React.isValidElement(node)) return node;
  
  // If it's an Action without a title, add a default title
  if (node.type === Action && !node.props.title) {
    console.log("Found Action without title, adding default title");
    return React.cloneElement(node, { title: "Action" });
  }
  
  // If it's an Action.Push without a title, add a default title
  if (node.type && 
      typeof node.type === 'object' && 
      node.type.displayName === 'Action.Push' && 
      !node.props.title) {
    console.log("Found Action.Push without title, adding default title");
    return React.cloneElement(node, { title: "Action" });
  }
  
  // Recursively validate children
  if (node.props && node.props.children) {
    const children = Array.isArray(node.props.children) 
      ? node.props.children 
      : [node.props.children];
    
    const validatedChildren = children.map(child => ensureActionHasTitle(child));
    
    return React.cloneElement(node, {
      children: validatedChildren.length === 1 ? validatedChildren[0] : validatedChildren
    });
  }
  
  return node;
};
```

#### Step 2.3: Update the finalActions Logic

File: `src/components/empty-view.tsx`

```typescript
// Replace the finalActions logic (around line 23)
let finalActions: React.ReactNode = undefined;

if (actions) {
  try {
    // If actions is already an ActionPanel, validate its children
    if (isActionPanel(actions)) {
      console.log("Actions is an ActionPanel, validating children");
      finalActions = ensureActionHasTitle(actions);
    }
    // Otherwise, wrap it in ActionPanel and validate
    else {
      console.log("Wrapping actions in ActionPanel and validating");
      finalActions = <ActionPanel>{ensureActionHasTitle(actions)}</ActionPanel>;
    }
  } catch (error) {
    console.error("Error processing actions:", error);
    // Fallback to a safe default
    finalActions = (
      <ActionPanel>
        <Action title="Fallback Action" onAction={() => {}} />
      </ActionPanel>
    );
  }
}
// If no actions provided but extensionPreferences is true, use default ActionOpenPreferences
else if (extensionPreferences) {
  finalActions = (
    <ActionPanel>
      <ActionOpenPreferences />
    </ActionPanel>
  );
}
```

### Phase 3: Fix ActionPanel Structure in search-webhook-workflows.tsx (Day 2, Morning)

#### Step 3.1: Fix EmptyView for Error State

File: `src/search-webhook-workflows.tsx`

```typescript
// Replace the EmptyView in error state (around line 131)
<EmptyView
  title="Failed to Load Workflows"
  extensionPreferences={false}
  actions={
    <ActionPanel title="Error Actions">
      <ActionPanel.Section title="Troubleshooting">
        <Action
          title="Retry"
          icon={Icon.Repeat}
          onAction={() => setRefresh(Date.now())}
        />
        <Action
          title="Reset All Data"
          icon={Icon.Trash}
          style={Action.Style.Destructive}
          onAction={async () => {
            try {
              await resetAllStorageData();
              setRefresh(Date.now());
            } catch (error) {
              console.error("Failed to reset storage:", error);
            }
          }}
        />
      </ActionPanel.Section>
      <ActionPanel.Section title="Settings">
        <ActionOpenPreferences />
        <Action.Push
          title="Set Trigger Filters..."
          icon={Icon.Filter}
          target={<TriggerFilterForm />}
          shortcut={{ modifiers: ["cmd", "shift"], key: "f" }}
        />
      </ActionPanel.Section>
    </ActionPanel>
  }
/>
```

#### Step 3.2: Fix EmptyView for No Workflows

File: `src/search-webhook-workflows.tsx`

```typescript
// Replace the EmptyView for no workflows (around line 201)
<EmptyView
  title={activeFilters.length > 0 ? "No Workflows Match Filters" : "No Webhook Workflows Found"}
  extensionPreferences={false}
  actions={
    <ActionPanel title="Webhook Actions">
      <ActionPanel.Section title="Filter Actions">
        <Action.Push
          title="Set Trigger Filters..."
          icon={Icon.Filter}
          target={<TriggerFilterForm />}
          shortcut={{ modifiers: ["cmd", "shift"], key: "f" }}
        />
        <Action
          title="Refresh List"
          icon={Icon.Repeat}
          onAction={() => setRefresh(Date.now())}
        />
      </ActionPanel.Section>
      <ActionPanel.Section title="Settings">
        <ActionOpenPreferences />
        <Action.Push
          title="Reset Storage Data..."
          icon={Icon.Trash}
          target={<ResetStorageForm />}
          shortcut={{ modifiers: ["ctrl", "shift"], key: "r" }}
        />
        <Action
          title="Reset All Data Now"
          icon={Icon.Trash}
          style={Action.Style.Destructive}
          onAction={async () => {
            try {
              await resetAllStorageData();
              setRefresh(Date.now());
            } catch (error) {
              console.error("Failed to reset storage:", error);
            }
          }}
        />
      </ActionPanel.Section>
    </ActionPanel>
  }
/>
```

#### Step 3.3: Fix SaveCommandForm Integration

File: `src/search-webhook-workflows.tsx`

```typescript
// Replace the SaveCommandForm push (around line 312)
<Action.Push
  title="Save Webhook Command..."
  icon={Icon.Download}
  target={
    <SaveCommandForm
      method={webhookDetails.method}
      url={webhookFullUrl}
      headers=""
      queryParams=""
      body=""
    />
  }
  shortcut={{ modifiers: ["cmd", "shift"], key: "s" }}
/>
```

### Phase 4: Fix WebhookTriggerForm and ActionSaveCommand (Day 2, Afternoon)

#### Step 4.1: Improve ActionSaveCommand Component

File: `src/components/WebhookTriggerForm.tsx`

```typescript
// Replace the ActionSaveCommand function (around line 163)
function ActionSaveCommand(props: ActionSaveCommandProps) {
  const { method, webhookBaseUrl, headers, queryParams, body, showBodyField } = props;
  const { push } = useNavigation();

  // Construct the final URL using passed props
  const finalUrl = queryParams ? `${webhookBaseUrl}?${queryParams}` : webhookBaseUrl;

  return (
    <Action
      title="Save as Command..."
      icon={Icon.HardDrive}
      shortcut={{ modifiers: ["cmd"], key: "s" }}
      onAction={() => {
        console.log("ActionSaveCommand: Preparing to push SaveCommandForm");
        
        try {
          // Ensure all required props are provided with defaults
          const saveCommandProps = {
            method: method || "GET",
            url: finalUrl,
            headers: headers || "",
            queryParams: queryParams || "",
            body: showBodyField ? (body || "") : ""
          };
          
          console.log("ActionSaveCommand: Props for SaveCommandForm:", JSON.stringify(saveCommandProps));
          
          // Create and push the form
          push(
            <SaveCommandForm
              method={saveCommandProps.method}
              url={saveCommandProps.url}
              headers={saveCommandProps.headers}
              queryParams={saveCommandProps.queryParams}
              body={saveCommandProps.body}
            />
          );
        } catch (error) {
          console.error("Error creating or pushing SaveCommandForm:", error);
          // Show error toast
          showToast({
            style: Toast.Style.Failure,
            title: "Error",
            message: "Failed to open Save Command form"
          });
        }
      }}
    />
  );
}
```

#### Step 4.2: Improve SaveCommandForm Validation

File: `src/components/SaveCommandForm.tsx`

```typescript
// Update the SaveCommandForm component (around line 10)
export default function SaveCommandForm(props: SaveCommandFormProps) {
  console.log("SaveCommandForm: Rendering with props:", JSON.stringify({
    method: props.method,
    url: props.url,
    hasHeaders: !!props.headers,
    hasQueryParams: !!props.queryParams,
    hasBody: !!props.body
  }));
  
  // Ensure all props are properly defined with fallbacks
  const {
    method = "GET",
    url = "",
    headers = "",
    queryParams = "",
    body = ""
  } = props;
  
  // Validate required props
  if (!url) {
    console.error("SaveCommandForm: Missing required URL prop");
  }
  
  if (!method) {
    console.error("SaveCommandForm: Missing required method prop");
  }
  
  const { pop } = useNavigation();

  // Rest of the component...
}
```

### Phase 5: Implement Filter Validation (Day 3, Morning)

#### Step 5.1: Improve Filter Validation in search-webhook-workflows.tsx

File: `src/search-webhook-workflows.tsx`

```typescript
// Replace the filter loading logic (around line 65)
// 1. Load saved filters with robust validation
const storedFilters = await LocalStorage.getItem<string>(TRIGGER_FILTERS_KEY);
let currentFilters: string[] = [];

if (storedFilters) {
  try {
    let parsedFilters: unknown;
    
    try {
      parsedFilters = JSON.parse(storedFilters);
    } catch (parseError) {
      console.error("Failed to parse saved filters:", parseError);
      await LocalStorage.removeItem(TRIGGER_FILTERS_KEY);
      throw new Error("Invalid filter format");
    }
    
    // Validate filters are in the expected format
    if (!Array.isArray(parsedFilters)) {
      console.warn("Saved filters are not in array format, resetting");
      await LocalStorage.removeItem(TRIGGER_FILTERS_KEY);
      throw new Error("Filters not in array format");
    }
    
    // Filter out non-string values and validate each string
    currentFilters = parsedFilters.filter(item => {
      if (typeof item !== 'string') {
        console.warn(`Found non-string filter item: ${typeof item}`);
        return false;
      }
      
      if (item.trim().length === 0) {
        console.warn("Found empty string filter item");
        return false;
      }
      
      return true;
    });
    
    // If we found invalid items, save the cleaned version back
    if (currentFilters.length !== parsedFilters.length) {
      console.warn(`Found ${parsedFilters.length - currentFilters.length} invalid filter items, cleaning up`);
      await LocalStorage.setItem(TRIGGER_FILTERS_KEY, JSON.stringify(currentFilters));
    }
  } catch (error) {
    console.error("Error processing filters:", error);
    currentFilters = []; // Use empty array as fallback
  }
}

setActiveFilters(currentFilters); // Update state for UI indicator
```

#### Step 5.2: Improve TriggerFilterForm Component

File: `src/components/TriggerFilterForm.tsx`

Add validation and error handling to the TriggerFilterForm component.

### Phase 6: Add Comprehensive Error Handling (Day 3, Afternoon)

#### Step 6.1: Add Error Boundary Component

File: `src/components/ErrorBoundary.tsx` (new file)

```typescript
import React from "react";
import { List, ActionPanel, Action, Icon } from "@raycast/api";

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    console.error("Component error:", error);
    console.error("Error info:", errorInfo);
  }

  render(): React.ReactNode {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <List>
          <List.EmptyView
            title="Something Went Wrong"
            description={this.state.error?.message || "An unexpected error occurred"}
            icon={{ source: Icon.ExclamationMark, tintColor: "#FF0000" }}
            actions={
              <ActionPanel>
                <Action
                  title="Try Again"
                  icon={Icon.Repeat}
                  onAction={() => this.setState({ hasError: false })}
                />
              </ActionPanel>
            }
          />
        </List>
      );
    }

    return this.props.children;
  }
}
```

#### Step 6.2: Use Error Boundary in search-webhook-workflows.tsx

File: `src/search-webhook-workflows.tsx`

```typescript
// Import the ErrorBoundary
import { ErrorBoundary } from "./components/ErrorBoundary";

// Wrap the component content with ErrorBoundary
export default function SearchWebhookWorkflowsCommand() {
  // ... existing code ...

  return (
    <ErrorBoundary>
      {/* Existing component content */}
    </ErrorBoundary>
  );
}
```

#### Step 6.3: Add Try-Catch Blocks to Critical Sections

Add try-catch blocks to critical sections throughout the codebase, especially in event handlers and data processing functions.

### Phase 7: Testing and Refinement (Day 4)

#### Step 7.1: Test Each Component Individually

1. Test EmptyView component with different props
2. Test search-webhook-workflows.tsx with different data scenarios
3. Test WebhookTriggerForm and SaveCommandForm

#### Step 7.2: Integration Testing

1. Test the complete workflow from searching to saving commands
2. Test with filters applied and without filters
3. Test error scenarios and recovery

#### Step 7.3: Refinement

Make any necessary adjustments based on testing results.

## Implementation Timeline

| Day | Morning | Afternoon |
|-----|---------|-----------|
| 1 | Add Diagnostic Logging | Fix EmptyView Component |
| 2 | Fix ActionPanel Structure | Fix WebhookTriggerForm and ActionSaveCommand |
| 3 | Implement Filter Validation | Add Comprehensive Error Handling |
| 4 | Testing | Refinement |

## Success Criteria

1. The "Missing required property 'title' for Unknown" error no longer appears
2. The "search triggerable workflows" feature works correctly in all scenarios
3. Filter functionality works properly
4. Error handling is robust and user-friendly

## Rollback Plan

If the changes cause new issues:

1. Revert to the previous version
2. Analyze logs to identify the new issues
3. Create a new plan addressing both the original and new issues