# Plan: n8n Raycast Extension Enhancement

**Project Goal:** Enhance the n8n Raycast extension to use shared API credentials, filter workflows by n8n tags, and allow saving/running predefined webhook triggers.

---

**Phase 0: Preparation & Refinement**

*   **Goal:** Ensure type safety and consistent API interaction before adding new features.
*   **Steps:**
    1.  **Review/Update Types (`src/types/types.ts`):**
        *   Verify `Workflow` interface includes `tags: string[]` (or similar) based on API response. Add if missing.
        *   Confirm `Node` interface accuracy.
    2.  **Review API Utils (`src/utils/n8n-api-utils.ts`):**
        *   Standardize error handling, logging, and `showToast` usage.
    3.  **Review Workflow Utils (`src/utils/workflow-utils.ts`):**
        *   Confirm `getWebhookDetails` logic.

---

**Phase 1: Implement Shared Preferences**

*   **Goal:** Require API URL and Key only once for the entire extension.
*   **Steps:**
    1.  **Modify `package.json`:**
        *   Define `instanceUrl` and `apiKey` in the root `preferences` array.
        *   Remove duplicate definitions from within `commands` (`search-workflows`, `search-webhook-workflows`).
    2.  **Verification:**
        *   Run `npm run dev`, ensure successful build.
        *   Test commands read shared preferences.

---

**Phase 2: Implement Tag Filtering (in "Search Workflows")**

*   **Goal:** Allow filtering the main workflow list using tags defined in n8n.
*   **Steps:**
    1.  **API Endpoint Confirmation:** Verify endpoint for fetching tags (e.g., `GET /api/v1/tags`).
    2.  **Add `getAllTagsAPI()`:** Implement in `src/utils/n8n-api-utils.ts`.
    3.  **Update `search-workflows.tsx`:**
        *   Add state for tags.
        *   Fetch tags alongside workflows.
        *   Dynamically populate `List.Dropdown` with fetched tags + "All Tags".
        *   Modify filtering logic to use `workflow.tags`.
    4.  **Cleanup:** Remove hardcoded `filterTag` constant and imports.

---

**Phase 3: Implement Saved Commands (Webhook Triggers)**

*   **Goal:** Allow users to save specific webhook configurations and run them from a dedicated command.
*   **Steps:**
    1.  **Define `SavedCommand` Type (`src/types/types.ts`):**
        ```typescript
        interface SavedCommand {
          id: string; // Unique ID
          name: string; // User-defined name
          method: string;
          url: string; // Full trigger URL
          headers?: string; // Store as string
          queryParams?: string; // Store as string
          body?: string; // Store as string
        }
        ```
    2.  **Create Storage Utilities (`src/utils/storage-utils.ts`):**
        *   Implement `getSavedCommands`, `addSavedCommand`, `deleteSavedCommand` using `LocalStorage`. Handle JSON parsing/stringifying.
    3.  **Add "Save" Action (`WebhookTriggerForm.tsx`):**
        *   Add `<Action title="Save as Command..." icon={Icon.Save} onAction={() => push(<SaveCommandForm ... />)} />`.
        *   Pass current form values (headers, query, body) + method/URL to `SaveCommandForm`.
    4.  **Create `SaveCommandForm.tsx`:**
        *   Takes webhook details as props.
        *   Renders a form with a `name` field.
        *   On submit, calls `addSavedCommand`, then `pop()`.
    5.  **Create `run-saved-command` Command:**
        *   Define command (e.g., `run-saved-command`) in `package.json`.
        *   Create `src/run-saved-command.tsx`.
        *   Fetch and display saved commands from `LocalStorage` in a `List`.
        *   Primary action calls `triggerWebhook` with saved details.
        *   Add secondary action to call `deleteSavedCommand`.

---

**Phase 4: Final Testing & Cleanup**

*   **Goal:** Ensure stability and polish.
*   **Steps:**
    1.  Test all commands and features thoroughly (including edge cases).
    2.  Test saving, running, deleting saved commands.
    3.  Review code for cleanup opportunities.
    4.  Consider updating `README.md`.

---