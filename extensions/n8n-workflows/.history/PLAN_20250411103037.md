# Plan: n8n Raycast Extension Enhancement

**Project Goal:** Enhance the n8n Raycast extension to use shared API credentials, filter workflows by n8n tags, and allow saving/running predefined webhook triggers.

---

**Phase 0: Preparation & Refinement**

*   **Goal:** Ensure type safety and consistent API interaction before adding new features.
*   **Steps:**
    1.  **Review/Update Types (`src/types/types.ts`):**
        *   Verify `Workflow` interface includes `tags: Tag[]` (or similar) based on API response. Add if missing. (Completed - was `Tag[]`)
        *   Confirm `Node` interface accuracy. (Completed - added `id`)
    2.  **Review API Utils (`src/utils/n8n-api-utils.ts`):**
        *   Standardize error handling, logging, and `showToast` usage. (Partially done during debugging)
    3.  **Review Workflow Utils (`src/utils/workflow-utils.ts`):**
        *   Confirm `getWebhookDetails` logic. (Completed)

---

**Phase 1: Implement Shared Preferences**

*   **Goal:** Require API URL and Key only once for the entire extension.
*   **Status:** Completed.
*   **Steps:**
    1.  **Modify `package.json`:**
        *   Define `instanceUrl` and `apiKey` in the root `preferences` array.
        *   Remove duplicate definitions from within `commands` (`search-workflows`, `search-webhook-workflows`).
    2.  **Verification:**
        *   Run `npm run dev`, ensure successful build.
        *   Test commands read shared preferences.

---

**Phase 2: Implement Tag Filtering (in "Search Workflows")**

*   **Goal:** Allow filtering the main workflow list using tags defined in n8n.
*   **Status:** Completed.
*   **Steps:**
    1.  **API Endpoint Confirmation:** Assumed `GET /api/v1/tags`. Verified working during testing.
    2.  **Add `getAllTagsAPI()`:** Implemented in `src/utils/n8n-api-utils.ts`.
    3.  **Update `search-workflows.tsx`:**
        *   Added state for tags.
        *   Fetched tags alongside workflows (adjusted to fetch sequentially for robustness).
        *   Dynamically populated `List.Dropdown` with fetched tags + "All Tags".
        *   Modified filtering logic to use `workflow.tags` (checking `tag.name`).
    4.  **Cleanup:** Removed hardcoded `filterTag` constant and imports.

---

**Phase 3: Implement Saved Commands (Webhook Triggers)**

*   **Goal:** Allow users to save specific webhook configurations and run them from a dedicated command.
*   **Status:** Pending.
*   **Steps:**
    1.  **Define `SavedCommand` Type (`src/types/types.ts`):**
        ```typescript
        interface SavedCommand {
          id: string; // Unique ID
          name: string; // User-defined name
          method: string;
          url: string; // Full trigger URL
          headers?: string; // Store as string
          queryParams?: string; // Store as string
          body?: string; // Store as string
        }
        ```
    2.  **Create Storage Utilities (`src/utils/storage-utils.ts`):**
        *   Implement `getSavedCommands`, `addSavedCommand`, `deleteSavedCommand` using `LocalStorage`. Handle JSON parsing/stringifying.
    3.  **Add "Save" Action (`WebhookTriggerForm.tsx`):**
        *   Add `<Action title="Save as Command..." icon={Icon.Save} onAction={() => push(<SaveCommandForm ... />)} />`.
        *   Pass current form values (headers, query, body) + method/URL to `SaveCommandForm`.
    4.  **Create `SaveCommandForm.tsx`:**
        *   Takes webhook details as props.
        *   Renders a form with a `name` field.
        *   On submit, calls `addSavedCommand`, then `pop()`.
    5.  **Create `run-saved-command` Command:**
        *   Define command (e.g., `run-saved-command`) in `package.json`.
        *   Create `src/run-saved-command.tsx`.
        *   Fetch and display saved commands from `LocalStorage` in a `List`.
        *   Primary action calls `triggerWebhook` with saved details.
        *   Add secondary action to call `deleteSavedCommand`.

---

**Phase 4: Persistent Tag Filtering for Triggerable Workflows**

*   **Goal:** Allow persistent filtering of triggerable workflows through dedicated settings
*   **Status:** Pending
*   **Steps:**
    1. **Storage System Enhancement**:
        - Add `TRIGGER_FILTERS_KEY` to `src/utils/constants.ts`
        - Create `saveTriggerFilters()` and `loadTriggerFilters()` in `src/utils/storage-utils.ts`
        - Extend Preferences type in `search-workflows.tsx` with `triggerFilters: string[]`
    
    2. **Settings Interface**:
        - Create `TagPreferencesForm.tsx` component with multi-select tag UI
        - Add new entry to `action-open-preferences.tsx` linking to settings
        - Implement tag selection persistence using LocalStorage
    
    3. **Workflow Filter Integration**:
        - Modify `search-webhook-workflows.tsx` to load stored filters
        - Update filtering logic to match workflows against stored tag IDs
        - Add visual indicator when filters are active
    
    4. **Validation**:
        - Handle cases where stored tags no longer exist in n8n
        - Add "Clear Filters" action to reset to default state

---

**Phase 5: Final Testing & Cleanup**

*   **Goal:** Ensure stability and polish.
*   **Status:** Pending.
*   **Steps:**
    1.  Test all commands and features thoroughly (including edge cases).
    2.  Test saving, running, deleting saved commands.
    3.  Verify tag filter persistence across extension restarts
    4.  Test filter synchronization between settings and workflow lists
    5.  Validate error handling for missing/invalid stored tags
    6.  Review code for cleanup opportunities.
    7.  Consider updating `README.md`.

---

**Reflections & Learnings**

*   **JSON Syntax:** Be extra careful with JSON files (`package.json`) - no comments allowed, watch for trailing commas. Validate JSON structure before applying changes if unsure.
*   **Type Definitions vs. Reality:** TypeScript types (`src/types/types.ts`) must accurately reflect the actual data structure returned by the API. If discrepancies occur (like `workflow.tags` being `Tag[]` instead of `string[]`), update the types. Use `console.log` on raw API responses during development to verify structures.
*   **API Call Robustness:** When fetching multiple independent data sources (like workflows and tags), fetching them sequentially can be more robust than `Promise.all` if one source failing shouldn't block the display of the other. Handle errors gracefully for non-critical data fetches (like tags).
*   **Raycast Build vs. Runtime Errors:** Distinguish between build errors reported by `ray dev` (syntax errors, missing files/modules) and runtime errors seen in the Raycast console or logs (API errors, component rendering issues).
*   **Raycast Component Structure:** Pay attention to how Raycast components like `ActionPanel` and `ActionPanel.Section` should be nested to avoid runtime errors (e.g., `Missing required property "title"`).

---