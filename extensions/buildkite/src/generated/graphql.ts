import { GraphQLClient } from 'graphql-request';
import { GraphQLClientRequestHeaders } from 'graphql-request/build/cjs/types';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** An ISO-8601 encoded UTC date string */
  DateTime: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /**
   * Represents non-fractional signed whole numeric values.
   *
   * `JSInt` can represent values between -(2^53) + 1 and 2^53 - 1.
   */
  JSInt: { input: any; output: any; }
  /** A blob of JSON represented as a pretty formatted string */
  JSON: { input: any; output: any; }
  /** A Pipeline identifier using a slug, and optionally negated with a leading `!` */
  PipelineSelector: { input: any; output: any; }
  /** A Team identifier using a slug, and optionally negated with a leading `!` */
  TeamSelector: { input: any; output: any; }
  /** A User identifier using a UUID, and optionally negated with a leading `!` */
  UserSelector: { input: any; output: any; }
  /** A blob of XML represented as a pretty formatted string */
  XML: { input: any; output: any; }
  /** A blob of YAML */
  YAML: { input: any; output: any; }
};

/** API access tokens for authentication with the Buildkite API */
export type ApiAccessToken = Node & {
  id: Scalars['ID']['output'];
  /** The public UUID for the API Access Token */
  uuid: Scalars['ID']['output'];
};

/** A code that is used by an API Application to request an API Access Token */
export type ApiAccessTokenCode = Node & {
  application: Maybe<ApiApplication>;
  /** The time when this code was authorized by a user */
  authorizedAt: Maybe<Scalars['DateTime']['output']>;
  /** The IP address of the client that authorized this code */
  authorizedIPAddress: Maybe<Scalars['String']['output']>;
  /** The actual code used to find this API Access Token Code record */
  code: Scalars['String']['output'];
  /** The description of the code provided by the API Application */
  description: Scalars['String']['output'];
  /** The time when this code will expire */
  expiresAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
};

/** Autogenerated input type of APIAccessTokenCodeAuthorizeMutation */
export type ApiAccessTokenCodeAuthorizeMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of APIAccessTokenCodeAuthorizeMutation. */
export type ApiAccessTokenCodeAuthorizeMutationPayload = {
  apiAccessTokenCode: ApiAccessTokenCode;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

/** All possible scopes on a user's API Access Token */
export type ApiAccessTokenScopes =
  | 'GRAPHQL'
  | 'READ_AGENTS'
  | 'READ_ARTIFACTS'
  | 'READ_BUILDS'
  | 'READ_BUILD_LOGS'
  | 'READ_CLUSTERS'
  | 'READ_JOB_ENV'
  | 'READ_NOTIFICATION_SERVICES'
  | 'READ_ORGANIZATIONS'
  | 'READ_PIPELINES'
  | 'READ_PIPELINE_TEMPLATES'
  | 'READ_SUITES'
  | 'READ_TEAMS'
  | 'READ_USER'
  | 'WRITE_AGENTS'
  | 'WRITE_ARTIFACTS'
  | 'WRITE_BUILDS'
  | 'WRITE_BUILD_LOGS'
  | 'WRITE_CLUSTERS'
  | 'WRITE_NOTIFICATION_SERVICES'
  | 'WRITE_PIPELINES'
  | 'WRITE_PIPELINE_TEMPLATES'
  | 'WRITE_SUITES';

/** An API Application */
export type ApiApplication = Node & {
  /** A description of the application */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The name of this application */
  name: Scalars['String']['output'];
};

/** An agent */
export type Agent = Node & {
  clusterQueue: Maybe<ClusterQueue>;
  /** The time when the agent connected to Buildkite */
  connectedAt: Maybe<Scalars['DateTime']['output']>;
  /** The connection state of the agent */
  connectionState: Scalars['String']['output'];
  /** The date the agent was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when the agent disconnected from Buildkite */
  disconnectedAt: Maybe<Scalars['DateTime']['output']>;
  /** The last time the agent performed a `heartbeat` operation to the Agent API */
  heartbeatAt: Maybe<Scalars['DateTime']['output']>;
  /** The hostname of the machine running the agent */
  hostname: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The IP address that the agent has connected from */
  ipAddress: Maybe<Scalars['String']['output']>;
  /** If this version of agent has been deprecated by Buildkite */
  isDeprecated: Scalars['Boolean']['output'];
  /**
   * Returns whether or not this agent is running a job. If isRunningJob true, but
   * the `job` field is empty, the current user doesn't have access to view the job
   */
  isRunningJob: Scalars['Boolean']['output'];
  /** The currently running job */
  job: Maybe<Job>;
  /** Jobs that have been assigned to this agent */
  jobs: Maybe<JobConnection>;
  /** The date the agent was lost from Buildkite if it didn't cleanly disconnect */
  lostAt: Maybe<Scalars['DateTime']['output']>;
  /** The meta data this agent was stared with */
  metaData: Maybe<Array<Scalars['String']['output']>>;
  /** The name of the agent */
  name: Scalars['String']['output'];
  /** The operating system the agent is running on */
  operatingSystem: Maybe<OperatingSystem>;
  organization: Maybe<Organization>;
  permissions: AgentPermissions;
  /** The process identifier (PID) of the agent process on the machine */
  pid: Maybe<Scalars['String']['output']>;
  /** @deprecated DEPRECATED: please use heartbeatAt */
  pingedAt: Maybe<Scalars['DateTime']['output']>;
  /** The priority setting for the agent */
  priority: Maybe<Scalars['Int']['output']>;
  /** Whether this agent is visible to everyone, including people outside this organization */
  public: Scalars['Boolean']['output'];
  /** The time this agent was forced to stop */
  stopForcedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that forced this agent to stop */
  stopForcedBy: Maybe<User>;
  /**
   * The time the agent was first asked to stop
   * @deprecated Use either `stoppedGracefullyAt` or `stopForcedAt`
   */
  stoppedAt: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user that initially stopped this agent
   * @deprecated Use either `stoppedGracefullyBy` or `stopForcedBy`
   */
  stoppedBy: Maybe<User>;
  /** The time the agent was gracefully stopped by a user */
  stoppedGracefullyAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that gracefully stopped this agent */
  stoppedGracefullyBy: Maybe<User>;
  /** The User-Agent of the program that is making Agent API requests to Buildkite */
  userAgent: Maybe<Scalars['String']['output']>;
  /** The public UUID for the agent */
  uuid: Scalars['String']['output'];
  /** The version of the agent */
  version: Maybe<Scalars['String']['output']>;
  /** Whether this agent's version has known issues and should be upgraded */
  versionHasKnownIssues: Scalars['Boolean']['output'];
};


/** An agent */
export type AgentJobsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  agentQueryRules: InputMaybe<Array<Scalars['String']['input']>>;
  before: InputMaybe<Scalars['String']['input']>;
  concurrency: InputMaybe<JobConcurrencySearch>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<JobOrder>;
  passed: InputMaybe<Scalars['Boolean']['input']>;
  priority: InputMaybe<Scalars['Int']['input']>;
  state: InputMaybe<Array<JobStates>>;
  step: InputMaybe<JobStepSearch>;
  type: InputMaybe<Array<JobTypes>>;
};

export type AgentConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<AgentEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type AgentEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Agent>;
};

/** Permissions information about what actions the current user can do against this agent */
export type AgentPermissions = {
  /** Whether the user can stop the agent remotely */
  agentStop: Maybe<Permission>;
};

/** Autogenerated input type of AgentStop */
export type AgentStopInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** If this agent should finish the current job before stopping */
  graceful: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of AgentStop. */
export type AgentStopPayload = {
  agent: Agent;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

/** A token used to connect an agent to Buildkite */
export type AgentToken = Node & {
  /** The time this agent token was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that created this agent token */
  createdBy: Maybe<User>;
  /** A description about what this agent token is used for */
  description: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  organization: Maybe<Organization>;
  permissions: AgentTokenPermissions;
  /** Whether agents registered with this token will be visible to everyone, including people outside this organization */
  public: Scalars['Boolean']['output'];
  /** The time this agent token was revoked */
  revokedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that revoked this agent token */
  revokedBy: Maybe<User>;
  /** The reason as defined by the user why this token was revoked */
  revokedReason: Maybe<Scalars['String']['output']>;
  /**
   * The token value used to register a new agent
   * @deprecated Hiding these after creation to improve security. Use the `token_value` field on AgentTokenCreate instead.
   */
  token: Scalars['String']['output'];
  /** The public UUID for the agent */
  uuid: Scalars['ID']['output'];
};

export type AgentTokenConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<AgentTokenEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of AgentTokenCreate */
export type AgentTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  description: InputMaybe<Scalars['String']['input']>;
  organizationID: Scalars['ID']['input'];
  public: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of AgentTokenCreate. */
export type AgentTokenCreatePayload = {
  agentTokenEdge: AgentTokenEdge;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Organization;
  /**
   * The token value used to register a new agent. Please ensure to securely copy
   * this value immediately upon generation as it will not be displayed again.
   */
  tokenValue: Scalars['String']['output'];
};

export type AgentTokenEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<AgentToken>;
};

/** Permissions information about what actions the current user can do against the agent token */
export type AgentTokenPermissions = {
  /** Whether the user can revoke this agent token */
  agentTokenRevoke: Maybe<Permission>;
};

/** Autogenerated input type of AgentTokenRevoke */
export type AgentTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** The reason why this agent token should be revoked */
  reason: Scalars['String']['input'];
};

/** Autogenerated return type of AgentTokenRevoke. */
export type AgentTokenRevokePayload = {
  agentToken: AgentToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

/** An annotation allows you to add arbitrary content to the top of a build page in the Buildkite UI */
export type Annotation = Node & {
  /** The body of the annotation */
  body: Maybe<AnnotationBody>;
  /** The context of the annotation that helps you differentiate this one from others */
  context: Scalars['String']['output'];
  /** The date the annotation was created */
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** The visual style of the annotation */
  style: Maybe<AnnotationStyle>;
  /** The last time the annotation was changed */
  updatedAt: Maybe<Scalars['DateTime']['output']>;
  /** The public UUID for this annotation */
  uuid: Scalars['ID']['output'];
};

/** A body of an annotation */
export type AnnotationBody = {
  /**
   * The body of the annotation rendered as HTML. The renderer result could be an
   * empty string if the textual version has unsupported HTML tags
   */
  html: Maybe<Scalars['String']['output']>;
  /** The body of the annotation as text */
  text: Scalars['String']['output'];
};

export type AnnotationConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<AnnotationEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type AnnotationEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Annotation>;
};

/** The visual style of the annotation */
export type AnnotationStyle =
  /** The default styling of an annotation */
  | 'DEFAULT'
  /** The annotation has a red border with a cross next to it */
  | 'ERROR'
  /** The annotation has a blue border with an information icon next to it */
  | 'INFO'
  /** The annotation has a green border with a tick next to it */
  | 'SUCCESS'
  /** The annotation has an orange border with a warning icon next to it */
  | 'WARNING';

/** A file uploaded from the agent whilst running a job */
export type Artifact = Node & {
  /**
   * The download URL for the artifact. Unless you've used your own artifact
   * storage, the URL will be valid for only 10 minutes.
   */
  downloadURL: Scalars['String']['output'];
  /** The time when the artifact will, or did, expire */
  expiresAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The job that uploaded this artifact */
  job: Maybe<JobTypeCommand>;
  /** The mime type of the file provided by the agent */
  mimeType: Scalars['String']['output'];
  /** The path of the uploaded artifact */
  path: Scalars['String']['output'];
  /** A SHA1SUM of the file */
  sha1sum: Scalars['String']['output'];
  /** The size of the file in bytes that was uploaded */
  size: Scalars['Int']['output'];
  /** The upload state of the artifact */
  state: Scalars['String']['output'];
  /** The public UUID for this artifact */
  uuid: Scalars['ID']['output'];
};

export type ArtifactConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<ArtifactEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type ArtifactEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Artifact>;
};

/** Context for an audit event created during an REST/GraphQL API request */
export type AuditApiContext = {
  /** The remote IP which made the request */
  requestIpAddress: Maybe<Scalars['String']['output']>;
  /** The client supplied user agent which made the request */
  requestUserAgent: Maybe<Scalars['String']['output']>;
};

/** The actor who caused an AuditEvent */
export type AuditActor = {
  /** The GraphQL ID for this actor */
  id: Scalars['ID']['output'];
  /** The name or short description of this actor */
  name: Maybe<Scalars['String']['output']>;
  /** The node corresponding to this actor, if available */
  node: Maybe<AuditActorNode>;
  /** The type of this actor */
  type: Maybe<AuditActorType>;
  /** The public UUID of this actor */
  uuid: Scalars['ID']['output'];
};

/** Kinds of actors which can perform audit events */
export type AuditActorNode = User;

/** All the possible types of actors in an Audit Event */
export type AuditActorType =
  | 'USER';

/** Kinds of contexts in which an audit event can be performed */
export type AuditContext = AuditApiContext | AuditWebContext;

/** Audit record of an event which occurred in the system */
export type AuditEvent = Node & {
  /** The actor who caused this event */
  actor: Maybe<AuditActor>;
  /** The context in which this event occurred */
  context: Maybe<AuditContext>;
  /** The changed data in the event */
  data: Maybe<Scalars['JSON']['output']>;
  id: Scalars['ID']['output'];
  /** The time at which this event occurred */
  occurredAt: Scalars['DateTime']['output'];
  /** The subject of this event */
  subject: Maybe<AuditSubject>;
  /** The type of event */
  type: AuditEventType;
  /** The public UUID for the event */
  uuid: Scalars['ID']['output'];
};

/** All the possible types of an Audit Event */
export type AuditEventType =
  | 'AGENT_TOKEN_CREATED'
  | 'AGENT_TOKEN_REVOKED'
  | 'AGENT_TOKEN_UPDATED'
  | 'API_ACCESS_TOKEN_CREATED'
  | 'API_ACCESS_TOKEN_DELETED'
  | 'API_ACCESS_TOKEN_ORGANIZATION_ACCESS_REVOKED'
  | 'API_ACCESS_TOKEN_UPDATED'
  | 'AUTHORIZATION_CREATED'
  | 'AUTHORIZATION_DELETED'
  | 'CLUSTER_CREATED'
  | 'CLUSTER_DELETED'
  | 'CLUSTER_PERMISSION_CREATED'
  | 'CLUSTER_PERMISSION_DELETED'
  | 'CLUSTER_QUEUE_CREATED'
  | 'CLUSTER_QUEUE_DELETED'
  | 'CLUSTER_QUEUE_TOKEN_CREATED'
  | 'CLUSTER_QUEUE_TOKEN_DELETED'
  | 'CLUSTER_QUEUE_TOKEN_UPDATED'
  | 'CLUSTER_QUEUE_UPDATED'
  | 'CLUSTER_TOKEN_CREATED'
  | 'CLUSTER_TOKEN_DELETED'
  | 'CLUSTER_TOKEN_UPDATED'
  | 'CLUSTER_UPDATED'
  | 'NOTIFICATION_SERVICE_BROKEN'
  | 'NOTIFICATION_SERVICE_CREATED'
  | 'NOTIFICATION_SERVICE_DELETED'
  | 'NOTIFICATION_SERVICE_DISABLED'
  | 'NOTIFICATION_SERVICE_ENABLED'
  | 'NOTIFICATION_SERVICE_UPDATED'
  | 'ORGANIZATION_BANNER_CREATED'
  | 'ORGANIZATION_BANNER_DELETED'
  | 'ORGANIZATION_BANNER_UPDATED'
  | 'ORGANIZATION_BUILD_EXPORT_UPDATED'
  | 'ORGANIZATION_CREATED'
  | 'ORGANIZATION_DELETED'
  | 'ORGANIZATION_INVITATION_ACCEPTED'
  | 'ORGANIZATION_INVITATION_CREATED'
  | 'ORGANIZATION_INVITATION_RESENT'
  | 'ORGANIZATION_INVITATION_REVOKED'
  | 'ORGANIZATION_MEMBER_CREATED'
  | 'ORGANIZATION_MEMBER_DELETED'
  | 'ORGANIZATION_MEMBER_UPDATED'
  | 'ORGANIZATION_TEAMS_DISABLED'
  | 'ORGANIZATION_TEAMS_ENABLED'
  | 'ORGANIZATION_UPDATED'
  | 'PIPELINE_CREATED'
  | 'PIPELINE_DELETED'
  | 'PIPELINE_SCHEDULE_CREATED'
  | 'PIPELINE_SCHEDULE_DELETED'
  | 'PIPELINE_SCHEDULE_UPDATED'
  | 'PIPELINE_TEMPLATE_CREATED'
  | 'PIPELINE_TEMPLATE_DELETED'
  | 'PIPELINE_TEMPLATE_UPDATED'
  | 'PIPELINE_UPDATED'
  | 'PIPELINE_VISIBILITY_CHANGED'
  | 'PIPELINE_WEBHOOK_URL_ROTATED'
  | 'SCM_PIPELINE_SETTINGS_CREATED'
  | 'SCM_PIPELINE_SETTINGS_DELETED'
  | 'SCM_PIPELINE_SETTINGS_UPDATED'
  | 'SCM_REPOSITORY_HOST_CREATED'
  | 'SCM_REPOSITORY_HOST_DESTROYED'
  | 'SCM_REPOSITORY_HOST_UPDATED'
  | 'SCM_SERVICE_CREATED'
  | 'SCM_SERVICE_DELETED'
  | 'SCM_SERVICE_UPDATED'
  | 'SSO_PROVIDER_CREATED'
  | 'SSO_PROVIDER_DELETED'
  | 'SSO_PROVIDER_DISABLED'
  | 'SSO_PROVIDER_ENABLED'
  | 'SSO_PROVIDER_UPDATED'
  | 'SUBSCRIPTION_PLAN_CHANGED'
  | 'SUBSCRIPTION_PLAN_CHANGE_SCHEDULED'
  | 'SUITE_API_TOKEN_REGENERATED'
  | 'SUITE_CREATED'
  | 'SUITE_DELETED'
  | 'SUITE_MONITOR_CREATED'
  | 'SUITE_MONITOR_DELETED'
  | 'SUITE_MONITOR_UPDATED'
  | 'SUITE_UPDATED'
  | 'SUITE_VISIBILITY_CHANGED'
  | 'TEAM_CREATED'
  | 'TEAM_DELETED'
  | 'TEAM_MEMBER_CREATED'
  | 'TEAM_MEMBER_DELETED'
  | 'TEAM_MEMBER_UPDATED'
  | 'TEAM_PIPELINE_CREATED'
  | 'TEAM_PIPELINE_DELETED'
  | 'TEAM_PIPELINE_UPDATED'
  | 'TEAM_SUITE_CREATED'
  | 'TEAM_SUITE_DELETED'
  | 'TEAM_SUITE_UPDATED'
  | 'TEAM_UPDATED'
  | 'USER_API_ACCESS_TOKEN_ORGANIZATION_ACCESS_ADDED'
  | 'USER_API_ACCESS_TOKEN_ORGANIZATION_ACCESS_REMOVED'
  | 'USER_EMAIL_CREATED'
  | 'USER_EMAIL_DELETED'
  | 'USER_EMAIL_MARKED_PRIMARY'
  | 'USER_EMAIL_VERIFIED'
  | 'USER_PASSWORD_RESET'
  | 'USER_PASSWORD_RESET_REQUESTED'
  | 'USER_TOTP_ACTIVATED'
  | 'USER_TOTP_CREATED'
  | 'USER_TOTP_DELETED'
  | 'USER_UPDATED';

/** The subject of an AuditEvent */
export type AuditSubject = {
  /** The GraphQL ID for the subject */
  id: Scalars['ID']['output'];
  /** The name or short description of this subject */
  name: Maybe<Scalars['String']['output']>;
  /** The node corresponding to the subject, if available */
  node: Maybe<AuditSubjectNode>;
  /** The type of this subject */
  type: Maybe<AuditSubjectType>;
  /** The public UUID of this subject */
  uuid: Scalars['ID']['output'];
};

/** Kinds of subjects which can have audit events performed on them */
export type AuditSubjectNode = ApiAccessToken | AgentToken | AuthorizationBitbucket | AuthorizationGitHub | AuthorizationGitHubEnterprise | Cluster | ClusterPermission | ClusterQueue | ClusterQueueToken | ClusterToken | Email | NotificationServiceSlack | NotificationServiceWebhook | Organization | OrganizationBanner | OrganizationInvitation | OrganizationMember | Pipeline | PipelineSchedule | PipelineTemplate | ScmPipelineSettings | ScmRepositoryHost | ScmService | SsoProviderGitHubApp | SsoProviderGoogleGSuite | SsoProviderSaml | Subscription | Suite | Totp | Team | TeamMember | TeamPipeline | TeamSuite | User;

/** All the possible types of subjects in an Audit Event */
export type AuditSubjectType =
  | 'AGENT_TOKEN'
  | 'API_ACCESS_TOKEN'
  | 'AUTHORIZATION'
  | 'CLUSTER'
  | 'CLUSTER_PERMISSION'
  | 'CLUSTER_QUEUE'
  | 'CLUSTER_QUEUE_TOKEN'
  | 'CLUSTER_TOKEN'
  | 'NOTIFICATION_SERVICE'
  | 'ORGANIZATION'
  | 'ORGANIZATION_BANNER'
  | 'ORGANIZATION_INVITATION'
  | 'ORGANIZATION_MEMBER'
  | 'PIPELINE'
  | 'PIPELINE_SCHEDULE'
  | 'PIPELINE_TEMPLATE'
  | 'SCM_PIPELINE_SETTINGS'
  | 'SCM_REPOSITORY_HOST'
  | 'SCM_SERVICE'
  | 'SSO_PROVIDER'
  | 'SUBSCRIPTION'
  | 'SUITE'
  | 'SUITE_MONITOR'
  | 'TEAM'
  | 'TEAM_MEMBER'
  | 'TEAM_PIPELINE'
  | 'TEAM_SUITE'
  | 'USER'
  | 'USER_EMAIL'
  | 'USER_TOTP';

/** Context for an audit event created during a web request */
export type AuditWebContext = {
  /** The remote IP which made the request */
  requestIpAddress: Maybe<Scalars['String']['output']>;
  /** The client supplied user agent which made the request */
  requestUserAgent: Maybe<Scalars['String']['output']>;
  /** When the session started, if available */
  sessionCreatedAt: Maybe<Scalars['DateTime']['output']>;
  /** When the session was escalated, if available and escalated */
  sessionEscalatedAt: Maybe<Scalars['DateTime']['output']>;
  /** The session's authenticated user, if available */
  sessionUser: Maybe<User>;
  /** The session's authenticated user's uuid */
  sessionUserUuid: Maybe<Scalars['ID']['output']>;
};

export type Authorization = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A Bitbucket account authorized with a Buildkite account */
export type AuthorizationBitbucket = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

export type AuthorizationConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<AuthorizationEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type AuthorizationEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Authorization>;
};

/** A GitHub account authorized with a Buildkite account */
export type AuthorizationGitHub = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A GitHub app authorized with a Buildkite account */
export type AuthorizationGitHubApp = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A GitHub Enterprise account authorized with a Buildkite account */
export type AuthorizationGitHubEnterprise = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A Google account authorized with a Buildkite account */
export type AuthorizationGoogle = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A SAML account authorized with a Buildkite account */
export type AuthorizationSaml = Authorization & Node & {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The type of the authorization */
export type AuthorizationType =
  /** Bitbucket Authorization */
  | 'BITBUCKET'
  /** GitHub Authorization */
  | 'GITHUB'
  /** GitHub Enterprise Authorization */
  | 'GITHUB_ENTERPRISE';

/** An avatar belonging to a user */
export type Avatar = {
  /** The URL of the avatar */
  url: Scalars['String']['output'];
};

/** A build from a pipeline */
export type Build = Node & {
  annotations: Maybe<AnnotationConnection>;
  /** The current blocked state of the build */
  blockedState: Maybe<BuildBlockedStates>;
  /** The branch for the build */
  branch: Scalars['String']['output'];
  /** The time when the build was cancelled */
  canceledAt: Maybe<Scalars['DateTime']['output']>;
  /**
   * The user who canceled this build. If the build was canceled, and this value is
   * null, then it was canceled automatically by Buildkite
   */
  canceledBy: Maybe<User>;
  /** The fully-qualified commit for the build */
  commit: Scalars['String']['output'];
  /** The time when the build was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  createdBy: Maybe<BuildCreator>;
  /** Custom environment variables passed to this build */
  env: Maybe<Array<Scalars['String']['output']>>;
  /** The time when the build finished */
  finishedAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  jobs: Maybe<JobConnection>;
  /** The message for the build */
  message: Maybe<Scalars['String']['output']>;
  metaData: Maybe<BuildMetaDataConnection>;
  /** The number of the build */
  number: Scalars['Int']['output'];
  organization: Organization;
  pipeline: Pipeline;
  pullRequest: Maybe<PullRequest>;
  /** The build that this build was rebuilt from */
  rebuiltFrom: Maybe<Build>;
  /** The time when the build became scheduled for running */
  scheduledAt: Maybe<Scalars['DateTime']['output']>;
  /** Where the build was created */
  source: BuildSource;
  /** The time when the build started running */
  startedAt: Maybe<Scalars['DateTime']['output']>;
  /** The current state of the build */
  state: BuildStates;
  /** The job that this build was triggered from */
  triggeredFrom: Maybe<JobTypeTrigger>;
  /** The URL for the build */
  url: Scalars['String']['output'];
  /** The UUID for the build */
  uuid: Scalars['String']['output'];
};


/** A build from a pipeline */
export type BuildAnnotationsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  style: InputMaybe<Array<AnnotationStyle>>;
};


/** A build from a pipeline */
export type BuildJobsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  agentQueryRules: InputMaybe<Array<Scalars['String']['input']>>;
  before: InputMaybe<Scalars['String']['input']>;
  concurrency: InputMaybe<JobConcurrencySearch>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<JobOrder>;
  passed: InputMaybe<Scalars['Boolean']['input']>;
  priority: InputMaybe<JobPrioritySearch>;
  state: InputMaybe<Array<JobStates>>;
  step: InputMaybe<JobStepSearch>;
  type: InputMaybe<Array<JobTypes>>;
};


/** A build from a pipeline */
export type BuildMetaDataArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of BuildAnnotate */
export type BuildAnnotateInput = {
  /** Append to an existing annotation */
  append: InputMaybe<Scalars['Boolean']['input']>;
  /** The body of the annotation. Markdown and some limited HTML is supported */
  body: InputMaybe<Scalars['String']['input']>;
  /** The GraphQL ID of the build you want to annotate */
  buildID: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** A string label to differentiate this annotation from other annotations. The default is `default` */
  context: InputMaybe<Scalars['String']['input']>;
  /** The style of the annotation. The default is `DEFAULT` */
  style: InputMaybe<AnnotationStyle>;
};

/** Autogenerated return type of BuildAnnotate. */
export type BuildAnnotatePayload = {
  annotation: Maybe<Annotation>;
  annotationEdge: Maybe<AnnotationEdge>;
  build: Maybe<Build>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

/** Author for a build */
export type BuildAuthorInput = {
  /** The email for the build author */
  email: Scalars['String']['input'];
  /** The name for the build author */
  name: Scalars['String']['input'];
};

/** All the possible blocked states a build can be in */
export type BuildBlockedStates =
  /** The blocked build is failed */
  | 'FAILED'
  /** The blocked build is passed */
  | 'PASSED'
  /** The blocked build is running */
  | 'RUNNING';

/** Autogenerated input type of BuildCancel */
export type BuildCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of BuildCancel. */
export type BuildCancelPayload = {
  build: Build;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

export type BuildConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<BuildEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of BuildCreate */
export type BuildCreateInput = {
  author: InputMaybe<BuildAuthorInput>;
  /** The branch for the build */
  branch: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** The commit for the build */
  commit: InputMaybe<Scalars['String']['input']>;
  /** Environment variables used for the build */
  env: InputMaybe<Array<Scalars['String']['input']>>;
  /** The message that is displayed on the build */
  message: InputMaybe<Scalars['String']['input']>;
  metaData: InputMaybe<Array<BuildMetaDataInput>>;
  /** The GraphQL ID of the pipeline you want to create a build on */
  pipelineID: Scalars['ID']['input'];
};

/** Autogenerated return type of BuildCreate. */
export type BuildCreatePayload = {
  build: Maybe<Build>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

/** Either a `User` or an `UnregisteredUser` type */
export type BuildCreator = UnregisteredUser | User;

export type BuildEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Build>;
};

/** A comment on a build */
export type BuildMetaData = {
  /** The key used to set this meta data */
  key: Scalars['String']['output'];
  /** The value set to this meta data */
  value: Scalars['String']['output'];
};

export type BuildMetaDataConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<BuildMetaDataEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type BuildMetaDataEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<BuildMetaData>;
};

/** Meta-data key/value pairs for a build */
export type BuildMetaDataInput = {
  /** The key for this meta-data item */
  key: Scalars['String']['input'];
  /** The value for this meta-data item */
  value: Scalars['String']['input'];
};

/** Autogenerated input type of BuildRebuild */
export type BuildRebuildInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of BuildRebuild. */
export type BuildRebuildPayload = {
  build: Build;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  rebuild: Build;
};

/** All the possible build retention periods, depending on your billing plan */
export type BuildRetentionPeriods =
  /** 30 days */
  | 'DAYS_30'
  /** 60 days */
  | 'DAYS_60'
  /** 90 days */
  | 'DAYS_90'
  /** 6 months */
  | 'MONTHS_6'
  /** 12 months */
  | 'MONTHS_12'
  /** 18 months */
  | 'MONTHS_18'
  /** 2 years */
  | 'YEARS_2';

export type BuildSource = {
  name: Scalars['String']['output'];
};

/** A build was triggered via an API */
export type BuildSourceApi = BuildSource & {
  name: Scalars['String']['output'];
};

/** A build was triggered manually via the frontend */
export type BuildSourceFrontend = BuildSource & {
  name: Scalars['String']['output'];
};

/** A build was triggered via a schedule */
export type BuildSourceSchedule = BuildSource & {
  name: Scalars['String']['output'];
  /** The associated schedule that created this build. Will be `null` if the associated schedule has been deleted. */
  pipelineSchedule: Maybe<PipelineSchedule>;
};

/** A build was triggered via a trigger job */
export type BuildSourceTriggerJob = BuildSource & {
  name: Scalars['String']['output'];
};

/** A build was triggered via a Webhook */
export type BuildSourceWebhook = BuildSource & {
  /** Provider specific headers sent along with the webhook. This will return null if the webhook has been purged by Buildkite. */
  headers: Maybe<Array<Scalars['String']['output']>>;
  name: Scalars['String']['output'];
  /**
   * The body of the webhook. Buildkite only stores webhook data for a short period
   * of time, so if this returns null - then the webhook data has been purged by Buildkite
   */
  payload: Maybe<Scalars['JSON']['output']>;
  /** The UUID for this webhook. This will return null if the webhook has been purged by Buildkite */
  uuid: Maybe<Scalars['String']['output']>;
};

/** All the possible states a build can be in */
export type BuildStates =
  /** The build is blocked */
  | 'BLOCKED'
  /** The build was canceled */
  | 'CANCELED'
  /** The build is currently being canceled */
  | 'CANCELING'
  /** The build is currently being created */
  | 'CREATING'
  /** The build failed */
  | 'FAILED'
  /** The build is failing */
  | 'FAILING'
  /** The build wasn't run */
  | 'NOT_RUN'
  /** The build passed */
  | 'PASSED'
  /** The build is currently running jobs */
  | 'RUNNING'
  /** The build has yet to start running jobs */
  | 'SCHEDULED'
  /** The build was skipped */
  | 'SKIPPED';

/** The results of a `buildkite-agent pipeline upload` */
export type BuildStepUpload = {
  /** The uploaded step definition */
  definition: BuildStepUploadDefinition;
  id: Scalars['ID']['output'];
  /** The UUID for this build step upload */
  uuid: Scalars['ID']['output'];
};

/** The pipeline definition for a step upload */
export type BuildStepUploadDefinition = {
  /** The uploaded step definition rendered as JSON */
  json: Scalars['String']['output'];
  /** The uploaded step definition rendered as YAML */
  yaml: Scalars['String']['output'];
};

/** A changelog */
export type Changelog = Node & {
  author: Maybe<ChangelogAuthor>;
  /** The body of this changelog */
  body: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The date and time this changelog was published */
  publishedAt: Maybe<Scalars['DateTime']['output']>;
  /** The tag for this changelog */
  tag: Scalars['String']['output'];
  /** The title for this changelog */
  title: Scalars['String']['output'];
  /** The public UUID for this changelog */
  uuid: Scalars['String']['output'];
};

/** The author of the changelog */
export type ChangelogAuthor = {
  avatar: Avatar;
  /** The name of the author */
  name: Scalars['String']['output'];
};

export type ChangelogConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<ChangelogEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type ChangelogEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Changelog>;
};

export type Cluster = Node & {
  /** Returns agent tokens for the Cluster */
  agentTokens: Maybe<ClusterAgentTokenConnection>;
  /** Color hex code for the cluster */
  color: Maybe<Scalars['String']['output']>;
  /** User who created the cluster */
  createdBy: Maybe<User>;
  /** The default queue that agents connecting to the cluster without specifying a queue will accept jobs from */
  defaultQueue: Maybe<ClusterQueue>;
  /** Description of the cluster */
  description: Maybe<Scalars['String']['output']>;
  /** Emoji for the cluster using Buildkite emoji syntax */
  emoji: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Name of the cluster */
  name: Scalars['String']['output'];
  organization: Maybe<Organization>;
  queues: Maybe<ClusterQueueConnection>;
  /** The public UUID for this cluster */
  uuid: Scalars['ID']['output'];
};


export type ClusterAgentTokensArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterQueuesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<ClusterQueueOrder>;
};

export type ClusterAgentTokenConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<ClusterAgentTokenEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreateInput = {
  /**
   * A list of CIDR-notation IPv4 addresses from which agents can use this token.
   * Please note that this feature is not yet available to all organizations
   */
  allowedIpAddresses: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  clusterId: Scalars['ID']['input'];
  description: Scalars['String']['input'];
  /**
   * Agents registered with this token will use a unique token for each job. Please
   * note that this feature is not yet available to all organizations
   */
  jobTokensEnabled: InputMaybe<Scalars['Boolean']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterAgentTokenCreate. */
export type ClusterAgentTokenCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  clusterAgentToken: ClusterToken;
  /**
   * The token value used to register a new agent to this tokens cluster. Please
   * ensure to securely copy this value immediately upon generation as it will not
   * be displayed again.
   */
  tokenValue: Scalars['String']['output'];
};

export type ClusterAgentTokenEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<ClusterToken>;
};

/** Autogenerated input type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterAgentTokenRevoke. */
export type ClusterAgentTokenRevokePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedClusterAgentTokenId: Scalars['ID']['output'];
};

/** Autogenerated input type of ClusterAgentTokenUpdate */
export type ClusterAgentTokenUpdateInput = {
  /**
   * A list of CIDR-notation IPv4 addresses from which agents can use this token.
   * Please note that this feature is not yet available to all organizations
   */
  allowedIpAddresses: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  /**
   * Agents registered with this token will use a unique token for each job. Please
   * note that this feature is not yet available to all organizations
   */
  jobTokensEnabled: InputMaybe<Scalars['Boolean']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterAgentTokenUpdate. */
export type ClusterAgentTokenUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  clusterAgentToken: ClusterToken;
};

export type ClusterConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<ClusterEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of ClusterCreate */
export type ClusterCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** Color hex code for the cluster */
  color: InputMaybe<Scalars['String']['input']>;
  /** Description for the cluster */
  description: InputMaybe<Scalars['String']['input']>;
  /** Emoji for the cluster using Buildkite emoji syntax */
  emoji: InputMaybe<Scalars['String']['input']>;
  /** Name for the cluster */
  name: Scalars['String']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterCreate. */
export type ClusterCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  cluster: Cluster;
};

/** Autogenerated input type of ClusterDelete */
export type ClusterDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterDelete. */
export type ClusterDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedClusterId: Scalars['ID']['output'];
};

export type ClusterEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Cluster>;
};

/** The different orders you can sort clusters by */
export type ClusterOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently created clusters first */
  | 'RECENTLY_CREATED';

export type ClusterPermission = {
  actor: Maybe<ClusterPermissionActor>;
  /** Whether the actor can add pipelines to this cluster */
  can_add_pipelines: Scalars['Boolean']['output'];
  /** Whether the actor can manage the associated cluster */
  can_manage: Scalars['Boolean']['output'];
  /** Whether the actor can see this cluster's tokens */
  can_see_tokens: Scalars['Boolean']['output'];
  cluster: Maybe<Cluster>;
  id: Scalars['ID']['output'];
  /** The public UUID for this cluster permission */
  uuid: Scalars['ID']['output'];
};

/** Actor to whom a cluster permission is applied */
export type ClusterPermissionActor = OrganizationMember | Team;

export type ClusterQueue = Node & {
  cluster: Maybe<Cluster>;
  createdBy: Maybe<User>;
  description: Maybe<Scalars['String']['output']>;
  /** States whether job dispatch is paused for this cluster queue */
  dispatchPaused: Scalars['Boolean']['output'];
  /** The time this queue was paused */
  dispatchPausedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user who paused this cluster queue */
  dispatchPausedBy: Maybe<User>;
  /** Note describing why job dispatch was paused for this cluster queue */
  dispatchPausedNote: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  /** The public UUID for this cluster queue */
  uuid: Scalars['ID']['output'];
};

export type ClusterQueueConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<ClusterQueueEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of ClusterQueueCreate */
export type ClusterQueueCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  clusterId: Scalars['ID']['input'];
  /** Description for the queue */
  description: InputMaybe<Scalars['String']['input']>;
  /** The queue tag used to connect an agent to the queue, this can't be updated later */
  key: Scalars['String']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterQueueCreate. */
export type ClusterQueueCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  clusterQueue: ClusterQueue;
};

/** Autogenerated input type of ClusterQueueDelete */
export type ClusterQueueDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterQueueDelete. */
export type ClusterQueueDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedClusterQueueId: Scalars['ID']['output'];
};

export type ClusterQueueEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<ClusterQueue>;
};

/** The different orders you can sort cluster queues by */
export type ClusterQueueOrder =
  /** Order by key alphabetically */
  | 'KEY'
  /** Order by the most recently created cluster queues first */
  | 'RECENTLY_CREATED';

/** Autogenerated input type of ClusterQueuePauseDispatch */
export type ClusterQueuePauseDispatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** An optional note describing the reason for pausing */
  note: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ClusterQueuePauseDispatch. */
export type ClusterQueuePauseDispatchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  queue: ClusterQueue;
};

/** Autogenerated input type of ClusterQueueResumeDispatch */
export type ClusterQueueResumeDispatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterQueueResumeDispatch. */
export type ClusterQueueResumeDispatchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  queue: ClusterQueue;
};

/** A token used to register an agent with a Buildkite cluster queue */
export type ClusterQueueToken = Node & {
  /**
   * A list of CIDR-notation IPv4 addresses from which agents can use this token.
   * Please note that this feature is not yet available to all organizations
   */
  allowedIpAddresses: Maybe<Scalars['String']['output']>;
  cluster: Maybe<Cluster>;
  clusterQueue: Maybe<ClusterQueue>;
  createdBy: Maybe<User>;
  /** A description for this cluster queue token */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /**
   * Agents registered with this token will use a unique token for each job. Please
   * note that this feature is not yet available to all organizations
   */
  jobTokensEnabled: Maybe<Scalars['Boolean']['output']>;
  /** The public UUID for this cluster queue token */
  uuid: Scalars['ID']['output'];
};

/** Autogenerated input type of ClusterQueueUpdate */
export type ClusterQueueUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** Description for the queue */
  description: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterQueueUpdate. */
export type ClusterQueueUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  clusterQueue: ClusterQueue;
};

/** A token used to connect an agent in cluster to Buildkite */
export type ClusterToken = Node & {
  /**
   * A list of CIDR-notation IPv4 addresses from which agents can use this token.
   * Please note that this feature is not yet available to all organizations
   */
  allowedIpAddresses: Maybe<Scalars['String']['output']>;
  cluster: Maybe<Cluster>;
  createdBy: Maybe<User>;
  /** A description about what this cluster agent token is used for */
  description: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /**
   * Agents registered with this token will use a unique token for each job. Please
   * note that this feature is not yet available to all organizations
   */
  jobTokensEnabled: Maybe<Scalars['Boolean']['output']>;
  /**
   * The token value used to register a new agent to this tokens cluster. This will
   * soon return an empty string before we finally remove this field.
   * @deprecated Hiding these after creation to improve security. Use the `token_value` field on ClusterAgentTokenCreate instead.
   */
  token: Scalars['String']['output'];
  /** The public UUID for this cluster token */
  uuid: Scalars['ID']['output'];
};

/** Autogenerated input type of ClusterUpdate */
export type ClusterUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** Color hex code for the cluster */
  color: InputMaybe<Scalars['String']['input']>;
  /** ID of the queue to set as the cluster's default queue */
  defaultQueueId: InputMaybe<Scalars['ID']['input']>;
  /** Description for the cluster */
  description: InputMaybe<Scalars['String']['input']>;
  /** Emoji for the cluster using Buildkite emoji syntax */
  emoji: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** Name for the cluster */
  name: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClusterUpdate. */
export type ClusterUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  cluster: Cluster;
};

export type Connection = {
  count: Scalars['Int']['output'];
  pageInfo: Maybe<PageInfo>;
};

export type Dependency = {
  /** Is this dependency allowed to fail */
  allowFailure: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The step key or step identifier that this step depends on */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this dependency */
  uuid: Scalars['ID']['output'];
};

export type DependencyConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<DependencyEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type DependencyEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Dependency>;
};

/** A job dispatch for a particular Organization */
export type Dispatch = {
  id: Scalars['ID']['output'];
  /** The public UUID for this organization dispatch */
  uuid: Scalars['String']['output'];
};

/** An email address */
export type Email = Node & {
  /** The email address */
  address: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Whether the email address is the user's primary address */
  primary: Scalars['Boolean']['output'];
  /** The public UUID for this email */
  uuid: Scalars['ID']['output'];
  /** Whether the email address has been verified by the user */
  verified: Scalars['Boolean']['output'];
};

/** The connection type for Email. */
export type EmailConnection = Connection & {
  count: Scalars['Int']['output'];
  /** A list of edges. */
  edges: Maybe<Array<Maybe<EmailEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<Email>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of EmailCreate */
export type EmailCreateInput = {
  address: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of EmailCreate. */
export type EmailCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  emailEdge: EmailEdge;
  viewer: Viewer;
};

/** An edge in a connection. */
export type EmailEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<Email>;
};

/** Autogenerated input type of EmailResendVerification */
export type EmailResendVerificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EmailResendVerification. */
export type EmailResendVerificationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  email: Email;
};

/** A shared GraphQL query */
export type GraphQlSnippet = {
  /** When this GraphQL snippet was created */
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** The default operation name for this snippet */
  operationName: Maybe<Scalars['String']['output']>;
  /** The query of this GraphQL snippet */
  query: Scalars['String']['output'];
  /** The URL for the GraphQL snippet */
  url: Scalars['String']['output'];
  /** The public UUID for this snippet */
  uuid: Scalars['ID']['output'];
};

/** Autogenerated input type of GraphQLSnippetCreate */
export type GraphQlSnippetCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  operationName: InputMaybe<Scalars['ID']['input']>;
  query: Scalars['String']['input'];
};

/** Autogenerated return type of GraphQLSnippetCreate. */
export type GraphQlSnippetCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  graphQLSnippet: GraphQlSnippet;
};

/** Kinds of jobs that can exist on a build */
export type Job = JobTypeBlock | JobTypeCommand | JobTypeTrigger | JobTypeWait;

/** Concurrency configuration for a job */
export type JobConcurrency = {
  /** The concurrency group */
  group: Scalars['String']['output'];
  /** The maximum amount of jobs in the concurrency that are allowed to run at any given time */
  limit: Scalars['Int']['output'];
};

/** Searching for concurrency groups on jobs */
export type JobConcurrencySearch = {
  /** The groups you want to search */
  group: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JobConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<JobEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type JobEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Job>;
};

export type JobEvent = {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** The actor who was responsible for the job event */
export type JobEventActor = {
  /** The node corresponding to this actor if available */
  node: Maybe<JobEventActorNodeUnion>;
  /** The type of this actor */
  type: JobEventActorType;
  /** The public UUID of this actor if available */
  uuid: Maybe<Scalars['ID']['output']>;
};

/** Actor types that can create events on a job */
export type JobEventActorNodeUnion = Agent | Dispatch | User;

/** All the actors that can have created a job event */
export type JobEventActorType =
  /** The actor was an agent */
  | 'AGENT'
  /** The actor was the dispatcher */
  | 'DISPATCH'
  /** The actor was the system */
  | 'SYSTEM'
  /** The actor was a user */
  | 'USER';

/** An event created when the dispatcher assigns the job to an agent */
export type JobEventAssigned = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  /** The agent the job was assigned to */
  assignedAgent: Maybe<Agent>;
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** An event created when the job creates new build steps via pipeline upload */
export type JobEventBuildStepUploadCreated = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  buildStepUpload: BuildStepUpload;
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** An event created when the job is canceled */
export type JobEventCanceled = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  exitStatus: Scalars['JSInt']['output'];
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The termination signal which killed the command, if the command was killed */
  signal: Maybe<Scalars['String']['output']>;
  /**
   * If the termination signal was sent by the agent, the reason the agent took
   * that action. If this field is null, and the `signal` field is not null, the
   * command was killed by another process or by the operating system.
   */
  signalReason: Maybe<JobEventSignalReason>;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

export type JobEventConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<JobEventEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type JobEventEdge = {
  cursor: Scalars['String']['output'];
  node: JobEvent;
};

/** An event created when the job is finished */
export type JobEventFinished = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  /**
   * The exit status returned by the command on the agent. A value of `-1`
   * indicates either that the agent was lost or the process was killed. If the
   * process was killed, the `signal` field will be non-null.
   */
  exitStatus: Scalars['JSInt']['output'];
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The termination signal which killed the command, if the command was killed */
  signal: Maybe<Scalars['String']['output']>;
  /**
   * If the termination signal was sent by the agent, the reason the agent took
   * that action. If this field is null, and the `signal` field is not null, the
   * command was killed by another process or by the operating system.
   */
  signalReason: Maybe<JobEventSignalReason>;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** A generic event type that doesn't have any additional meta-information associated with the event */
export type JobEventGeneric = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** An event created when the job is retried */
export type JobEventRetried = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  automaticRule: Maybe<JobRetryRuleAutomatic>;
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  retriedInJob: Maybe<JobTypeCommand>;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** The reason why a signal was sent to the job's process, or why the process did not start */
export type JobEventSignalReason =
  /** The agent refused the job. Note that in this case, no signal was sent to the process, the job was not run at all. */
  | 'AGENT_REFUSED'
  /** The agent sent the signal to the process because the agent was stopped */
  | 'AGENT_STOP'
  /** The agent sent the signal to the process because the job was canceled */
  | 'CANCEL'
  /**
   * The agent was unable to start the job process, often due to memory or resource
   * constraints. Note that in this case, no signal was sent to the process, it
   * simply never started.
   */
  | 'PROCESS_RUN_ERROR'
  /**
   * The agent refused the job because the signature could not be verified. Note
   * that in this case, no signal was sent to the process, the job was not run at all.
   */
  | 'SIGNATURE_REJECTED';

/** An event created when the job is timed out */
export type JobEventTimedOut = JobEvent & Node & {
  /** The actor that caused this event to occur */
  actor: JobEventActor;
  exitStatus: Scalars['JSInt']['output'];
  id: Scalars['ID']['output'];
  /** The job that this event belongs to */
  job: JobTypeCommand;
  /** The termination signal which killed the command, if the command was killed */
  signal: Maybe<Scalars['String']['output']>;
  /**
   * If the termination signal was sent by the agent, the reason the agent took
   * that action. If this field is null, and the `signal` field is not null, the
   * command was killed by another process or by the operating system.
   */
  signalReason: Maybe<JobEventSignalReason>;
  /** The time when the event occurred */
  timestamp: Scalars['DateTime']['output'];
  /** The type of event */
  type: JobEventType;
  /** The public UUID for this job event */
  uuid: Scalars['ID']['output'];
};

/** All the possible types of events that happen to a Job */
export type JobEventType =
  /** The Job was accepted by an agent */
  | 'ACCEPTED'
  /** The agent took too long to start the job */
  | 'ACCEPTED_EXPIRED'
  /** The agent disconnected while processing this job */
  | 'AGENT_DISCONNECTED'
  /** The agent was lost while processing this job */
  | 'AGENT_LOST'
  /** The agent was stopped while processing this job */
  | 'AGENT_STOPPED'
  /** The Job was assigned to an agent */
  | 'ASSIGNED'
  /** The agent took too long to accept the job */
  | 'ASSIGNED_EXPIRED'
  /** The Job uploaded steps to the current build */
  | 'BUILD_STEP_UPLOAD_CREATED'
  /** The Job was marked for cancelation by a user */
  | 'CANCELATION'
  /** The Job was canceled */
  | 'CANCELED'
  /** The Job was changed */
  | 'CHANGED'
  /** The Job expired before it was started on an agent */
  | 'EXPIRED'
  /** The Job was finished by an agent */
  | 'FINISHED'
  /** The Job is limited by a concurrency group */
  | 'LIMITED'
  /** The Job sent a notification */
  | 'NOTIFICATION'
  /** The Job was retried either automatically or by a user */
  | 'RETRIED'
  /** The Job was scheduled */
  | 'SCHEDULED'
  /** The Job was started by an agent */
  | 'STARTED'
  /** The Job was timed out */
  | 'TIMED_OUT'
  /** The Job was unblocked by a user */
  | 'UNBLOCKED';

export type JobInterface = {
  /** If this job has been retried */
  retried: Scalars['Boolean']['output'];
  /** The user that retried this job */
  retriedBy: Maybe<User>;
  /** The number of times the job has been retried */
  retriesCount: Maybe<Scalars['Int']['output']>;
  /** The job that was retried to create this job */
  retrySource: Maybe<Job>;
  /** The type of retry that was performed on this job */
  retryType: Maybe<JobRetryTypes>;
  /** The UUID for this job */
  uuid: Scalars['String']['output'];
};

/** A record of job minutes usage, aggregated by day and pipeline. */
export type JobMinutesUsage = ResourceUsageInterface & {
  aggregatedOn: Scalars['ISO8601Date']['output'];
  pipeline: Maybe<Pipeline>;
  pipelineId: Scalars['ID']['output'];
  /**
   * The recorded usage in seconds. For billing purposes, seconds are summed for a
   * billing period and rounded down to the nearest minute.
   */
  seconds: Scalars['Int']['output'];
};

/** The different orders you can sort jobs by */
export type JobOrder =
  /** Order by the most recently assigned jobs first */
  | 'RECENTLY_ASSIGNED'
  /** Order by the most recently created jobs first */
  | 'RECENTLY_CREATED';

/** The priority with which a job will run */
export type JobPriority = {
  number: Maybe<Scalars['Int']['output']>;
};

/** Search jobs by priority */
export type JobPrioritySearch = {
  /** The priority number to search */
  number: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Automatic retry rule configuration */
export type JobRetryRuleAutomatic = {
  exitStatus: Maybe<Scalars['String']['output']>;
  limit: Maybe<Scalars['String']['output']>;
  signal: Maybe<Scalars['String']['output']>;
  signalReason: Maybe<Scalars['String']['output']>;
};

/** Retry Rules for a job */
export type JobRetryRules = {
  automatic: Maybe<Array<Maybe<JobRetryRuleAutomatic>>>;
  manual: Maybe<Scalars['Boolean']['output']>;
};

/** The retry types that can be made on a Job */
export type JobRetryTypes =
  | 'AUTOMATIC'
  | 'MANUAL';

/** All the possible states a job can be in */
export type JobStates =
  /** The job was accepted by the agent, and now it's waiting to start running */
  | 'ACCEPTED'
  /** The job has been assigned to an agent, and it's waiting for it to accept */
  | 'ASSIGNED'
  /** The job is waiting on a `block` step to finish */
  | 'BLOCKED'
  /** The job was in a `BLOCKED` state when the build failed */
  | 'BLOCKED_FAILED'
  /** The jobs configuration means that it can't be run */
  | 'BROKEN'
  /** The job was canceled */
  | 'CANCELED'
  /** The job is currently canceling */
  | 'CANCELING'
  /** The job expired before it was started on an agent */
  | 'EXPIRED'
  /** The job has finished */
  | 'FINISHED'
  /** The job is waiting for jobs with the same concurrency group to finish */
  | 'LIMITED'
  /** The job is waiting on a concurrency group check before becoming either `LIMITED` or `SCHEDULED` */
  | 'LIMITING'
  /** The job has just been created and doesn't have a state yet */
  | 'PENDING'
  /** The job is running */
  | 'RUNNING'
  /** The job is scheduled and waiting for an agent */
  | 'SCHEDULED'
  /** The job was skipped */
  | 'SKIPPED'
  /** The job timed out */
  | 'TIMED_OUT'
  /** The job is timing out for taking too long */
  | 'TIMING_OUT'
  /** This `block` job has been manually unblocked */
  | 'UNBLOCKED'
  /** This `block` job was in an `UNBLOCKED` state when the build failed */
  | 'UNBLOCKED_FAILED'
  /** The job is waiting on a `wait` step to finish */
  | 'WAITING'
  /** The job was in a `WAITING` state when the build failed */
  | 'WAITING_FAILED';

/** Searching for jobs based on step information */
export type JobStepSearch = {
  /** The key assigned to the step */
  key: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A type of job that requires a user to unblock it before proceeding in a build pipeline */
export type JobTypeBlock = JobInterface & Node & {
  /** The build that this job is a part of */
  build: Maybe<Build>;
  id: Scalars['ID']['output'];
  /** Whether or not this job can be unblocked yet (may be waiting on another job to finish) */
  isUnblockable: Maybe<Scalars['Boolean']['output']>;
  /** The label of this block step */
  label: Maybe<Scalars['String']['output']>;
  /** If this job has been retried */
  retried: Scalars['Boolean']['output'];
  /** The user that retried this job */
  retriedBy: Maybe<User>;
  /** The number of times the job has been retried */
  retriesCount: Maybe<Scalars['Int']['output']>;
  /** The job that was retried to create this job */
  retrySource: Maybe<Job>;
  /** The type of retry that was performed on this job */
  retryType: Maybe<JobRetryTypes>;
  /** The state of the job */
  state: JobStates;
  /** The step that defined this job. Some older jobs in the system may not have an associated step */
  step: Maybe<StepInput>;
  /** The time when the job was created */
  unblockedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that unblocked this job */
  unblockedBy: Maybe<User>;
  /** The UUID for this job */
  uuid: Scalars['String']['output'];
};

/** Autogenerated input type of JobTypeBlockUnblock */
export type JobTypeBlockUnblockInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** Hash of values for the block step's fields. */
  fields: InputMaybe<Scalars['JSON']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of JobTypeBlockUnblock. */
export type JobTypeBlockUnblockPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  jobTypeBlock: JobTypeBlock;
};

/** A type of job that runs a command on an agent */
export type JobTypeCommand = JobInterface & Node & {
  /** The agent that is running the job */
  agent: Maybe<Agent>;
  /** The ruleset used to find an agent to run this job */
  agentQueryRules: Maybe<Array<Scalars['String']['output']>>;
  /** Artifacts uploaded to this job */
  artifacts: Maybe<ArtifactConnection>;
  /** A glob of files to automatically upload after the job finishes */
  automaticArtifactUploadPaths: Maybe<Scalars['String']['output']>;
  /** The build that this job is a part of */
  build: Maybe<Build>;
  /** The time when the job was cancelled */
  canceledAt: Maybe<Scalars['DateTime']['output']>;
  /** The cluster of this job */
  cluster: Maybe<Cluster>;
  /** The cluster queue of this job */
  clusterQueue: Maybe<ClusterQueue>;
  /** The command the job will run */
  command: Maybe<Scalars['String']['output']>;
  /** Concurrency information related to a job */
  concurrency: Maybe<JobConcurrency>;
  /** The time when the job was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** Environment variables for this job */
  env: Maybe<Array<Scalars['String']['output']>>;
  /** Job events */
  events: JobEventConnection;
  /** The exit status returned by the command on the agent */
  exitStatus: Maybe<Scalars['String']['output']>;
  /** The time when the job was expired */
  expiredAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when the job finished */
  finishedAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The label of the job */
  label: Maybe<Scalars['String']['output']>;
  /** The matrix configuration values for this particular job */
  matrix: Maybe<Scalars['JSON']['output']>;
  /** The index of this job within the parallel job group it is a part of. Null if this job is not part of a parallel job group. */
  parallelGroupIndex: Maybe<Scalars['Int']['output']>;
  /**
   * The total number of jobs in the parallel job group this job is a part of. Null
   * if this job is not part of a parallel job group.
   */
  parallelGroupTotal: Maybe<Scalars['Int']['output']>;
  /** If the job has finished and passed */
  passed: Scalars['Boolean']['output'];
  /** The pipeline that this job is a part of */
  pipeline: Maybe<Pipeline>;
  /** The priority of this job */
  priority: JobPriority;
  /** If this job has been retried */
  retried: Scalars['Boolean']['output'];
  /** The user that retried this job */
  retriedBy: Maybe<User>;
  /** The number of times the job has been retried */
  retriesCount: Maybe<Scalars['Int']['output']>;
  /** Job retry rules */
  retryRules: Maybe<JobRetryRules>;
  /** The job that was retried to create this job */
  retrySource: Maybe<Job>;
  /** The type of retry that was performed on this job */
  retryType: Maybe<JobRetryTypes>;
  /** The time when the job became available to be run by an agent */
  runnableAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when the job became scheduled for running */
  scheduledAt: Maybe<Scalars['DateTime']['output']>;
  /** The termination signal which killed the command, if the command was killed */
  signal: Maybe<Scalars['String']['output']>;
  /**
   * If the termination signal was sent by the agent, the reason the agent took
   * that action. If this field is null, and the `signal` field is not null, the
   * command was killed by another process or by the operating system.
   */
  signalReason: Maybe<JobEventSignalReason>;
  /** If the job soft failed */
  softFailed: Scalars['Boolean']['output'];
  /** The time when the job started running */
  startedAt: Maybe<Scalars['DateTime']['output']>;
  /** The state of the job */
  state: JobStates;
  /** The step that defined this job. Some older jobs in the system may not have an associated step */
  step: Maybe<StepCommand>;
  /** The URL for the job */
  url: Scalars['String']['output'];
  /** The UUID for this job */
  uuid: Scalars['String']['output'];
};


/** A type of job that runs a command on an agent */
export type JobTypeCommandArtifactsArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** A type of job that runs a command on an agent */
export type JobTypeCommandEventsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of JobTypeCommandCancel */
export type JobTypeCommandCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of JobTypeCommandCancel. */
export type JobTypeCommandCancelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  jobTypeCommand: JobTypeCommand;
};

/** Autogenerated input type of JobTypeCommandRetry */
export type JobTypeCommandRetryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of JobTypeCommandRetry. */
export type JobTypeCommandRetryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  jobTypeCommand: JobTypeCommand;
  retriedInJobTypeCommand: JobTypeCommand;
};

/** A type of job that triggers another build on a pipeline */
export type JobTypeTrigger = JobInterface & Node & {
  /** The build that this job is a part of */
  build: Maybe<Build>;
  id: Scalars['ID']['output'];
  /** The label of this trigger step */
  label: Maybe<Scalars['String']['output']>;
  /** If this job has been retried */
  retried: Scalars['Boolean']['output'];
  /** The user that retried this job */
  retriedBy: Maybe<User>;
  /** The number of times the job has been retried */
  retriesCount: Maybe<Scalars['Int']['output']>;
  /** The job that was retried to create this job */
  retrySource: Maybe<Job>;
  /** The type of retry that was performed on this job */
  retryType: Maybe<JobRetryTypes>;
  /** The state of the job */
  state: JobStates;
  /** The step that defined this job. Some older jobs in the system may not have an associated step */
  step: Maybe<StepTrigger>;
  /** The build that this job triggered */
  triggered: Maybe<Build>;
  /** The UUID for this job */
  uuid: Scalars['String']['output'];
};

/** A type of job that waits for all previous jobs to pass before proceeding the build pipeline */
export type JobTypeWait = JobInterface & Node & {
  /** The build that this job is a part of */
  build: Maybe<Build>;
  id: Scalars['ID']['output'];
  /** The label of this wait step */
  label: Maybe<Scalars['String']['output']>;
  /** If this job has been retried */
  retried: Scalars['Boolean']['output'];
  /** The user that retried this job */
  retriedBy: Maybe<User>;
  /** The number of times the job has been retried */
  retriesCount: Maybe<Scalars['Int']['output']>;
  /** The job that was retried to create this job */
  retrySource: Maybe<Job>;
  /** The type of retry that was performed on this job */
  retryType: Maybe<JobRetryTypes>;
  /** The state of the job */
  state: JobStates;
  /** The step that defined this job. Some older jobs in the system may not have an associated step */
  step: Maybe<StepWait>;
  /** The UUID for this job */
  uuid: Scalars['String']['output'];
};

/** All the possible types of jobs that can exist */
export type JobTypes =
  /** A job that blocks a pipeline from progressing until it's manually unblocked */
  | 'BLOCK'
  /** A job that runs a command on an agent */
  | 'COMMAND'
  /** A job that triggers another build on a pipeline */
  | 'TRIGGER'
  /** A job that waits for all previous jobs to finish */
  | 'WAIT';

/** The root for mutations in this schema */
export type Mutation = {
  /** Instruct an agent to stop accepting new build jobs and shut itself down. */
  agentStop: Maybe<AgentStopPayload>;
  /** Create a new agent registration token. */
  agentTokenCreate: Maybe<AgentTokenCreatePayload>;
  /** Revoke an agent registration token. */
  agentTokenRevoke: Maybe<AgentTokenRevokePayload>;
  /**
   * Authorize an API Access Token Code generated by an API Application. Please
   * note this mutation is private and cannot be executed externally.
   */
  apiAccessTokenCodeAuthorize: Maybe<ApiAccessTokenCodeAuthorizeMutationPayload>;
  /** Annotate a build with information to appear on the build page. */
  buildAnnotate: Maybe<BuildAnnotatePayload>;
  /** Cancel a build. */
  buildCancel: Maybe<BuildCancelPayload>;
  /** Create a build. */
  buildCreate: Maybe<BuildCreatePayload>;
  /** Rebuild a build. */
  buildRebuild: Maybe<BuildRebuildPayload>;
  /** Create a new cluster agent token */
  clusterAgentTokenCreate: Maybe<ClusterAgentTokenCreatePayload>;
  /** Revokes a cluster agent token */
  clusterAgentTokenRevoke: Maybe<ClusterAgentTokenRevokePayload>;
  /** Updates a cluster agent token */
  clusterAgentTokenUpdate: Maybe<ClusterAgentTokenUpdatePayload>;
  /** Create a cluster. */
  clusterCreate: Maybe<ClusterCreatePayload>;
  /** Delete a cluster. */
  clusterDelete: Maybe<ClusterDeletePayload>;
  /** Create a cluster queue. */
  clusterQueueCreate: Maybe<ClusterQueueCreatePayload>;
  /** Delete a cluster queue. */
  clusterQueueDelete: Maybe<ClusterQueueDeletePayload>;
  /**
   * This will prevent dispatch of jobs to agents on this queue. You can add an
   * optional note describing the reason for pausing.
   */
  clusterQueuePauseDispatch: Maybe<ClusterQueuePauseDispatchPayload>;
  /** This will resume dispatch of jobs on this queue. */
  clusterQueueResumeDispatch: Maybe<ClusterQueueResumeDispatchPayload>;
  /** Updates a cluster queue. */
  clusterQueueUpdate: Maybe<ClusterQueueUpdatePayload>;
  /** Updates a cluster. */
  clusterUpdate: Maybe<ClusterUpdatePayload>;
  /** Add a new email address for the current user */
  emailCreate: Maybe<EmailCreatePayload>;
  /** Resend a verification email. */
  emailResendVerification: Maybe<EmailResendVerificationPayload>;
  /** Create a GraphQL snippet. */
  graphQLSnippetCreate: Maybe<GraphQlSnippetCreatePayload>;
  /** Unblocks a build's "Block pipeline" job. */
  jobTypeBlockUnblock: Maybe<JobTypeBlockUnblockPayload>;
  /** Cancel a job. */
  jobTypeCommandCancel: Maybe<JobTypeCommandCancelPayload>;
  /** Retry a job. */
  jobTypeCommandRetry: Maybe<JobTypeCommandRetryPayload>;
  /**
   * Dismisses a notice from the Buildkite UI. This mutation is idempotent so if
   * you dismiss the same notice multiple times, it will return the original
   * `dismissedAt` time
   */
  noticeDismiss: Maybe<NoticeDismissPayload>;
  /**
   * Revokes access to an organization for a user's API access token. The
   * organization can not be re-added to the same token, however the user can
   * create a new token and add the organization to that token.
   */
  organizationApiAccessTokenRevoke: Maybe<OrganizationApiAccessTokenRevokeMutationPayload>;
  /**
   * Sets an allowlist of IP addresses for API access to an organization. Please
   * note that this is a beta feature and is not yet available to all
   * organizations.
   */
  organizationApiIpAllowlistUpdate: Maybe<OrganizationApiipAllowlistUpdateMutationPayload>;
  /** Delete the system banner */
  organizationBannerDelete: Maybe<OrganizationBannerDeletePayload>;
  /**
   * Retrieves the active system banner for provided organization, then updates it
   * with input data. If active banner is not found, a new banner is created with
   * the provided input.
   */
  organizationBannerUpsert: Maybe<OrganizationBannerUpsertPayload>;
  /** Sets whether the organization requires two-factor authentication for all members. */
  organizationEnforceTwoFactorAuthenticationForMembersUpdate: Maybe<OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutationPayload>;
  /** Send email invitations to this organization. */
  organizationInvitationCreate: Maybe<OrganizationInvitationCreatePayload>;
  /** Resend an organization invitation email. */
  organizationInvitationResend: Maybe<OrganizationInvitationResendPayload>;
  /** Revoke an invitation to an organization so that it can no longer be accepted. */
  organizationInvitationRevoke: Maybe<OrganizationInvitationRevokePayload>;
  /** Remove a user from an organization. */
  organizationMemberDelete: Maybe<OrganizationMemberDeletePayload>;
  /** Change a user's role within an organization. */
  organizationMemberUpdate: Maybe<OrganizationMemberUpdatePayload>;
  /** Specify the maximum timeframe to revoke organization access from inactive API tokens. */
  organizationRevokeInactiveTokensAfterUpdate: Maybe<OrganizationRevokeInactiveTokensAfterUpdateMutationPayload>;
  /** Archive a pipeline. */
  pipelineArchive: Maybe<PipelineArchivePayload>;
  /** Create a pipeline. */
  pipelineCreate: Maybe<PipelineCreatePayload>;
  /** Create SCM webhooks for a pipeline. */
  pipelineCreateWebhook: Maybe<PipelineCreateWebhookPayload>;
  /** Delete a pipeline. */
  pipelineDelete: Maybe<PipelineDeletePayload>;
  /** Favorite a pipeline. */
  pipelineFavorite: Maybe<PipelineFavoritePayload>;
  /**
   * Rotate a pipeline's webhook URL.
   *
   * Note that the old webhook URL will stop working immediately and so must be updated quickly to avoid interruption.
   */
  pipelineRotateWebhookURL: Maybe<PipelineRotateWebhookUrlPayload>;
  /** Create a scheduled build on pipeline. */
  pipelineScheduleCreate: Maybe<PipelineScheduleCreatePayload>;
  /** Delete a scheduled build on pipeline. */
  pipelineScheduleDelete: Maybe<PipelineScheduleDeletePayload>;
  /** Update a scheduled build on pipeline. */
  pipelineScheduleUpdate: Maybe<PipelineScheduleUpdatePayload>;
  /** Create a pipeline template. */
  pipelineTemplateCreate: Maybe<PipelineTemplateCreatePayload>;
  /** Delete a pipeline template. */
  pipelineTemplateDelete: Maybe<PipelineTemplateDeletePayload>;
  /** Update a pipeline template. */
  pipelineTemplateUpdate: Maybe<PipelineTemplateUpdatePayload>;
  /** Unarchive a pipeline. */
  pipelineUnarchive: Maybe<PipelineUnarchivePayload>;
  /** Change the settings for a pipeline. */
  pipelineUpdate: Maybe<PipelineUpdatePayload>;
  /** Create a SSO provider. */
  ssoProviderCreate: Maybe<SsoProviderCreatePayload>;
  /** Delete a SSO provider. */
  ssoProviderDelete: Maybe<SsoProviderDeletePayload>;
  /** Disable a SSO provider. */
  ssoProviderDisable: Maybe<SsoProviderDisablePayload>;
  /** Enable a SSO provider. */
  ssoProviderEnable: Maybe<SsoProviderEnablePayload>;
  /** Change the settings for a SSO provider. */
  ssoProviderUpdate: Maybe<SsoProviderUpdatePayload>;
  /** Create a team. */
  teamCreate: Maybe<TeamCreatePayload>;
  /** Delete a team. */
  teamDelete: Maybe<TeamDeletePayload>;
  /** Add a user to a team. */
  teamMemberCreate: Maybe<TeamMemberCreatePayload>;
  /** Remove a user from a team. */
  teamMemberDelete: Maybe<TeamMemberDeletePayload>;
  /** Update a user's role in a team. */
  teamMemberUpdate: Maybe<TeamMemberUpdatePayload>;
  /** Add a pipeline to a team. */
  teamPipelineCreate: Maybe<TeamPipelineCreatePayload>;
  /** Remove a pipeline from a team. */
  teamPipelineDelete: Maybe<TeamPipelineDeletePayload>;
  /** Update a pipeline's access level within a team. */
  teamPipelineUpdate: Maybe<TeamPipelineUpdatePayload>;
  /** Add a suite to a team. */
  teamSuiteCreate: Maybe<TeamSuiteCreatePayload>;
  /** Remove a suite from a team. */
  teamSuiteDelete: Maybe<TeamSuiteDeletePayload>;
  /** Update a suite's access level within a team. */
  teamSuiteUpdate: Maybe<TeamSuiteUpdatePayload>;
  /** Change the settings for a team. */
  teamUpdate: Maybe<TeamUpdatePayload>;
  /**
   * Activate a previously-generated TOTP configuration, and its Recovery Codes.
   *
   * Once activated, both this TOTP configuration, and the associated Recovery Codes will become active for the user.
   * Any previous TOTP configuration or Recovery Codes will no longer be usable.
   *
   * This mutation is private, requires an escalated session, and cannot be accessed via the public GraphQL API.
   */
  totpActivate: Maybe<TotpActivatePayload>;
  /**
   * Create a new TOTP configuration for the current user.
   *
   * This will produce a TOTP configuration with an associated set of Recovery
   * Codes. The Recovery Codes must be presented to the user prior to the TOTP's
   * activation with `totpActivate`.
   * Neither TOTP configuration nor Recovery Codes will be usable until they have been activated.
   *
   * This mutation is private, requires an escalated session, and cannot be accessed via the public GraphQL API.
   */
  totpCreate: Maybe<TotpCreatePayload>;
  /**
   * Delete a TOTP configuration.
   *
   * If a TOTP configuration was active, it will no longer be used for logging on to the user's account.
   * Any Recovery Codes associated with the TOTP configuration will also no longer be usable.
   *
   * This mutation is private, requires an escalated session, and cannot be accessed via the public GraphQL API.
   */
  totpDelete: Maybe<TotpDeletePayload>;
  /**
   * Generate a new set of Recovery Codes for a given TOTP.
   *
   * The new Recovery Codes will immediately replace any existing recovery codes.
   *
   * This mutation is private, requires an escalated session, and cannot be accessed via the public GraphQL API.
   */
  totpRecoveryCodesRegenerate: Maybe<TotpRecoveryCodesRegeneratePayload>;
};


/** The root for mutations in this schema */
export type MutationAgentStopArgs = {
  input: AgentStopInput;
};


/** The root for mutations in this schema */
export type MutationAgentTokenCreateArgs = {
  input: AgentTokenCreateInput;
};


/** The root for mutations in this schema */
export type MutationAgentTokenRevokeArgs = {
  input: AgentTokenRevokeInput;
};


/** The root for mutations in this schema */
export type MutationApiAccessTokenCodeAuthorizeArgs = {
  input: ApiAccessTokenCodeAuthorizeMutationInput;
};


/** The root for mutations in this schema */
export type MutationBuildAnnotateArgs = {
  input: BuildAnnotateInput;
};


/** The root for mutations in this schema */
export type MutationBuildCancelArgs = {
  input: BuildCancelInput;
};


/** The root for mutations in this schema */
export type MutationBuildCreateArgs = {
  input: BuildCreateInput;
};


/** The root for mutations in this schema */
export type MutationBuildRebuildArgs = {
  input: BuildRebuildInput;
};


/** The root for mutations in this schema */
export type MutationClusterAgentTokenCreateArgs = {
  input: ClusterAgentTokenCreateInput;
};


/** The root for mutations in this schema */
export type MutationClusterAgentTokenRevokeArgs = {
  input: ClusterAgentTokenRevokeInput;
};


/** The root for mutations in this schema */
export type MutationClusterAgentTokenUpdateArgs = {
  input: ClusterAgentTokenUpdateInput;
};


/** The root for mutations in this schema */
export type MutationClusterCreateArgs = {
  input: ClusterCreateInput;
};


/** The root for mutations in this schema */
export type MutationClusterDeleteArgs = {
  input: ClusterDeleteInput;
};


/** The root for mutations in this schema */
export type MutationClusterQueueCreateArgs = {
  input: ClusterQueueCreateInput;
};


/** The root for mutations in this schema */
export type MutationClusterQueueDeleteArgs = {
  input: ClusterQueueDeleteInput;
};


/** The root for mutations in this schema */
export type MutationClusterQueuePauseDispatchArgs = {
  input: ClusterQueuePauseDispatchInput;
};


/** The root for mutations in this schema */
export type MutationClusterQueueResumeDispatchArgs = {
  input: ClusterQueueResumeDispatchInput;
};


/** The root for mutations in this schema */
export type MutationClusterQueueUpdateArgs = {
  input: ClusterQueueUpdateInput;
};


/** The root for mutations in this schema */
export type MutationClusterUpdateArgs = {
  input: ClusterUpdateInput;
};


/** The root for mutations in this schema */
export type MutationEmailCreateArgs = {
  input: EmailCreateInput;
};


/** The root for mutations in this schema */
export type MutationEmailResendVerificationArgs = {
  input: EmailResendVerificationInput;
};


/** The root for mutations in this schema */
export type MutationGraphQlSnippetCreateArgs = {
  input: GraphQlSnippetCreateInput;
};


/** The root for mutations in this schema */
export type MutationJobTypeBlockUnblockArgs = {
  input: JobTypeBlockUnblockInput;
};


/** The root for mutations in this schema */
export type MutationJobTypeCommandCancelArgs = {
  input: JobTypeCommandCancelInput;
};


/** The root for mutations in this schema */
export type MutationJobTypeCommandRetryArgs = {
  input: JobTypeCommandRetryInput;
};


/** The root for mutations in this schema */
export type MutationNoticeDismissArgs = {
  input: NoticeDismissInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationApiAccessTokenRevokeArgs = {
  input: OrganizationApiAccessTokenRevokeMutationInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationApiIpAllowlistUpdateArgs = {
  input: OrganizationApiipAllowlistUpdateMutationInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationBannerDeleteArgs = {
  input: OrganizationBannerDeleteInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationBannerUpsertArgs = {
  input: OrganizationBannerUpsertInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationEnforceTwoFactorAuthenticationForMembersUpdateArgs = {
  input: OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutationInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationInvitationCreateArgs = {
  input: OrganizationInvitationCreateInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationInvitationResendArgs = {
  input: OrganizationInvitationResendInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationInvitationRevokeArgs = {
  input: OrganizationInvitationRevokeInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationMemberDeleteArgs = {
  input: OrganizationMemberDeleteInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationMemberUpdateArgs = {
  input: OrganizationMemberUpdateInput;
};


/** The root for mutations in this schema */
export type MutationOrganizationRevokeInactiveTokensAfterUpdateArgs = {
  input: OrganizationRevokeInactiveTokensAfterUpdateMutationInput;
};


/** The root for mutations in this schema */
export type MutationPipelineArchiveArgs = {
  input: PipelineArchiveInput;
};


/** The root for mutations in this schema */
export type MutationPipelineCreateArgs = {
  input: PipelineCreateInput;
};


/** The root for mutations in this schema */
export type MutationPipelineCreateWebhookArgs = {
  input: PipelineCreateWebhookInput;
};


/** The root for mutations in this schema */
export type MutationPipelineDeleteArgs = {
  input: PipelineDeleteInput;
};


/** The root for mutations in this schema */
export type MutationPipelineFavoriteArgs = {
  input: PipelineFavoriteInput;
};


/** The root for mutations in this schema */
export type MutationPipelineRotateWebhookUrlArgs = {
  input: PipelineRotateWebhookUrlInput;
};


/** The root for mutations in this schema */
export type MutationPipelineScheduleCreateArgs = {
  input: PipelineScheduleCreateInput;
};


/** The root for mutations in this schema */
export type MutationPipelineScheduleDeleteArgs = {
  input: PipelineScheduleDeleteInput;
};


/** The root for mutations in this schema */
export type MutationPipelineScheduleUpdateArgs = {
  input: PipelineScheduleUpdateInput;
};


/** The root for mutations in this schema */
export type MutationPipelineTemplateCreateArgs = {
  input: PipelineTemplateCreateInput;
};


/** The root for mutations in this schema */
export type MutationPipelineTemplateDeleteArgs = {
  input: PipelineTemplateDeleteInput;
};


/** The root for mutations in this schema */
export type MutationPipelineTemplateUpdateArgs = {
  input: PipelineTemplateUpdateInput;
};


/** The root for mutations in this schema */
export type MutationPipelineUnarchiveArgs = {
  input: PipelineUnarchiveInput;
};


/** The root for mutations in this schema */
export type MutationPipelineUpdateArgs = {
  input: PipelineUpdateInput;
};


/** The root for mutations in this schema */
export type MutationSsoProviderCreateArgs = {
  input: SsoProviderCreateInput;
};


/** The root for mutations in this schema */
export type MutationSsoProviderDeleteArgs = {
  input: SsoProviderDeleteInput;
};


/** The root for mutations in this schema */
export type MutationSsoProviderDisableArgs = {
  input: SsoProviderDisableInput;
};


/** The root for mutations in this schema */
export type MutationSsoProviderEnableArgs = {
  input: SsoProviderEnableInput;
};


/** The root for mutations in this schema */
export type MutationSsoProviderUpdateArgs = {
  input: SsoProviderUpdateInput;
};


/** The root for mutations in this schema */
export type MutationTeamCreateArgs = {
  input: TeamCreateInput;
};


/** The root for mutations in this schema */
export type MutationTeamDeleteArgs = {
  input: TeamDeleteInput;
};


/** The root for mutations in this schema */
export type MutationTeamMemberCreateArgs = {
  input: TeamMemberCreateInput;
};


/** The root for mutations in this schema */
export type MutationTeamMemberDeleteArgs = {
  input: TeamMemberDeleteInput;
};


/** The root for mutations in this schema */
export type MutationTeamMemberUpdateArgs = {
  input: TeamMemberUpdateInput;
};


/** The root for mutations in this schema */
export type MutationTeamPipelineCreateArgs = {
  input: TeamPipelineCreateInput;
};


/** The root for mutations in this schema */
export type MutationTeamPipelineDeleteArgs = {
  input: TeamPipelineDeleteInput;
};


/** The root for mutations in this schema */
export type MutationTeamPipelineUpdateArgs = {
  input: TeamPipelineUpdateInput;
};


/** The root for mutations in this schema */
export type MutationTeamSuiteCreateArgs = {
  input: TeamSuiteCreateInput;
};


/** The root for mutations in this schema */
export type MutationTeamSuiteDeleteArgs = {
  input: TeamSuiteDeleteInput;
};


/** The root for mutations in this schema */
export type MutationTeamSuiteUpdateArgs = {
  input: TeamSuiteUpdateInput;
};


/** The root for mutations in this schema */
export type MutationTeamUpdateArgs = {
  input: TeamUpdateInput;
};


/** The root for mutations in this schema */
export type MutationTotpActivateArgs = {
  input: TotpActivateInput;
};


/** The root for mutations in this schema */
export type MutationTotpCreateArgs = {
  input: TotpCreateInput;
};


/** The root for mutations in this schema */
export type MutationTotpDeleteArgs = {
  input: TotpDeleteInput;
};


/** The root for mutations in this schema */
export type MutationTotpRecoveryCodesRegenerateArgs = {
  input: TotpRecoveryCodesRegenerateInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** A notice or notice that a user sees in the Buildkite UI */
export type Notice = {
  /** The time when this notice was dismissed from the UI */
  dismissedAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** The namespace of this notice */
  namespace: NoticeNamespaces;
  /** The scope within the namespace */
  scope: Scalars['String']['output'];
};

/** Autogenerated input type of NoticeDismiss */
export type NoticeDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of NoticeDismiss. */
export type NoticeDismissPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  notice: Maybe<Notice>;
};

/** All the possible namespaces for a notice */
export type NoticeNamespaces =
  /** A change to an existing feature */
  | 'CHANGE'
  /** The user has had an email suggested to them */
  | 'EMAIL_SUGGESTION'
  /** An event announcement */
  | 'EVENT'
  /** A new feature was added */
  | 'FEATURE';

export type NotificationService = {
  /** The description of this service */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The name of the service provider */
  name: Scalars['String']['output'];
};

/** Deliver notifications to Slack */
export type NotificationServiceSlack = Node & NotificationService & {
  /** The description of this service */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The name of the service provider */
  name: Scalars['String']['output'];
};

/** Deliver notifications to a custom URL */
export type NotificationServiceWebhook = NotificationService & {
  /** The description of this service */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The name of the service provider */
  name: Scalars['String']['output'];
};

/** A operating system that an agent can run on */
export type OperatingSystem = {
  /** The name of the operating system */
  name: Scalars['String']['output'];
};

/** An organization */
export type Organization = Node & {
  /** Returns agent access tokens for an Organization. By default returns all tokens, whether revoked or non-revoked. */
  agentTokens: Maybe<AgentTokenConnection>;
  agents: Maybe<AgentConnection>;
  /** A space-separated allowlist of IP addresses that can access the organization via the GraphQL or REST API */
  allowedApiIpAddresses: Maybe<Scalars['String']['output']>;
  /** Returns user API access tokens that can access this organization */
  apiAccessTokens: OrganizationApiAccessTokenConnection;
  auditEvents: Maybe<OrganizationAuditEventConnection>;
  /** Returns active banners for this organization. */
  banners: OrganizationBannerConnection;
  /** Return cluster in the Organization by UUID */
  cluster: Maybe<Cluster>;
  /** Returns clusters for an Organization */
  clusters: Maybe<ClusterConnection>;
  /** The URL to an icon representing this organization */
  iconUrl: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invitations: Maybe<OrganizationInvitationConnection>;
  /** Whether teams is enabled for this organization */
  isTeamsEnabled: Scalars['Boolean']['output'];
  jobs: Maybe<JobConnection>;
  /** Returns users within the organization */
  members: Maybe<OrganizationMemberConnection>;
  /**
   * Whether this organization requires 2FA to access (Please note that this is a
   * beta feature and is not yet available to all organizations.)
   */
  membersRequireTwoFactorAuthentication: Scalars['Boolean']['output'];
  /** The name of the organization */
  name: Scalars['String']['output'];
  permissions: OrganizationPermissions;
  /** Return all the pipeline templates the current user has access to for this organization */
  pipelineTemplates: Maybe<PipelineTemplateConnection>;
  /** Return all the pipelines the current user has access to for this organization */
  pipelines: Maybe<PipelineConnection>;
  /** Whether this organization is visible to everyone, including people outside it */
  public: Scalars['Boolean']['output'];
  /**
   * API tokens with access to this organization will be automatically revoked
   * after this many seconds of inactivity. A `null` value indicates never revoke
   * inactive tokens.
   */
  revokeInactiveTokensAfter: Maybe<RevokeInactiveTokenPeriod>;
  /** The slug used to represent the organization in URLs */
  slug: Scalars['String']['output'];
  /** The single sign-on configuration of this organization */
  sso: Maybe<OrganizationSso>;
  /** Single sign on providers created for an organization */
  ssoProviders: Maybe<SsoProviderConnection>;
  /** Return all the suite the current user has access to for this organization */
  suites: Maybe<SuiteConnection>;
  /** Returns teams within the organization that the viewer can see */
  teams: Maybe<TeamConnection>;
  /** Returns the resource usage data for this organization. */
  usage: UsageUnionConnection;
  /** The public UUID for this organization */
  uuid: Scalars['String']['output'];
};


/** An organization */
export type OrganizationAgentTokensArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  revoked: InputMaybe<Scalars['Boolean']['input']>;
};


/** An organization */
export type OrganizationAgentsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  cluster: InputMaybe<Scalars['ID']['input']>;
  clusterQueue: InputMaybe<Array<Scalars['ID']['input']>>;
  clustered?: InputMaybe<Scalars['Boolean']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  isRunningJob: InputMaybe<Scalars['Boolean']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  metaData: InputMaybe<Array<Scalars['String']['input']>>;
  search: InputMaybe<Scalars['String']['input']>;
};


/** An organization */
export type OrganizationApiAccessTokensArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** An organization */
export type OrganizationAuditEventsArgs = {
  actor: InputMaybe<Array<Scalars['ID']['input']>>;
  actorType: InputMaybe<Array<AuditActorType>>;
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  occurredAtFrom: InputMaybe<Scalars['DateTime']['input']>;
  occurredAtTo: InputMaybe<Scalars['DateTime']['input']>;
  order?: InputMaybe<OrganizationAuditEventOrders>;
  subject: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectType: InputMaybe<Array<AuditSubjectType>>;
  subjectUUID: InputMaybe<Array<Scalars['ID']['input']>>;
  type: InputMaybe<Array<AuditEventType>>;
};


/** An organization */
export type OrganizationBannersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** An organization */
export type OrganizationClusterArgs = {
  id: Scalars['ID']['input'];
};


/** An organization */
export type OrganizationClustersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<ClusterOrder>;
};


/** An organization */
export type OrganizationInvitationsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<OrganizationInvitationOrders>;
  state: InputMaybe<Array<OrganizationInvitationStates>>;
};


/** An organization */
export type OrganizationJobsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  agentQueryRules: InputMaybe<Array<Scalars['String']['input']>>;
  before: InputMaybe<Scalars['String']['input']>;
  cluster: InputMaybe<Scalars['ID']['input']>;
  clusterQueue: InputMaybe<Array<Scalars['ID']['input']>>;
  clustered?: InputMaybe<Scalars['Boolean']['input']>;
  concurrency: InputMaybe<JobConcurrencySearch>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<JobOrder>;
  passed: InputMaybe<Scalars['Boolean']['input']>;
  priority: InputMaybe<JobPrioritySearch>;
  state: InputMaybe<Array<JobStates>>;
  step: InputMaybe<JobStepSearch>;
  type: InputMaybe<Array<JobTypes>>;
};


/** An organization */
export type OrganizationMembersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  email: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<OrganizationMemberOrder>;
  role: InputMaybe<Array<OrganizationMemberRole>>;
  search: InputMaybe<Scalars['String']['input']>;
  security: InputMaybe<OrganizationMemberSecurityInput>;
  sso: InputMaybe<OrganizationMemberSsoInput>;
  team: InputMaybe<Scalars['TeamSelector']['input']>;
};


/** An organization */
export type OrganizationPipelineTemplatesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<PipelineTemplateOrder>;
};


/** An organization */
export type OrganizationPipelinesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  archived: InputMaybe<Scalars['Boolean']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  cluster: InputMaybe<Scalars['ID']['input']>;
  clustered?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtFrom: InputMaybe<Scalars['DateTime']['input']>;
  createdAtTo: InputMaybe<Scalars['DateTime']['input']>;
  favorite: InputMaybe<Scalars['Boolean']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<PipelineOrders>;
  repository: InputMaybe<PipelineRepositoryInput>;
  search: InputMaybe<Scalars['String']['input']>;
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  team: InputMaybe<Scalars['TeamSelector']['input']>;
};


/** An organization */
export type OrganizationSsoProvidersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** An organization */
export type OrganizationSuitesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  createdAtFrom: InputMaybe<Scalars['DateTime']['input']>;
  createdAtTo: InputMaybe<Scalars['DateTime']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<SuiteOrders>;
  search: InputMaybe<Scalars['String']['input']>;
  team: InputMaybe<Scalars['TeamSelector']['input']>;
};


/** An organization */
export type OrganizationTeamsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamOrder>;
  pipeline: InputMaybe<Scalars['PipelineSelector']['input']>;
  privacy: InputMaybe<Array<TeamPrivacy>>;
  search: InputMaybe<Scalars['String']['input']>;
  user: InputMaybe<Scalars['UserSelector']['input']>;
};


/** An organization */
export type OrganizationUsageArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  aggregatedOnFrom: InputMaybe<Scalars['ISO8601Date']['input']>;
  aggregatedOnTo: InputMaybe<Scalars['ISO8601Date']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  pipelineIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  resource?: InputMaybe<Array<ResourceUsageType>>;
  suiteIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Information on user API Access Tokens which can access the Organization. Excludes the token attribute */
export type OrganizationApiAccessToken = {
  createdAt: Scalars['DateTime']['output'];
  /** A description of the token */
  description: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The IP address of the last request to the Buildkite API */
  ipAddress: Maybe<Scalars['String']['output']>;
  /** The last time the token was used to access the Buildkite API */
  lastAccessedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user associated with this token */
  owner: Maybe<User>;
  /** The organization scopes that the user's token has access to */
  scopes: Array<ApiAccessTokenScopes>;
  /** The public UUID for the API Access Token */
  uuid: Scalars['ID']['output'];
};

/** The connection type for OrganizationAPIAccessToken. */
export type OrganizationApiAccessTokenConnection = {
  /** A list of edges. */
  edges: Maybe<Array<Maybe<OrganizationApiAccessTokenEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<OrganizationApiAccessToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OrganizationApiAccessTokenEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<OrganizationApiAccessToken>;
};

/** Autogenerated input type of OrganizationAPIAccessTokenRevokeMutation */
export type OrganizationApiAccessTokenRevokeMutationInput = {
  apiAccessTokenId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationAPIAccessTokenRevokeMutation. */
export type OrganizationApiAccessTokenRevokeMutationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  revokedApiAccessTokenId: Scalars['ID']['output'];
};

/** Autogenerated input type of OrganizationAPIIPAllowlistUpdateMutation */
export type OrganizationApiipAllowlistUpdateMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  ipAddresses: Scalars['String']['input'];
  organizationID: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationAPIIPAllowlistUpdateMutation. */
export type OrganizationApiipAllowlistUpdateMutationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
};

export type OrganizationAuditEventConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationAuditEventEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type OrganizationAuditEventEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<AuditEvent>;
};

/** The different orders you can sort audit events by */
export type OrganizationAuditEventOrders =
  /** Order by the most recently occurring events first */
  | 'RECENTLY_OCCURRED';

/** System banner of an organization */
export type OrganizationBanner = Node & {
  id: Scalars['ID']['output'];
  /** The banner message */
  message: Scalars['String']['output'];
  /** The UUID of the organization banner */
  uuid: Scalars['String']['output'];
};

/** The connection type for OrganizationBanner. */
export type OrganizationBannerConnection = {
  /** A list of edges. */
  edges: Maybe<Array<Maybe<OrganizationBannerEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<OrganizationBanner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of OrganizationBannerDelete */
export type OrganizationBannerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationBannerDelete. */
export type OrganizationBannerDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedBannerId: Scalars['ID']['output'];
};

/** An edge in a connection. */
export type OrganizationBannerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<OrganizationBanner>;
};

/** Autogenerated input type of OrganizationBannerUpsert */
export type OrganizationBannerUpsertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  message: Scalars['String']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationBannerUpsert. */
export type OrganizationBannerUpsertPayload = {
  banner: OrganizationBanner;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
};

export type OrganizationConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type OrganizationEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Organization>;
};

/** Autogenerated input type of OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutation */
export type OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  membersRequireTwoFactorAuthentication: Scalars['Boolean']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutation. */
export type OrganizationEnforceTwoFactorAuthenticationForMembersUpdateMutationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Organization;
};

/** A pending invitation to a user to join this organization */
export type OrganizationInvitation = Node & {
  /** The time when the invitation was accepted */
  acceptedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that accepted this invite */
  acceptedBy: Maybe<User>;
  /** The time when the invitation was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that added invited this email address */
  createdBy: Maybe<User>;
  /** The email address of this invitation */
  email: Scalars['String']['output'];
  /** The time when the invitation was automatically expired */
  expiredAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  organization: Maybe<Organization>;
  permissions: OrganizationInvitationPermissions;
  /** The time when this invitation was revoked */
  revokedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that revoked this invitation */
  revokedBy: Maybe<User>;
  /** The role the user will have in the organization once they've accepted the invitation */
  role: OrganizationMemberRole;
  /** The slug of the invitation that can be used to find an invitation in the query root */
  slug: Scalars['String']['output'];
  sso: OrganizationInvitationSsoType;
  /** The current state of the invitation */
  state: OrganizationInvitationStates;
  /** Teams that have been assigned to this invitation */
  teams: Maybe<OrganizationInvitationTeamAssignmentConnection>;
  /** The UUID of the invitation */
  uuid: Scalars['String']['output'];
};


/** A pending invitation to a user to join this organization */
export type OrganizationInvitationTeamsArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
};

export type OrganizationInvitationConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of OrganizationInvitationCreate */
export type OrganizationInvitationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  emails: Array<Scalars['String']['input']>;
  organizationID: Scalars['ID']['input'];
  role: InputMaybe<OrganizationMemberRole>;
  sso: InputMaybe<OrganizationInvitationSsoInput>;
  teams: InputMaybe<Array<OrganizationInvitationTeamAssignmentInput>>;
};

/** Autogenerated return type of OrganizationInvitationCreate. */
export type OrganizationInvitationCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  invitationEdges: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;
  organization: Maybe<Organization>;
};

export type OrganizationInvitationEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<OrganizationInvitation>;
};

/** The different orders you can sort organization invitations by */
export type OrganizationInvitationOrders =
  /** Order by email address alphabetically */
  | 'EMAIL'
  /** Order by the most recently created invitations first */
  | 'RECENTLY_CREATED';

/** Permissions information about what actions the current user can do against this invitation */
export type OrganizationInvitationPermissions = {
  /** Whether the user can resend this invitation */
  organizationInvitationResend: Maybe<Permission>;
  /** Whether the user can revoke this invitation */
  organizationInvitationRevoke: Maybe<Permission>;
};

/** Autogenerated input type of OrganizationInvitationResend */
export type OrganizationInvitationResendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationInvitationResend. */
export type OrganizationInvitationResendPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organizationInvitation: OrganizationInvitation;
};

/** Autogenerated input type of OrganizationInvitationRevoke */
export type OrganizationInvitationRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationInvitationRevoke. */
export type OrganizationInvitationRevokePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Organization;
  organizationInvitation: OrganizationInvitation;
  organizationInvitationEdge: OrganizationInvitationEdge;
};

export type OrganizationInvitationSsoInput = {
  mode: OrganizationMemberSsoModeEnum;
};

/** Information about the SSO setup for this invited organization member */
export type OrganizationInvitationSsoType = {
  /** The SSO mode of the invited organization member */
  mode: Maybe<OrganizationMemberSsoModeEnum>;
};

/** All the possible states that an organization invitation can be */
export type OrganizationInvitationStates =
  /** The invitation was accepted by the person it was sent to */
  | 'ACCEPTED'
  /** The invitation wasn't accepted and the link has expired */
  | 'EXPIRED'
  /** The invitation is waiting for a user to accept it */
  | 'PENDING'
  /** The invitation was revoked and can no longer be accepted */
  | 'REVOKED';

/** A team that has been assigned to an invitation */
export type OrganizationInvitationTeamAssignment = {
  id: Scalars['ID']['output'];
  /** The role that the user will have once they've accepted the invite */
  role: TeamMemberRole;
  /** The team that this assignment refers to */
  team: Team;
};

export type OrganizationInvitationTeamAssignmentConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationInvitationTeamAssignmentEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type OrganizationInvitationTeamAssignmentEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<OrganizationInvitationTeamAssignment>;
};

/** Used to assign teams to organization invitation in mutations */
export type OrganizationInvitationTeamAssignmentInput = {
  /** The ID of the team you want the user to join once they've accepted the invite */
  id: Scalars['ID']['input'];
  /** The role in the team you want the user to have */
  role: TeamMemberRole;
};

/** A member of an organization */
export type OrganizationMember = Node & {
  /** Whether or not organizations are required to pay for this user */
  complimentary: Scalars['Boolean']['output'];
  /** The time when this user was added to the organization */
  createdAt: Scalars['DateTime']['output'];
  /** The user that added invited this user */
  createdBy: Maybe<User>;
  id: Scalars['ID']['output'];
  organization: Organization;
  permissions: OrganizationMemberPermissions;
  /** Pipelines the user has access to within the organization */
  pipelines: OrganizationMemberPipelineConnection;
  /** The users role within the organization */
  role: OrganizationMemberRole;
  security: OrganizationMemberSecurity;
  sso: OrganizationMemberSso;
  /** Teams that this user is a part of within the organization */
  teams: TeamMemberConnection;
  user: User;
  /** The public UUID for this organization member */
  uuid: Scalars['String']['output'];
};


/** A member of an organization */
export type OrganizationMemberPipelinesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<PipelineOrders>;
  search: InputMaybe<Scalars['String']['input']>;
};


/** A member of an organization */
export type OrganizationMemberTeamsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamMemberOrder>;
};

export type OrganizationMemberConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationMemberEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of OrganizationMemberDelete */
export type OrganizationMemberDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of OrganizationMemberDelete. */
export type OrganizationMemberDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedOrganizationMemberID: Scalars['ID']['output'];
  organization: Maybe<Organization>;
  user: Maybe<User>;
};

export type OrganizationMemberEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<OrganizationMember>;
};

/** The different orders you can sort members by */
export type OrganizationMemberOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently created members first */
  | 'RECENTLY_CREATED'
  /** Order by relevance when searching for members */
  | 'RELEVANCE';

/** Permissions information about what actions the current user can do against the organization membership record */
export type OrganizationMemberPermissions = {
  /** Whether the user can delete the user from the organization */
  organizationMemberDelete: Maybe<Permission>;
  /** Whether the user can update the organization's members role information */
  organizationMemberUpdate: Maybe<Permission>;
};

/** Represents the connection between a user an a pipeline within an organization */
export type OrganizationMemberPipeline = {
  /** The pipeline the user has access to within the organization */
  pipeline: Pipeline;
};

export type OrganizationMemberPipelineConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<OrganizationMemberPipelineEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type OrganizationMemberPipelineEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<OrganizationMemberPipeline>;
};

/** The roles a user can be within an organization */
export type OrganizationMemberRole =
  /** Has full access to the entire organization */
  | 'ADMIN'
  /** The user is a regular member of the organization */
  | 'MEMBER';

/** Information about the SSO setup for this organization member */
export type OrganizationMemberSso = {
  /** SSO authorizations provided by your organization that have been created for this user */
  authorizations: Maybe<SsoAuthorizationConnection>;
  /** The SSO mode of the organization member */
  mode: Maybe<OrganizationMemberSsoModeEnum>;
};


/** Information about the SSO setup for this organization member */
export type OrganizationMemberSsoAuthorizationsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  state: InputMaybe<Array<SsoAuthorizationState>>;
};

export type OrganizationMemberSsoInput = {
  mode: OrganizationMemberSsoModeEnum;
};

/** The SSO authorization modes you can use on a member */
export type OrganizationMemberSsoModeEnum =
  /** The member can either use SSO or their email & password */
  | 'OPTIONAL'
  /** The member must use SSO to access your organization */
  | 'REQUIRED';

/** Information about what security settings the user has enabled in Buildkite */
export type OrganizationMemberSecurity = {
  /** If the user has secured their Buildkite user account with a password */
  passwordProtected: Scalars['Boolean']['output'];
  /** If the user has enabled Two Factor Authentication */
  twoFactorEnabled: Scalars['Boolean']['output'];
};

export type OrganizationMemberSecurityInput = {
  passwordProtected: InputMaybe<Scalars['Boolean']['input']>;
  twoFactorEnabled: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of OrganizationMemberUpdate */
export type OrganizationMemberUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: InputMaybe<OrganizationMemberRole>;
  sso: InputMaybe<OrganizationMemberSsoInput>;
};

/** Autogenerated return type of OrganizationMemberUpdate. */
export type OrganizationMemberUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organizationMember: Maybe<OrganizationMember>;
};

/** Permissions information about what actions the current user can do against the organization */
export type OrganizationPermissions = {
  /** Whether the user can create agent tokens */
  agentTokenCreate: Maybe<Permission>;
  /** Whether the user can access agent tokens */
  agentTokenView: Maybe<Permission>;
  /** Whether the user can create a see a list of agents in organization */
  agentView: Maybe<Permission>;
  /** Whether the user can access audit events for the organization */
  auditEventsView: Maybe<Permission>;
  /** Whether the user can change the notification services for the organization */
  notificationServiceUpdate: Maybe<Permission>;
  /** Whether the user can view and manage billing for the organization */
  organizationBillingUpdate: Maybe<Permission>;
  /** Whether the user can invite members from an organization */
  organizationInvitationCreate: Maybe<Permission>;
  /** Whether the user can update/remove members from an organization */
  organizationMemberUpdate: Maybe<Permission>;
  /** Whether the user can see members in the organization */
  organizationMemberView: Maybe<Permission>;
  /** Whether the user can see sensitive information about members in the organization */
  organizationMemberViewSensitive: Maybe<Permission>;
  /** Whether the user can change the organization name and related source code provider settings */
  organizationUpdate: Maybe<Permission>;
  /** Whether the user can create a new pipeline in the organization */
  pipelineCreate: Maybe<Permission>;
  /** Whether the user can create a new pipeline without adding it to any teams within the organization */
  pipelineCreateWithoutTeams: Maybe<Permission>;
  /** Whether the user can create a see a list of pipelines in organization */
  pipelineView: Maybe<Permission>;
  /** Whether the user can change SSO Providers for the organization */
  ssoProviderCreate: Maybe<Permission>;
  /** Whether the user can change SSO Providers for the organization */
  ssoProviderUpdate: Maybe<Permission>;
  /** Whether the user can create a see a list of suites in organization */
  suiteView: Maybe<Permission>;
  /** Whether the user can administer one or all the teams in the organization */
  teamAdmin: Maybe<Permission>;
  /** Whether the user can create teams for the organization */
  teamCreate: Maybe<Permission>;
  /** Whether the user can toggle teams on/off for the organization */
  teamEnabledChange: Maybe<Permission>;
  /** Whether the user can see teams in the organization */
  teamView: Maybe<Permission>;
};

/** Autogenerated input type of OrganizationRevokeInactiveTokensAfterUpdateMutation */
export type OrganizationRevokeInactiveTokensAfterUpdateMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
  revokeInactiveTokensAfter: RevokeInactiveTokenPeriod;
};

/** Autogenerated return type of OrganizationRevokeInactiveTokensAfterUpdateMutation. */
export type OrganizationRevokeInactiveTokensAfterUpdateMutationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
};

/** Single sign-on settings for an organization */
export type OrganizationSso = {
  /** Whether this account is configured for single sign-on */
  isEnabled: Scalars['Boolean']['output'];
  /** The single sign-on provider for this organization */
  provider: Maybe<OrganizationSsoProvider>;
};

/** Single sign-on provider information for an organization */
export type OrganizationSsoProvider = {
  name: Scalars['String']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['String']['output']>;
};

/** The result of checking a permissions */
export type Permission = {
  allowed: Scalars['Boolean']['output'];
  code: Maybe<Scalars['String']['output']>;
  message: Maybe<Scalars['String']['output']>;
};

/** A pipeline */
export type Pipeline = Node & {
  /** Whether existing builds can be rebuilt as new builds. */
  allowRebuilds: Maybe<Scalars['Boolean']['output']>;
  /** Whether this pipeline has been archived */
  archived: Scalars['Boolean']['output'];
  /** The time when the pipeline was archived */
  archivedAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that archived this pipeline */
  archivedBy: Maybe<User>;
  /** A branch filter pattern to limit which pushed branches trigger builds on this pipeline. */
  branchConfiguration: Maybe<Scalars['String']['output']>;
  /**
   * Choose to keep builds or remove them after a set time period. Pipelines are
   * scanned once a day for builds that can be removed according to these settings.
   * @deprecated Build retention is now determined by your billing plan. This field is no longer used and always returns null.
   */
  buildRetentionEnabled: Maybe<Scalars['Boolean']['output']>;
  /**
   * The minimum number of builds to keep in the pipeline regardless of how old the builds are.
   * @deprecated Build retention is now determined by your billing plan. This field is no longer used and always returns null.
   */
  buildRetentionNumber: Maybe<Scalars['Int']['output']>;
  /**
   * How long is a build kept before it is automatically removed.
   * @deprecated Build retention is now determined by your billing plan. This field is no longer used and always returns null.
   */
  buildRetentionPeriod: Maybe<BuildRetentionPeriods>;
  /** Returns the builds for this pipeline */
  builds: Maybe<BuildConnection>;
  /**
   * When a new build is created on a branch, any previous builds that are running
   * on the same branch will be automatically cancelled
   */
  cancelIntermediateBuilds: Scalars['Boolean']['output'];
  /**
   * Limit which branches build cancelling applies to, for example `!main` will
   * ensure that the main branch won't have it's builds automatically cancelled.
   */
  cancelIntermediateBuildsBranchFilter: Maybe<Scalars['String']['output']>;
  cluster: Maybe<Cluster>;
  /** The color of the pipeline */
  color: Maybe<Scalars['String']['output']>;
  /** The shortest length to which any git commit ID may be truncated while guaranteeing referring to a unique commit */
  commitShortLength: Scalars['Int']['output'];
  /** The time when the pipeline was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** The user who created the pipeline */
  createdBy: Maybe<User>;
  /** The default branch for this pipeline */
  defaultBranch: Maybe<Scalars['String']['output']>;
  /** The default timeout in minutes for all command steps in this pipeline. This can still be overridden in any command step */
  defaultTimeoutInMinutes: Maybe<Scalars['Int']['output']>;
  /** The short description of the pipeline */
  description: Maybe<Scalars['String']['output']>;
  /** The emoji of the pipeline */
  emoji: Maybe<Scalars['String']['output']>;
  /** Returns true if the viewer has favorited this pipeline */
  favorite: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  jobs: Maybe<JobConnection>;
  /**
   * The maximum timeout in minutes for all command steps in this pipeline. Any
   * command step without a timeout or with a timeout greater than this value will
   * be set to this value.
   */
  maximumTimeoutInMinutes: Maybe<Scalars['Int']['output']>;
  metrics: Maybe<PipelineMetricConnection>;
  /** The name of the pipeline */
  name: Scalars['String']['output'];
  /** The next build number in the sequence */
  nextBuildNumber: Scalars['Int']['output'];
  organization: Organization;
  permissions: PipelinePermissions;
  pipelineTemplate: Maybe<PipelineTemplate>;
  /**
   * Whether this pipeline is visible to everyone, including people outside this organization
   * @deprecated Use `visibility`
   */
  public: Scalars['Boolean']['output'];
  /** The repository for this pipeline */
  repository: Maybe<Repository>;
  /** Schedules for this pipeline */
  schedules: Maybe<PipelineScheduleConnection>;
  /**
   * When a new build is created on a branch, any previous builds that haven't yet
   * started on the same branch will be automatically marked as skipped.
   */
  skipIntermediateBuilds: Scalars['Boolean']['output'];
  /**
   * Limit which branches build skipping applies to, for example `!main` will
   * ensure that the main branch won't have it's builds automatically skipped.
   */
  skipIntermediateBuildsBranchFilter: Maybe<Scalars['String']['output']>;
  /** The slug of the pipeline */
  slug: Scalars['String']['output'];
  steps: Maybe<PipelineSteps>;
  /** Tags that have been given to this pipeline */
  tags: Array<PipelineTag>;
  /** Teams associated with this pipeline */
  teams: Maybe<TeamPipelineConnection>;
  /** The URL for the pipeline */
  url: Scalars['String']['output'];
  /** The UUID of the pipeline */
  uuid: Scalars['String']['output'];
  /** Whether this pipeline is visible to everyone, including people outside this organization */
  visibility: PipelineVisibility;
  /** The URL to use in your repository settings for commit webhooks */
  webhookURL: Scalars['String']['output'];
};


/** A pipeline */
export type PipelineBuildsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  branch: InputMaybe<Array<Scalars['String']['input']>>;
  commit: InputMaybe<Array<Scalars['String']['input']>>;
  createdAtFrom: InputMaybe<Scalars['DateTime']['input']>;
  createdAtTo: InputMaybe<Scalars['DateTime']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  metaData: InputMaybe<Array<Scalars['String']['input']>>;
  state: InputMaybe<Array<BuildStates>>;
};


/** A pipeline */
export type PipelineJobsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  agentQueryRules: InputMaybe<Array<Scalars['String']['input']>>;
  before: InputMaybe<Scalars['String']['input']>;
  concurrency: InputMaybe<JobConcurrencySearch>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<JobOrder>;
  passed: InputMaybe<Scalars['Boolean']['input']>;
  priority: InputMaybe<JobPrioritySearch>;
  state: InputMaybe<Array<JobStates>>;
  step: InputMaybe<JobStepSearch>;
  type: InputMaybe<Array<JobTypes>>;
};


/** A pipeline */
export type PipelineMetricsArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** A pipeline */
export type PipelineSchedulesArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
};


/** A pipeline */
export type PipelineTeamsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamPipelineOrder>;
  search: InputMaybe<Scalars['String']['input']>;
};

/** The access levels that can be assigned to a pipeline */
export type PipelineAccessLevels =
  /** Allows builds and read only */
  | 'BUILD_AND_READ'
  /** Allows edits, builds and reads */
  | 'MANAGE_BUILD_AND_READ'
  /** Read only - no builds or edits */
  | 'READ_ONLY';

/** Autogenerated input type of PipelineArchive */
export type PipelineArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineArchive. */
export type PipelineArchivePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Pipeline;
};

export type PipelineConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<PipelineEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of PipelineCreate */
export type PipelineCreateInput = {
  /** If existing builds can be rebuilt as new builds. */
  allowRebuilds: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter pattern to limit which pushed branches trigger builds on this pipeline. */
  branchConfiguration: InputMaybe<Scalars['String']['input']>;
  /** If intermediate builds should be canceled as new builds are created */
  cancelIntermediateBuilds: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter to scope which builds this is applied to */
  cancelIntermediateBuildsBranchFilter: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** The GraphQL ID of the cluster you want to use for the pipeline */
  clusterId: InputMaybe<Scalars['ID']['input']>;
  /** A color hex code to represent this pipeline. */
  color: InputMaybe<Scalars['String']['input']>;
  /** The default branch used to show statistics about the build */
  defaultBranch: InputMaybe<Scalars['String']['input']>;
  /** The default timeout in minutes for all command steps in this pipeline. This can still be overridden in any command step. */
  defaultTimeoutInMinutes: InputMaybe<Scalars['Int']['input']>;
  /** A description of this pipeline. */
  description: InputMaybe<Scalars['String']['input']>;
  /** An emoji to represent this pipeline. */
  emoji: InputMaybe<Scalars['String']['input']>;
  /**
   * The maximum timeout in minutes for all command steps in this pipeline. Any
   * command step without a timeout or with a timeout greater than this value will
   * be set to this value.
   */
  maximumTimeoutInMinutes: InputMaybe<Scalars['Int']['input']>;
  /** The `graphql_name` of the pipeline. */
  name: Scalars['String']['input'];
  /** The initial build number to use in the sequence */
  nextBuildNumber: InputMaybe<Scalars['Int']['input']>;
  organizationId: Scalars['ID']['input'];
  /** The GraphQL ID of the pipeline template you want to use for the pipeline */
  pipelineTemplateId: InputMaybe<Scalars['ID']['input']>;
  /** A source code repository that will back this pipeline */
  repository: PipelineRepositoryInput;
  /** If intermediate builds should be skipped as new builds are created */
  skipIntermediateBuilds: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter to scope which builds this is applied to */
  skipIntermediateBuildsBranchFilter: InputMaybe<Scalars['String']['input']>;
  /** Steps used by this pipeline defined as YAML */
  steps: InputMaybe<PipelineStepsInput>;
  /** Tags you want this pipeline to have */
  tags: InputMaybe<Array<PipelineTagInput>>;
  /** Which teams this pipeline should be assigned to */
  teams: InputMaybe<Array<PipelineTeamAssignmentInput>>;
  /** The visibility of the pipeline, either PUBLIC or PRIVATE. */
  visibility: InputMaybe<PipelineVisibility>;
};

/** Autogenerated return type of PipelineCreate. */
export type PipelineCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  cluster: Maybe<Cluster>;
  organization: Organization;
  pipeline: Pipeline;
  pipelineEdge: PipelineEdge;
  pipelineTemplate: Maybe<PipelineTemplate>;
};

/** Autogenerated input type of PipelineCreateWebhook */
export type PipelineCreateWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineCreateWebhook. */
export type PipelineCreateWebhookPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipelineID: Scalars['ID']['output'];
};

/** Autogenerated input type of PipelineDelete */
export type PipelineDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineDelete. */
export type PipelineDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPipelineID: Scalars['ID']['output'];
  organization: Organization;
};

export type PipelineEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Pipeline>;
};

/** Autogenerated input type of PipelineFavorite */
export type PipelineFavoriteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  favorite: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineFavorite. */
export type PipelineFavoritePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Maybe<Pipeline>;
};

/** A metric for a pipeline */
export type PipelineMetric = Node & {
  id: Scalars['ID']['output'];
  /** The label of this metric */
  label: Scalars['ID']['output'];
  /** The URL for this metric */
  url: Maybe<Scalars['String']['output']>;
  /** The value for this metric */
  value: Maybe<Scalars['String']['output']>;
};

export type PipelineMetricConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<PipelineMetricEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type PipelineMetricEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<PipelineMetric>;
};

/** The different orders you can sort pipelines by */
export type PipelineOrders =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by favorites first alphabetically, then the rest of the pipelines alphabetically */
  | 'NAME_WITH_FAVORITES_FIRST'
  /** Order by the most recently created pipelines first */
  | 'RECENTLY_CREATED'
  /** Order by relevance when searching for pipelines */
  | 'RELEVANCE';

/** Permission information about what actions the current user can do against the pipeline */
export type PipelinePermissions = {
  /** Whether the user can create builds on this pipeline */
  buildCreate: Permission;
  /** Whether the user can delete this pipeline */
  pipelineDelete: Permission;
  /** Whether the user can favorite this pipeline */
  pipelineFavorite: Permission;
  /** Whether the user can create schedules on this pipeline */
  pipelineScheduleCreate: Permission;
  /** Whether the user can edit the settings of this pipeline */
  pipelineUpdate: Permission;
};

/** Repository information for a pipeline */
export type PipelineRepositoryInput = {
  /** The remote URL for this repository i.e. git@github.com:foo/bar.git */
  url: Scalars['String']['input'];
};

/** Autogenerated input type of PipelineRotateWebhookURL */
export type PipelineRotateWebhookUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineRotateWebhookURL. */
export type PipelineRotateWebhookUrlPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Pipeline;
};

/** A schedule of when a build should automatically triggered for a Pipeline */
export type PipelineSchedule = Node & {
  /** The branch to use for builds that this schedule triggers. Defaults to to the default branch in the Pipeline */
  branch: Maybe<Scalars['String']['output']>;
  /** Returns the builds created by this schedule */
  builds: Maybe<BuildConnection>;
  /** The commit to use for builds that this schedule triggers. Defaults to `HEAD` */
  commit: Maybe<Scalars['String']['output']>;
  /** The time when this schedule was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  createdBy: Maybe<User>;
  /** A definition of the trigger build schedule in cron syntax */
  cronline: Scalars['String']['output'];
  /** If this Pipeline schedule is currently enabled */
  enabled: Maybe<Scalars['Boolean']['output']>;
  /** Environment variables passed to any triggered builds */
  env: Maybe<Array<Scalars['String']['output']>>;
  /** The time when this schedule failed */
  failedAt: Maybe<Scalars['DateTime']['output']>;
  /** If the last attempt at triggering this scheduled build fails, this will be the reason */
  failedMessage: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** A short description of the Pipeline schedule */
  label: Scalars['String']['output'];
  /** The message to use for builds that this schedule triggers */
  message: Maybe<Scalars['String']['output']>;
  /** The time when this schedule will create a build next */
  nextBuildAt: Maybe<Scalars['DateTime']['output']>;
  permissions: PipelineSchedulePermissions;
  pipeline: Maybe<Pipeline>;
  /** The UUID of the Pipeline schedule */
  uuid: Scalars['String']['output'];
};


/** A schedule of when a build should automatically triggered for a Pipeline */
export type PipelineScheduleBuildsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

export type PipelineScheduleConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<PipelineScheduleEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of PipelineScheduleCreate */
export type PipelineScheduleCreateInput = {
  branch: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  commit: InputMaybe<Scalars['String']['input']>;
  cronline: InputMaybe<Scalars['String']['input']>;
  enabled: InputMaybe<Scalars['Boolean']['input']>;
  env: InputMaybe<Scalars['String']['input']>;
  label: InputMaybe<Scalars['String']['input']>;
  message: InputMaybe<Scalars['String']['input']>;
  pipelineID: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineScheduleCreate. */
export type PipelineScheduleCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Pipeline;
  pipelineScheduleEdge: PipelineScheduleEdge;
};

/** Autogenerated input type of PipelineScheduleDelete */
export type PipelineScheduleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineScheduleDelete. */
export type PipelineScheduleDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPipelineScheduleID: Scalars['ID']['output'];
  pipeline: Maybe<Pipeline>;
};

export type PipelineScheduleEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<PipelineSchedule>;
};

/** Permission information about what actions the current user can do against the pipeline schedule */
export type PipelineSchedulePermissions = {
  /** Whether the user can delete the schedule */
  pipelineScheduleDelete: Maybe<Permission>;
  /** Whether the user can update the schedule */
  pipelineScheduleUpdate: Maybe<Permission>;
};

/** Autogenerated input type of PipelineScheduleUpdate */
export type PipelineScheduleUpdateInput = {
  branch: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  commit: InputMaybe<Scalars['String']['input']>;
  cronline: InputMaybe<Scalars['String']['input']>;
  enabled: InputMaybe<Scalars['Boolean']['input']>;
  env: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  label: InputMaybe<Scalars['String']['input']>;
  message: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of PipelineScheduleUpdate. */
export type PipelineScheduleUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipelineSchedule: PipelineSchedule;
};

/** Steps defined on a pipeline */
export type PipelineSteps = {
  /** A YAML representation of the pipeline steps */
  yaml: Maybe<Scalars['YAML']['output']>;
};

/** Step definition for a pipeline */
export type PipelineStepsInput = {
  /** A YAML representation of the steps in this pipeline. This is formatted the same as `buildkite-agent pipeline upload */
  yaml: Scalars['String']['input'];
};

/** A tag associated with a pipeline */
export type PipelineTag = {
  /** The label for this tag */
  label: Scalars['String']['output'];
};

/** Tag associated with a pipeline */
export type PipelineTagInput = {
  /** The label of this tag */
  label: Scalars['String']['input'];
};

/** Used to assign teams to pipelines */
export type PipelineTeamAssignmentInput = {
  /** The access level members within the team have to the pipeline */
  accessLevel: InputMaybe<PipelineAccessLevels>;
  /** The ID of the team you want to be assigned */
  id: Scalars['ID']['input'];
};

/** A template defining a fixed step configuration for a pipeline */
export type PipelineTemplate = Node & {
  /** If the pipeline template is available for assignment by non admin users */
  available: Scalars['Boolean']['output'];
  /** A YAML representation of the step configuration */
  configuration: Scalars['YAML']['output'];
  /** The time when the template was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user who created the template */
  createdBy: User;
  /** The short description of the template */
  description: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The name of the template */
  name: Scalars['String']['output'];
  /** The last time the template was changed */
  updatedAt: Scalars['DateTime']['output'];
  /** The user who last updated the template */
  updatedBy: User;
  /** The UUID for the template */
  uuid: Scalars['ID']['output'];
};

export type PipelineTemplateConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<PipelineTemplateEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of PipelineTemplateCreate */
export type PipelineTemplateCreateInput = {
  /** If the pipeline template is available for assignment by non admin users */
  available: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** YAML step configuration for the pipeline template */
  configuration: Scalars['String']['input'];
  /** Description for the pipeline template */
  description: InputMaybe<Scalars['String']['input']>;
  /** Name for the pipeline template */
  name: Scalars['String']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineTemplateCreate. */
export type PipelineTemplateCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipelineTemplate: PipelineTemplate;
};

/** Autogenerated input type of PipelineTemplateDelete */
export type PipelineTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineTemplateDelete. */
export type PipelineTemplateDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPipelineTemplateId: Scalars['ID']['output'];
};

export type PipelineTemplateEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<PipelineTemplate>;
};

/** The different orders you can sort pipeline templates by */
export type PipelineTemplateOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently created pipeline templates first */
  | 'RECENTLY_CREATED';

/** Autogenerated input type of PipelineTemplateUpdate */
export type PipelineTemplateUpdateInput = {
  /** If the pipeline template is available for assignment by non admin users */
  available: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** YAML step configuration for the pipeline template */
  configuration: InputMaybe<Scalars['String']['input']>;
  /** Description for the pipeline template */
  description: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** Name for the pipeline template */
  name: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineTemplateUpdate. */
export type PipelineTemplateUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipelineTemplate: PipelineTemplate;
};

/** Autogenerated input type of PipelineUnarchive */
export type PipelineUnarchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PipelineUnarchive. */
export type PipelineUnarchivePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Pipeline;
};

/** Autogenerated input type of PipelineUpdate */
export type PipelineUpdateInput = {
  /** If existing builds can be rebuilt as new builds. */
  allowRebuilds: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether or not this pipeline should be archived. This field is deprecated and
   * will be removed on 2022-06-01. Use ArchivePipeline and UnarchivePipeline
   * mutations instead.
   */
  archived: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter pattern to limit which pushed branches trigger builds on this pipeline. */
  branchConfiguration: InputMaybe<Scalars['String']['input']>;
  /** If intermediate builds should be canceled as new builds are created */
  cancelIntermediateBuilds: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter to scope which builds this is applied to */
  cancelIntermediateBuildsBranchFilter: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** The GraphQL ID of the cluster you want to update for the pipeline */
  clusterId: InputMaybe<Scalars['ID']['input']>;
  /** A color hex code to represent this pipeline. */
  color: InputMaybe<Scalars['String']['input']>;
  /** The default branch used to show statistics about the build */
  defaultBranch: InputMaybe<Scalars['String']['input']>;
  /** The default timeout in minutes for all command steps in this pipeline. This can still be overridden in any command step. */
  defaultTimeoutInMinutes: InputMaybe<Scalars['Int']['input']>;
  /** A description of this pipeline. */
  description: InputMaybe<Scalars['String']['input']>;
  /** An emoji to represent this pipeline. */
  emoji: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /**
   * The maximum timeout in minutes for all command steps in this pipeline. Any
   * command step without a timeout or with a timeout greater than this value will
   * be set to this value.
   */
  maximumTimeoutInMinutes: InputMaybe<Scalars['Int']['input']>;
  /** The `graphql_name` of the pipeline. */
  name: InputMaybe<Scalars['String']['input']>;
  /** The next build number to use in the sequence */
  nextBuildNumber: InputMaybe<Scalars['Int']['input']>;
  /** The GraphQL ID of the pipeline template you want to apply to this pipeline */
  pipelineTemplateId: InputMaybe<Scalars['ID']['input']>;
  /** A source code repository that will back this pipeline */
  repository: InputMaybe<PipelineRepositoryInput>;
  /** If intermediate builds should be skipped as new builds are created */
  skipIntermediateBuilds: InputMaybe<Scalars['Boolean']['input']>;
  /** A branch filter to scope which builds this is applied to */
  skipIntermediateBuildsBranchFilter: InputMaybe<Scalars['String']['input']>;
  /** Steps used by this pipeline defined as YAML */
  steps: InputMaybe<PipelineStepsInput>;
  /** Tags you want this pipeline to have */
  tags: InputMaybe<Array<PipelineTagInput>>;
  /** The visibility of the pipeline, either PUBLIC or PRIVATE. */
  visibility: InputMaybe<PipelineVisibility>;
};

/** Autogenerated return type of PipelineUpdate. */
export type PipelineUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Pipeline;
};

/** The visibility of the pipeline */
export type PipelineVisibility =
  /** The pipeline is private */
  | 'PRIVATE'
  /** The pipeline is public */
  | 'PUBLIC';

/** A pull request on a provider */
export type PullRequest = {
  id: Scalars['String']['output'];
};

/** The query root for this schema */
export type Query = {
  /** Find an agent by its slug */
  agent: Maybe<Agent>;
  /** Find an agent token by its slug */
  agentToken: Maybe<AgentToken>;
  /** Find a API Access Token code */
  apiAccessTokenCode: Maybe<ApiAccessTokenCode>;
  /** Find an artifact by its UUID */
  artifact: Maybe<Artifact>;
  /** Find an audit event via its uuid */
  auditEvent: Maybe<AuditEvent>;
  /** Find a build */
  build: Maybe<Build>;
  /** Find a GraphQL snippet */
  graphQLSnippet: Maybe<GraphQlSnippet>;
  /** Find a build job */
  job: Maybe<Job>;
  /** Fetches an object given its ID. */
  node: Maybe<Node>;
  /** Find a notification service via its UUID */
  notificationService: Maybe<NotificationService>;
  /** Find an organization */
  organization: Maybe<Organization>;
  /** Find an organization invitation via its slug */
  organizationInvitation: Maybe<OrganizationInvitation>;
  /** Find an organization membership via its slug */
  organizationMember: Maybe<OrganizationMember>;
  /** Find a pipeline */
  pipeline: Maybe<Pipeline>;
  /** Find a pipeline schedule by its slug */
  pipelineSchedule: Maybe<PipelineSchedule>;
  /** Find a pipeline template */
  pipelineTemplate: Maybe<PipelineTemplate>;
  /** Find an sso provider either using it's slug, or UUID */
  ssoProvider: Maybe<SsoProvider>;
  /** Find a team */
  team: Maybe<Team>;
  /** Context of the current user using the GraphQL API */
  viewer: Maybe<Viewer>;
};


/** The query root for this schema */
export type QueryAgentArgs = {
  slug: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryAgentTokenArgs = {
  slug: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryApiAccessTokenCodeArgs = {
  code: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryArtifactArgs = {
  uuid: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryAuditEventArgs = {
  uuid: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryBuildArgs = {
  slug: InputMaybe<Scalars['ID']['input']>;
  uuid: InputMaybe<Scalars['ID']['input']>;
};


/** The query root for this schema */
export type QueryGraphQlSnippetArgs = {
  uuid: Scalars['String']['input'];
};


/** The query root for this schema */
export type QueryJobArgs = {
  uuid: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryNotificationServiceArgs = {
  uuid: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryOrganizationArgs = {
  slug: InputMaybe<Scalars['ID']['input']>;
  uuid: InputMaybe<Scalars['ID']['input']>;
};


/** The query root for this schema */
export type QueryOrganizationInvitationArgs = {
  slug: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryOrganizationMemberArgs = {
  slug: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryPipelineArgs = {
  slug: InputMaybe<Scalars['ID']['input']>;
  uuid: InputMaybe<Scalars['ID']['input']>;
};


/** The query root for this schema */
export type QueryPipelineScheduleArgs = {
  slug: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QueryPipelineTemplateArgs = {
  uuid: Scalars['ID']['input'];
};


/** The query root for this schema */
export type QuerySsoProviderArgs = {
  slug: InputMaybe<Scalars['ID']['input']>;
  uuid: InputMaybe<Scalars['ID']['input']>;
};


/** The query root for this schema */
export type QueryTeamArgs = {
  slug: Scalars['ID']['input'];
};

/** A recovery code */
export type RecoveryCode = {
  /** The recovery code. */
  code: Scalars['String']['output'];
  /** Whether the recovery codes is used */
  consumed: Scalars['Boolean']['output'];
  /** Foo */
  consumedAt: Maybe<Scalars['String']['output']>;
};

/** A batch of recovery codes */
export type RecoveryCodeBatch = {
  /** Whether the batch of recovery codes is active */
  active: Scalars['Boolean']['output'];
  /**
   * The recovery codes from this batch. Codes are consumed when used, and codes
   * will be included in this list whether consumed or not
   */
  codes: Array<RecoveryCode>;
  id: Scalars['ID']['output'];
};

/** A repository associated with a pipeline */
export type Repository = {
  /** The repository’s provider */
  provider: Maybe<RepositoryProvider>;
  /** The git URL for this repository */
  url: Scalars['String']['output'];
};

export type RepositoryProvider = {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by Beanstalk */
export type RepositoryProviderBeanstalk = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by Bitbucket */
export type RepositoryProviderBitbucket = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by Bitbucket Server */
export type RepositoryProviderBitbucketServer = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by Codebase */
export type RepositoryProviderCodebase = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by GitHub */
export type RepositoryProviderGithub = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by GitHub Enterprise */
export type RepositoryProviderGithubEnterprise = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by GitLab */
export type RepositoryProviderGitlab = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by GitLab Community Edition */
export type RepositoryProviderGitlabCommunity = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by GitLab Enterprise Edition */
export type RepositoryProviderGitlabEnterprise = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** A pipeline's repository is being provided by a service unknown to Buildkite */
export type RepositoryProviderUnknown = RepositoryProvider & {
  /** The name of the provider */
  name: Scalars['String']['output'];
  /** This URL to the provider’s web interface */
  url: Maybe<Scalars['String']['output']>;
  /** The URL to use when setting up webhooks from the provider to trigger Buildkite builds */
  webhookUrl: Maybe<Scalars['String']['output']>;
};

/** An aggregate of resource usage, grouped by day and resource. */
export type ResourceUsageInterface = {
  aggregatedOn: Scalars['ISO8601Date']['output'];
};

/** All types of billable resources */
export type ResourceUsageType =
  /** These records represent a pipeline's job minutes usage for a single day */
  | 'JOB_MINUTES'
  /** These records represent a suite's test executions usage for a single day */
  | 'TEST_EXECUTIONS';

/** API tokens with access to this organization will be automatically revoked after this many days of inactivity. */
export type RevokeInactiveTokenPeriod =
  /** Revoke organization access from API tokens after 30 days of inactivity */
  | 'DAYS_30'
  /** Revoke organization access from API tokens after 60 days of inactivity */
  | 'DAYS_60'
  /** Revoke organization access from API tokens after 90 days of inactivity */
  | 'DAYS_90'
  /** Revoke organization access from API tokens after 180 days of inactivity */
  | 'DAYS_180'
  /** Revoke organization access from API tokens after 365 days of inactivity */
  | 'DAYS_365'
  /** Never revoke organization access from inactive API tokens */
  | 'NEVER';

export type ScmPipelineSettings = {
  id: Scalars['ID']['output'];
};

export type ScmRepositoryHost = {
  id: Scalars['ID']['output'];
};

export type ScmService = {
  id: Scalars['ID']['output'];
};

export type SsoAuthorization = {
  /** The time when this SSO Authorization was created */
  createdAt: Scalars['DateTime']['output'];
  /** The time when this SSO Authorization was expired */
  expiredAt: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** Details around the identity provided by the SSO provider */
  identity: Maybe<SsoAuthorizationIdentity>;
  /** The time when this SSO Authorization was manually revoked */
  revokedAt: Maybe<Scalars['DateTime']['output']>;
  /** The SSO provider associated with this authorization */
  ssoProvider: SsoProvider;
  /** The current state of the SSO Authorization */
  state: SsoAuthorizationState;
  /** The user associated with this authorization */
  user: Maybe<User>;
  /** The time when this SSO Authorization was destroyed because the user logged out */
  userSessionDestroyedAt: Maybe<Scalars['DateTime']['output']>;
  /** The public UUID for this SSO authorization */
  uuid: Scalars['String']['output'];
};

export type SsoAuthorizationConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<SsoAuthorizationEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type SsoAuthorizationEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<SsoAuthorization>;
};

export type SsoAuthorizationIdentity = {
  /** The avatar URL provided in this identity */
  avatarURL: Maybe<Scalars['String']['output']>;
  /** The email addresses provided in this identity */
  email: Maybe<Scalars['String']['output']>;
  /** The name provided in this identity */
  name: Maybe<Scalars['String']['output']>;
  /** The identifier provided in this identity */
  uid: Maybe<Scalars['String']['output']>;
};

/** All the possible states an SSO Authorization */
export type SsoAuthorizationState =
  /** The authorization has been verified and is in use */
  | 'VERIFIED'
  /** The authorization was verified but has since expired */
  | 'VERIFIED_EXPIRED'
  /** The authorization was verified but has since been manually revoked */
  | 'VERIFIED_REVOKED'
  /** The authorization was verified but has since been destroyed as the user logged out of that session */
  | 'VERIFIED_USER_SESSION_DESTROYED';

export type SsoProvider = {
  /** The time when this SSO Provider was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user that created this SSO Provider */
  createdBy: User;
  /** The time when this SSO Provider was disabled */
  disabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that disabled this SSO Provider */
  disabledBy: Maybe<User>;
  /** The reason this SSO Provider was disabled */
  disabledReason: Maybe<Scalars['String']['output']>;
  /** An email domain whose addresses should be offered this SSO Provider during login. */
  emailDomain: Maybe<Scalars['String']['output']>;
  emailDomainVerificationAddress: Maybe<Scalars['String']['output']>;
  emailDomainVerifiedAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when this SSO Provider was enabled */
  enabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that enabled this SSO Provider */
  enabledBy: Maybe<User>;
  id: Scalars['ID']['output'];
  /** An extra message that can be added the Authorization screen of an SSO Provider */
  note: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** Defaults to false. If true, users are required to re-authenticate when their IP address changes. */
  pinSessionToIpAddress: Maybe<Scalars['Boolean']['output']>;
  /** How long a session should last before requiring re-authorization. A `null` value indicates an infinite session. */
  sessionDurationInHours: Maybe<Scalars['Int']['output']>;
  /** The current state of the SSO Provider */
  state: SsoProviderStates;
  /** Whether the SSO Provider requires a test authorization. If true, the provider can not yet be activated. */
  testAuthorizationRequired: Maybe<Scalars['Boolean']['output']>;
  /** The type of SSO Provider */
  type: SsoProviderTypes;
  /** The authorization URL for this SSO Provider */
  url: Scalars['String']['output'];
  /** The UUID for this SSO Provider */
  uuid: Scalars['ID']['output'];
};

export type SsoProviderConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<SsoProviderEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of SSOProviderCreate */
export type SsoProviderCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  digestMethod: InputMaybe<SsoProviderSamlxmlSecurity>;
  discloseGoogleHostedDomain: InputMaybe<Scalars['Boolean']['input']>;
  emailDomain: InputMaybe<Scalars['String']['input']>;
  emailDomainVerificationAddress: InputMaybe<Scalars['String']['input']>;
  githubOrganizationName: InputMaybe<Scalars['String']['input']>;
  googleHostedDomain: InputMaybe<Scalars['String']['input']>;
  identityProvider: InputMaybe<SsoProviderSamlIdP>;
  note: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['ID']['input'];
  /**
   * When enabled, users will be required to re-authenticate if their IP address
   * changes. This feature is only available for some billing plans.
   */
  pinSessionToIpAddress: InputMaybe<Scalars['Boolean']['input']>;
  sessionDurationInHours: InputMaybe<Scalars['Int']['input']>;
  signatureMethod: InputMaybe<SsoProviderSamlrsaxmlSecurity>;
  type: SsoProviderTypes;
};

/** Autogenerated return type of SSOProviderCreate. */
export type SsoProviderCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Organization;
  ssoProvider: SsoProvider;
  ssoProviderEdge: SsoProviderEdge;
};

/** Autogenerated input type of SSOProviderDelete */
export type SsoProviderDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SSOProviderDelete. */
export type SsoProviderDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedSSOProviderId: Scalars['ID']['output'];
  organization: Organization;
};

/** Autogenerated input type of SSOProviderDisable */
export type SsoProviderDisableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  disabledReason: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SSOProviderDisable. */
export type SsoProviderDisablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  ssoProvider: SsoProvider;
};

export type SsoProviderEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<SsoProvider>;
};

/** Autogenerated input type of SSOProviderEnable */
export type SsoProviderEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of SSOProviderEnable. */
export type SsoProviderEnablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  ssoProvider: SsoProvider;
};

/** Single sign-on provided by GitHub */
export type SsoProviderGitHubApp = Node & SsoProvider & {
  /** The time when this SSO Provider was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user that created this SSO Provider */
  createdBy: User;
  /** The time when this SSO Provider was disabled */
  disabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that disabled this SSO Provider */
  disabledBy: Maybe<User>;
  /** The reason this SSO Provider was disabled */
  disabledReason: Maybe<Scalars['String']['output']>;
  /** An email domain whose addresses should be offered this SSO Provider during login. */
  emailDomain: Maybe<Scalars['String']['output']>;
  emailDomainVerificationAddress: Maybe<Scalars['String']['output']>;
  emailDomainVerifiedAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when this SSO Provider was enabled */
  enabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that enabled this SSO Provider */
  enabledBy: Maybe<User>;
  /** The name of the organization on GitHub that the user must be in for an SSO authorization to be verified */
  githubOrganizationName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** An extra message that can be added the Authorization screen of an SSO Provider */
  note: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** Defaults to false. If true, users are required to re-authenticate when their IP address changes. */
  pinSessionToIpAddress: Maybe<Scalars['Boolean']['output']>;
  /** How long a session should last before requiring re-authorization. A `null` value indicates an infinite session. */
  sessionDurationInHours: Maybe<Scalars['Int']['output']>;
  /** The current state of the SSO Provider */
  state: SsoProviderStates;
  /** Whether the SSO Provider requires a test authorization. If true, the provider can not yet be activated. */
  testAuthorizationRequired: Maybe<Scalars['Boolean']['output']>;
  /** The type of SSO Provider */
  type: SsoProviderTypes;
  /** The authorization URL for this SSO Provider */
  url: Scalars['String']['output'];
  /** The UUID for this SSO Provider */
  uuid: Scalars['ID']['output'];
};

/** Single sign-on provided by Google */
export type SsoProviderGoogleGSuite = Node & SsoProvider & {
  /** The time when this SSO Provider was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user that created this SSO Provider */
  createdBy: User;
  /** The time when this SSO Provider was disabled */
  disabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that disabled this SSO Provider */
  disabledBy: Maybe<User>;
  /** The reason this SSO Provider was disabled */
  disabledReason: Maybe<Scalars['String']['output']>;
  /** Whether or not the hosted domain should be presented to the user during SSO */
  discloseGoogleHostedDomain: Scalars['Boolean']['output'];
  /** An email domain whose addresses should be offered this SSO Provider during login. */
  emailDomain: Maybe<Scalars['String']['output']>;
  emailDomainVerificationAddress: Maybe<Scalars['String']['output']>;
  emailDomainVerifiedAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when this SSO Provider was enabled */
  enabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that enabled this SSO Provider */
  enabledBy: Maybe<User>;
  /** The Google hosted domain that is required to be present in OAuth */
  googleHostedDomain: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** An extra message that can be added the Authorization screen of an SSO Provider */
  note: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** Defaults to false. If true, users are required to re-authenticate when their IP address changes. */
  pinSessionToIpAddress: Maybe<Scalars['Boolean']['output']>;
  /** How long a session should last before requiring re-authorization. A `null` value indicates an infinite session. */
  sessionDurationInHours: Maybe<Scalars['Int']['output']>;
  /** The current state of the SSO Provider */
  state: SsoProviderStates;
  /** Whether the SSO Provider requires a test authorization. If true, the provider can not yet be activated. */
  testAuthorizationRequired: Maybe<Scalars['Boolean']['output']>;
  /** The type of SSO Provider */
  type: SsoProviderTypes;
  /** The authorization URL for this SSO Provider */
  url: Scalars['String']['output'];
  /** The UUID for this SSO Provider */
  uuid: Scalars['ID']['output'];
};

/** Single sign-on provided via SAML */
export type SsoProviderSaml = Node & SsoProvider & {
  /** The time when this SSO Provider was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user that created this SSO Provider */
  createdBy: User;
  /** The algorithm used to calculate the digest value during a SAML exchange */
  digestMethod: SsoProviderSamlxmlSecurity;
  /** The time when this SSO Provider was disabled */
  disabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that disabled this SSO Provider */
  disabledBy: Maybe<User>;
  /** The reason this SSO Provider was disabled */
  disabledReason: Maybe<Scalars['String']['output']>;
  /** An email domain whose addresses should be offered this SSO Provider during login. */
  emailDomain: Maybe<Scalars['String']['output']>;
  emailDomainVerificationAddress: Maybe<Scalars['String']['output']>;
  emailDomainVerifiedAt: Maybe<Scalars['DateTime']['output']>;
  /** The time when this SSO Provider was enabled */
  enabledAt: Maybe<Scalars['DateTime']['output']>;
  /** The user that enabled this SSO Provider */
  enabledBy: Maybe<User>;
  id: Scalars['ID']['output'];
  /** Information about the IdP */
  identityProvider: Maybe<SsoProviderSamlIdPType>;
  /** An extra message that can be added the Authorization screen of an SSO Provider */
  note: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** Defaults to false. If true, users are required to re-authenticate when their IP address changes. */
  pinSessionToIpAddress: Maybe<Scalars['Boolean']['output']>;
  serviceProvider: SsoProviderSamlspType;
  /** How long a session should last before requiring re-authorization. A `null` value indicates an infinite session. */
  sessionDurationInHours: Maybe<Scalars['Int']['output']>;
  /** The algorithm used to calculate the signature value during a SAML exchange */
  signatureMethod: SsoProviderSamlrsaxmlSecurity;
  /** The current state of the SSO Provider */
  state: SsoProviderStates;
  /** Whether the SSO Provider requires a test authorization. If true, the provider can not yet be activated. */
  testAuthorizationRequired: Maybe<Scalars['Boolean']['output']>;
  /** The type of SSO Provider */
  type: SsoProviderTypes;
  /** The authorization URL for this SSO Provider */
  url: Scalars['String']['output'];
  /** The UUID for this SSO Provider */
  uuid: Scalars['ID']['output'];
};

export type SsoProviderSamlIdP = {
  certificate: InputMaybe<Scalars['String']['input']>;
  issuer: InputMaybe<Scalars['String']['input']>;
  metadata: InputMaybe<SsoProviderSamlIdPMetadata>;
  ssoURL: InputMaybe<Scalars['String']['input']>;
};

export type SsoProviderSamlIdPMetadata = {
  url: InputMaybe<Scalars['String']['input']>;
  xml: InputMaybe<Scalars['XML']['input']>;
};

/** Information about the IdP for a SAML SSO Provider */
export type SsoProviderSamlIdPType = {
  /** The certificated provided by the IdP */
  certificate: Maybe<Scalars['String']['output']>;
  /** The IdP Issuer value for this SSO Provider */
  issuer: Maybe<Scalars['String']['output']>;
  /** The metadata used to configure this SSO provider if it was provided */
  metadata: Maybe<SsoProviderSamlMetadataType>;
  /** The name of the IdP Service. Returns nil if no name can be guessed from the SSO URL */
  name: Maybe<Scalars['String']['output']>;
  /** The IdP SSO URL for this SSO Provider */
  ssoURL: Maybe<Scalars['String']['output']>;
};

/** SAML metadata used for configuration */
export type SsoProviderSamlMetadataType = {
  /** The URL that this metadata can be publicly accessed at */
  url: Maybe<Scalars['String']['output']>;
  /** The XML for this metadata */
  xml: Maybe<Scalars['XML']['output']>;
};

/** XML RSA security algorithms used in the SAML exchange */
export type SsoProviderSamlrsaxmlSecurity =
  /** http://www.w3.org/2000/09/xmldsig#rsa-sha1 */
  | 'RSA_SHA1'
  /** http://www.w3.org/2001/04/xmldsig-more#rsa-sha256 */
  | 'RSA_SHA256'
  /** http://www.w3.org/2001/04/xmldsig-more#rsa-sha384 */
  | 'RSA_SHA384'
  /** http://www.w3.org/2001/04/xmldsig-more#rsa-sha512 */
  | 'RSA_SHA512';

/** Information about Buildkite as a SAML Service Provider */
export type SsoProviderSamlspType = {
  /** The IdP Issuer value for this SSO Provider */
  issuer: Maybe<Scalars['String']['output']>;
  /** The metadata used to configure this SSO provider if it was provided */
  metadata: Maybe<SsoProviderSamlMetadataType>;
  /** The IdP SSO URL for this SSO Provider */
  ssoURL: Maybe<Scalars['String']['output']>;
};

/** XML security algorithms used in the SAML exchange */
export type SsoProviderSamlxmlSecurity =
  /** http://www.w3.org/2000/09/xmldsig#sha1 */
  | 'SHA1'
  /** http://www.w3.org/2001/04/xmlenc#sha256 */
  | 'SHA256'
  /** http://www.w3.org/2001/04/xmldsig-more#sha384 */
  | 'SHA384'
  /** http://www.w3.org/2001/04/xmlenc#sha512 */
  | 'SHA512';

/** All the possible states an SSO Provider can be in */
export type SsoProviderStates =
  /** The SSO Provider has been created, but has not been enabled for use yet */
  | 'CREATED'
  /** The SSO Provider has been disabled and can't be used directly */
  | 'DISABLED'
  /** The SSO Provider has been setup correctly and can be used by users */
  | 'ENABLED';

/** All the possible SSO Provider types */
export type SsoProviderTypes =
  /** A SSO Provider configured to use a GitHub App for authorization */
  | 'GITHUB_APP'
  /** A SSO Provider configured to use Google G Suite for authorization */
  | 'GOOGLE_GSUITE'
  /** An SSO Provider configured to use SAML */
  | 'SAML';

/** Autogenerated input type of SSOProviderUpdate */
export type SsoProviderUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  digestMethod: InputMaybe<SsoProviderSamlxmlSecurity>;
  discloseGoogleHostedDomain: InputMaybe<Scalars['Boolean']['input']>;
  emailDomain: InputMaybe<Scalars['String']['input']>;
  emailDomainVerificationAddress: InputMaybe<Scalars['String']['input']>;
  githubOrganizationName: InputMaybe<Scalars['String']['input']>;
  googleHostedDomain: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  identityProvider: InputMaybe<SsoProviderSamlIdP>;
  note: InputMaybe<Scalars['String']['input']>;
  /**
   * When enabled, users will be required to re-authenticate if their IP address
   * changes. This feature is only available for some billing plans.
   */
  pinSessionToIpAddress: InputMaybe<Scalars['Boolean']['input']>;
  sessionDurationInHours: InputMaybe<Scalars['Int']['input']>;
  signatureMethod: InputMaybe<SsoProviderSamlrsaxmlSecurity>;
};

/** Autogenerated return type of SSOProviderUpdate. */
export type SsoProviderUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  ssoProvider: SsoProvider;
};

export type Step = {
  /** The conditional evaluated for this step */
  conditional: Maybe<Scalars['String']['output']>;
  /** Dependencies of this job */
  dependencies: Maybe<DependencyConnection>;
  /** The user-defined key for this step */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this step */
  uuid: Scalars['String']['output'];
};


export type StepDependenciesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** A step in a build that runs a command on an agent */
export type StepCommand = Step & {
  /** The conditional evaluated for this step */
  conditional: Maybe<Scalars['String']['output']>;
  /** Dependencies of this job */
  dependencies: Maybe<DependencyConnection>;
  /** The user-defined key for this step */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this step */
  uuid: Scalars['String']['output'];
};


/** A step in a build that runs a command on an agent */
export type StepCommandDependenciesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** An input step collects information from a user */
export type StepInput = Step & {
  /** The conditional evaluated for this step */
  conditional: Maybe<Scalars['String']['output']>;
  /** Dependencies of this job */
  dependencies: Maybe<DependencyConnection>;
  /** The user-defined key for this step */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this step */
  uuid: Scalars['String']['output'];
};


/** An input step collects information from a user */
export type StepInputDependenciesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** A trigger step creates a build on another pipeline */
export type StepTrigger = Step & {
  /** The conditional evaluated for this step */
  conditional: Maybe<Scalars['String']['output']>;
  /** Dependencies of this job */
  dependencies: Maybe<DependencyConnection>;
  /** The user-defined key for this step */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this step */
  uuid: Scalars['String']['output'];
};


/** A trigger step creates a build on another pipeline */
export type StepTriggerDependenciesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** A wait step waits for all previous steps to have successfully completed before allowing following jobs to continue */
export type StepWait = Step & {
  /** The conditional evaluated for this step */
  conditional: Maybe<Scalars['String']['output']>;
  /** Dependencies of this job */
  dependencies: Maybe<DependencyConnection>;
  /** The user-defined key for this step */
  key: Maybe<Scalars['String']['output']>;
  /** The UUID for this step */
  uuid: Scalars['String']['output'];
};


/** A wait step waits for all previous steps to have successfully completed before allowing following jobs to continue */
export type StepWaitDependenciesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

export type Subscription = {
  id: Scalars['ID']['output'];
};

/** A suite */
export type Suite = Node & {
  /** The time when the suite was created */
  createdAt: Maybe<Scalars['DateTime']['output']>;
  /** The default branch for this suite */
  defaultBranch: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The name of the suite */
  name: Scalars['String']['output'];
  organization: Organization;
  /** The slug of the suite */
  slug: Scalars['String']['output'];
  /** Teams associated with this suite */
  teams: Maybe<TeamSuiteConnection>;
  /** The URL for the suite */
  url: Scalars['String']['output'];
  uuid: Scalars['String']['output'];
};


/** A suite */
export type SuiteTeamsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamSuiteOrder>;
  search: InputMaybe<Scalars['String']['input']>;
};

/** The access levels that can be assigned to a suite */
export type SuiteAccessLevels =
  /** Allows edits and reads */
  | 'MANAGE_AND_READ'
  /** Read only */
  | 'READ_ONLY';

export type SuiteConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<SuiteEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

export type SuiteEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Suite>;
};

/** The different orders you can sort suites by */
export type SuiteOrders =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently created suites first */
  | 'RECENTLY_CREATED'
  /** Order by relevance when searching for suites */
  | 'RELEVANCE';

/** A TOTP configuration */
export type Totp = {
  id: Scalars['ID']['output'];
  /** The recovery code batch associated with this TOTP configuration */
  recoveryCodes: RecoveryCodeBatch;
  /** Whether the TOTP configuration has been verified yet */
  verified: Scalars['Boolean']['output'];
};

/** Autogenerated input type of TOTPActivate */
export type TotpActivateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** The current one-time password associated with this TOTP configuration. */
  token: Scalars['String']['input'];
};

/** Autogenerated return type of TOTPActivate. */
export type TotpActivatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  totp: Totp;
  viewer: Viewer;
};

/** Autogenerated input type of TOTPCreate */
export type TotpCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of TOTPCreate. */
export type TotpCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The URI to enter into your one-time password generator. Usually presented to the user as a QR Code */
  provisioningUri: Scalars['String']['output'];
  totp: Totp;
};

/** Autogenerated input type of TOTPDelete */
export type TotpDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TOTPDelete. */
export type TotpDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  viewer: Viewer;
};

/** Autogenerated input type of TOTPRecoveryCodesRegenerate */
export type TotpRecoveryCodesRegenerateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** The ID of the TOTP to generate the Recovery Codes for */
  totpId: Scalars['ID']['input'];
};

/** Autogenerated return type of TOTPRecoveryCodesRegenerate. */
export type TotpRecoveryCodesRegeneratePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  recoveryCodes: RecoveryCodeBatch;
  totp: Totp;
};

/** An organization team */
export type Team = Node & {
  /** The time when this team was created */
  createdAt: Scalars['DateTime']['output'];
  /** The user that created this team */
  createdBy: Maybe<User>;
  /** New organization members will be granted this role on this team */
  defaultMemberRole: TeamMemberRole;
  /** A description of the team */
  description: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Add new organization members to this team by default */
  isDefaultTeam: Scalars['Boolean']['output'];
  /** Users that are part of this team */
  members: Maybe<TeamMemberConnection>;
  /** Whether or not team members can create new pipelines in this team */
  membersCanCreatePipelines: Scalars['Boolean']['output'];
  /**
   * Whether or not team members can delete pipelines in this team
   * @deprecated This property has been removed without replacement
   */
  membersCanDeletePipelines: Scalars['Boolean']['output'];
  /** The name of the team */
  name: Scalars['String']['output'];
  /** The organization that this team is a part of */
  organization: Maybe<Organization>;
  permissions: TeamPermissions;
  /** Pipelines associated with this team */
  pipelines: Maybe<TeamPipelineConnection>;
  /** The privacy setting for this team */
  privacy: TeamPrivacy;
  /** The slug of the team */
  slug: Scalars['String']['output'];
  /** Suites associated with this team */
  suites: Maybe<TeamSuiteConnection>;
  /** The public UUID for this team */
  uuid: Scalars['ID']['output'];
};


/** An organization team */
export type TeamMembersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamMemberOrder>;
  role: InputMaybe<Array<TeamMemberRole>>;
  search: InputMaybe<Scalars['String']['input']>;
};


/** An organization team */
export type TeamPipelinesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamPipelineOrder>;
  search: InputMaybe<Scalars['String']['input']>;
};


/** An organization team */
export type TeamSuitesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<TeamSuiteOrder>;
};

export type TeamConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<TeamEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of TeamCreate */
export type TeamCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** New organization members will be granted this role on this team */
  defaultMemberRole: TeamMemberRole;
  description: InputMaybe<Scalars['String']['input']>;
  /** Add new organization members to this team by default */
  isDefaultTeam: Scalars['Boolean']['input'];
  /** If members in this team can create pipelines in it */
  membersCanCreatePipelines: InputMaybe<Scalars['Boolean']['input']>;
  /** Deprecated: If members in this team can delete pipelines assigned to it */
  membersCanDeletePipelines: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  organizationID: Scalars['ID']['input'];
  /** The privacy setting for this team */
  privacy: TeamPrivacy;
};

/** Autogenerated return type of TeamCreate. */
export type TeamCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Organization;
  teamEdge: TeamEdge;
};

/** Autogenerated input type of TeamDelete */
export type TeamDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamDelete. */
export type TeamDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTeamID: Scalars['ID']['output'];
  organization: Organization;
};

export type TeamEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<Team>;
};

/** An member of a team */
export type TeamMember = Node & {
  /** The time when the team member was added */
  createdAt: Scalars['DateTime']['output'];
  /** The user that added this team member */
  createdBy: Maybe<User>;
  id: Scalars['ID']['output'];
  /** The organization member associated with this team member */
  organizationMember: Maybe<OrganizationMember>;
  permissions: TeamMemberPermissions;
  /** The users role within the team */
  role: TeamMemberRole;
  /** The team associated with this team member */
  team: Maybe<Team>;
  /** The user associated with this team member */
  user: Maybe<User>;
  /** The public UUID for this team member */
  uuid: Scalars['ID']['output'];
};

export type TeamMemberConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<TeamMemberEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of TeamMemberCreate */
export type TeamMemberCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** If no role is specified, the team member will be assigned the team's default role. */
  role: InputMaybe<TeamMemberRole>;
  teamID: Scalars['ID']['input'];
  userID: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamMemberCreate. */
export type TeamMemberCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  team: Maybe<Team>;
  teamMemberEdge: Maybe<TeamMemberEdge>;
};

/** Autogenerated input type of TeamMemberDelete */
export type TeamMemberDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamMemberDelete. */
export type TeamMemberDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTeamMemberID: Scalars['ID']['output'];
  team: Maybe<Team>;
};

export type TeamMemberEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<TeamMember>;
};

/** The different orders you can sort team members by */
export type TeamMemberOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently added members first */
  | 'RECENTLY_CREATED'
  /** Order by most relevant results when doing a search */
  | 'RELEVANCE';

/** Permissions information about what actions the current user can do against the team membership record */
export type TeamMemberPermissions = {
  /** Whether the user can delete the user from the team */
  teamMemberDelete: Maybe<Permission>;
  /** Whether the user can update the team's members admin status */
  teamMemberUpdate: Maybe<Permission>;
};

/** The roles a user can be within a team */
export type TeamMemberRole =
  /** The user can manage pipelines and users within the team */
  | 'MAINTAINER'
  /** The user is a regular member of the team */
  | 'MEMBER';

/** Autogenerated input type of TeamMemberUpdate */
export type TeamMemberUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  role: TeamMemberRole;
};

/** Autogenerated return type of TeamMemberUpdate. */
export type TeamMemberUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  teamMember: TeamMember;
};

/** The different orders you can sort teams by */
export type TeamOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently created teams first */
  | 'RECENTLY_CREATED'
  /** Order by relevance when searching for teams */
  | 'RELEVANCE';

/** Permissions information about what actions the current user can do against the team */
export type TeamPermissions = {
  /** Whether the user can see the pipelines within the team */
  pipelineView: Maybe<Permission>;
  /** Whether the user can delete the team */
  teamDelete: Maybe<Permission>;
  /** Whether the user can administer add members from the organization to this team */
  teamMemberCreate: Maybe<Permission>;
  /** Whether the user can add pipelines from other teams to this one */
  teamPipelineCreate: Maybe<Permission>;
  /** Whether the user can add suites from other teams to this one */
  teamSuiteCreate: Maybe<Permission>;
  /** Whether the user can update the team's name and description */
  teamUpdate: Maybe<Permission>;
};

/** An pipeline that's been assigned to a team */
export type TeamPipeline = Node & {
  /** The access level users have to this pipeline */
  accessLevel: PipelineAccessLevels;
  /** The time when the pipeline was added */
  createdAt: Scalars['DateTime']['output'];
  /** The user that added this pipeline to the team */
  createdBy: Maybe<User>;
  id: Scalars['ID']['output'];
  permissions: TeamPipelinePermissions;
  /** The pipeline associated with this team member */
  pipeline: Maybe<Pipeline>;
  /** The team associated with this team member */
  team: Maybe<Team>;
  /** The public UUID for this team member */
  uuid: Scalars['ID']['output'];
};

/** A collection of TeamPipeline records */
export type TeamPipelineConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<TeamPipelineEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of TeamPipelineCreate */
export type TeamPipelineCreateInput = {
  accessLevel: InputMaybe<PipelineAccessLevels>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  pipelineID: Scalars['ID']['input'];
  teamID: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamPipelineCreate. */
export type TeamPipelineCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  pipeline: Maybe<Pipeline>;
  team: Maybe<Team>;
  teamPipeline: Maybe<TeamPipeline>;
  teamPipelineEdge: Maybe<TeamPipelineEdge>;
};

/** Autogenerated input type of TeamPipelineDelete */
export type TeamPipelineDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  force: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamPipelineDelete. */
export type TeamPipelineDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTeamPipelineID: Scalars['ID']['output'];
  team: Maybe<Team>;
};

export type TeamPipelineEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<TeamPipeline>;
};

/** The different orders you can sort pipelines by */
export type TeamPipelineOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently added pipelines first */
  | 'RECENTLY_CREATED'
  /** Order by most relevant results when doing a search */
  | 'RELEVANCE';

/** Permission information about what actions the current user can do against the team pipelines */
export type TeamPipelinePermissions = {
  /** Whether the user can delete the pipeline from the team */
  teamPipelineDelete: Maybe<Permission>;
  /** Whether the user can update the pipeline connection to the team */
  teamPipelineUpdate: Maybe<Permission>;
};

/** Autogenerated input type of TeamPipelineUpdate */
export type TeamPipelineUpdateInput = {
  accessLevel: PipelineAccessLevels;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamPipelineUpdate. */
export type TeamPipelineUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  teamPipeline: TeamPipeline;
};

/** Whether a team is visible or secret within an organization */
export type TeamPrivacy =
  /** Visible to organization administrators and members */
  | 'SECRET'
  /** Visible to all members of the organization */
  | 'VISIBLE';

/** A suite that's been assigned to a team */
export type TeamSuite = Node & {
  /** The access level users have to this suite */
  accessLevel: SuiteAccessLevels;
  /** The time when the suite was added */
  createdAt: Scalars['DateTime']['output'];
  /** The user that added this suite to the team */
  createdBy: Maybe<User>;
  id: Scalars['ID']['output'];
  permissions: TeamSuitePermissions;
  /** The suite associated with this team member */
  suite: Maybe<Suite>;
  /** The team associated with this team member */
  team: Maybe<Team>;
  /** The public UUID for this team suite */
  uuid: Scalars['String']['output'];
};

/** A collection of TeamSuite records */
export type TeamSuiteConnection = Connection & {
  count: Scalars['Int']['output'];
  edges: Maybe<Array<Maybe<TeamSuiteEdge>>>;
  pageInfo: Maybe<PageInfo>;
};

/** Autogenerated input type of TeamSuiteCreate */
export type TeamSuiteCreateInput = {
  accessLevel: InputMaybe<SuiteAccessLevels>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  suiteID: Scalars['ID']['input'];
  teamID: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamSuiteCreate. */
export type TeamSuiteCreatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  suite: Maybe<Suite>;
  team: Maybe<Team>;
  teamSuite: Maybe<TeamSuite>;
  teamSuiteEdge: Maybe<TeamSuiteEdge>;
};

/** Autogenerated input type of TeamSuiteDelete */
export type TeamSuiteDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  force: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamSuiteDelete. */
export type TeamSuiteDeletePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTeamSuiteID: Scalars['ID']['output'];
  team: Maybe<Team>;
};

export type TeamSuiteEdge = {
  cursor: Scalars['String']['output'];
  node: Maybe<TeamSuite>;
};

/** The different orders you can sort suites by */
export type TeamSuiteOrder =
  /** Order by name alphabetically */
  | 'NAME'
  /** Order by the most recently added suites first */
  | 'RECENTLY_CREATED'
  /** Order by most relevant results when doing a search */
  | 'RELEVANCE';

/** Permission information about what actions the current user can do against the team suites */
export type TeamSuitePermissions = {
  /** Whether the user can delete the suite from the team */
  teamSuiteDelete: Maybe<Permission>;
  /** Whether the user can update the suite connection to the team */
  teamSuiteUpdate: Maybe<Permission>;
};

/** Autogenerated input type of TeamSuiteUpdate */
export type TeamSuiteUpdateInput = {
  accessLevel: SuiteAccessLevels;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of TeamSuiteUpdate. */
export type TeamSuiteUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  teamSuite: TeamSuite;
};

/** Autogenerated input type of TeamUpdate */
export type TeamUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  /** New organization members will be granted this role on this team */
  defaultMemberRole: TeamMemberRole;
  description: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  /** Add new organization members to this team by default */
  isDefaultTeam: Scalars['Boolean']['input'];
  /** If members in this team can create pipelines in it */
  membersCanCreatePipelines: InputMaybe<Scalars['Boolean']['input']>;
  /** Deprecated: If members in this team can delete pipelines assigned to it */
  membersCanDeletePipelines: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  /** The privacy setting for this team */
  privacy: InputMaybe<TeamPrivacy>;
};

/** Autogenerated return type of TeamUpdate. */
export type TeamUpdatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  team: Team;
};

/** A record of test executions usage, aggregated by day and test suite. */
export type TestExecutionsUsage = ResourceUsageInterface & {
  aggregatedOn: Scalars['ISO8601Date']['output'];
  /** The recorded usage. */
  executions: Scalars['Int']['output'];
  suite: Maybe<Suite>;
  suiteId: Scalars['ID']['output'];
};

/** A person who hasn’t signed up to Buildkite */
export type UnregisteredUser = {
  avatar: Avatar;
  /** The email for the user */
  email: Maybe<Scalars['String']['output']>;
  /** The name of the user */
  name: Maybe<Scalars['String']['output']>;
};

/** The possible resource usage types */
export type UsageUnion = JobMinutesUsage | TestExecutionsUsage;

/** The connection type for UsageUnion. */
export type UsageUnionConnection = {
  /** A list of edges. */
  edges: Maybe<Array<Maybe<UsageUnionEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<UsageUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UsageUnionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<UsageUnion>;
};

/** A user */
export type User = Node & {
  avatar: Avatar;
  /** If this user account is an official bot managed by Buildkite */
  bot: Scalars['Boolean']['output'];
  /** Returns builds that this user has created. */
  builds: Maybe<BuildConnection>;
  /** The primary email for the user */
  email: Scalars['String']['output'];
  /** Does the user have a password set */
  hasPassword: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The name of the user */
  name: Scalars['String']['output'];
  /** The public UUID of the user */
  uuid: Scalars['String']['output'];
};


/** A user */
export type UserBuildsArgs = {
  branch: InputMaybe<Array<Scalars['String']['input']>>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  metaData: InputMaybe<Array<Scalars['String']['input']>>;
  state: InputMaybe<Array<BuildStates>>;
};

/** Represents the current user session */
export type Viewer = Node & {
  authorizations: Maybe<AuthorizationConnection>;
  builds: Maybe<BuildConnection>;
  changelogs: Maybe<ChangelogConnection>;
  /** Emails associated with the current user */
  emails: Maybe<EmailConnection>;
  /** The ID of the current user */
  id: Scalars['ID']['output'];
  jobs: Maybe<JobConnection>;
  notice: Maybe<Notice>;
  organizations: Maybe<OrganizationConnection>;
  /** The current user's permissions */
  permissions: ViewerPermissions;
  /**
   * The user's active TOTP configuration, if any.
   *
   * This field is private, requires an escalated session, and cannot be accessed via the public GraphQL API.
   */
  totp: Maybe<Totp>;
  /** The current user */
  user: Maybe<User>;
};


/** Represents the current user session */
export type ViewerAuthorizationsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  type: InputMaybe<Array<AuthorizationType>>;
};


/** Represents the current user session */
export type ViewerBuildsArgs = {
  branch: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  metaData: InputMaybe<Array<Scalars['String']['input']>>;
  state: InputMaybe<Array<BuildStates>>;
};


/** Represents the current user session */
export type ViewerChangelogsArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  read: InputMaybe<Scalars['Boolean']['input']>;
};


/** Represents the current user session */
export type ViewerEmailsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  verified: InputMaybe<Scalars['Boolean']['input']>;
};


/** Represents the current user session */
export type ViewerJobsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  agentQueryRules: InputMaybe<Array<Scalars['String']['input']>>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<JobOrder>;
  priority: InputMaybe<JobPrioritySearch>;
  state: InputMaybe<Array<JobStates>>;
  type: InputMaybe<Array<JobTypes>>;
};


/** Represents the current user session */
export type ViewerNoticeArgs = {
  namespace: NoticeNamespaces;
  scope: Scalars['String']['input'];
};


/** Represents the current user session */
export type ViewerOrganizationsArgs = {
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** Represents the current user session */
export type ViewerTotpArgs = {
  id: InputMaybe<Scalars['ID']['input']>;
};

/** Permissions information about what actions the current user can do */
export type ViewerPermissions = {
  /** Whether the viewer can configure two-factor authentication */
  totpConfigure: Permission;
};

export type BuildFragment = { id: string, branch: string, createdAt: any | null, message: string | null, number: number, state: BuildStates, url: string, pipeline: { name: string } };

export type MyBuildsQueryVariables = Exact<{ [key: string]: never; }>;


export type MyBuildsQuery = { viewer: { user: { builds: { edges: Array<{ node: { id: string, branch: string, createdAt: any | null, message: string | null, number: number, state: BuildStates, url: string, pipeline: { name: string } } | null } | null> | null } | null } | null } | null };

export type ListBuildsQueryVariables = Exact<{
  pipeline: Scalars['ID']['input'];
}>;


export type ListBuildsQuery = { pipeline: { builds: { edges: Array<{ node: { id: string, branch: string, createdAt: any | null, message: string | null, number: number, state: BuildStates, url: string, pipeline: { name: string } } | null } | null> | null } | null } | null };

export type PipelineFragment = { slug: string, name: string, description: string | null, favorite: boolean, url: string, builds: { edges: Array<{ node: { state: BuildStates } | null } | null> | null } | null };

export type SearchPipelinesQueryVariables = Exact<{
  org: Scalars['ID']['input'];
  search: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchPipelinesQuery = { organization: { pipelines: { edges: Array<{ node: { slug: string, name: string, description: string | null, favorite: boolean, url: string, builds: { edges: Array<{ node: { state: BuildStates } | null } | null> | null } | null } | null } | null> | null } | null } | null };

export const BuildFragmentDoc = gql`
    fragment Build on Build {
  id
  branch
  createdAt
  message
  number
  state
  url
  pipeline {
    name
  }
}
    `;
export const PipelineFragmentDoc = gql`
    fragment Pipeline on Pipeline {
  slug
  name
  description
  favorite
  url
  builds(first: 1) {
    edges {
      node {
        state
      }
    }
  }
}
    `;
export const MyBuildsDocument = gql`
    query myBuilds {
  viewer {
    user {
      builds(first: 20) {
        edges {
          node {
            ...Build
          }
        }
      }
    }
  }
}
    ${BuildFragmentDoc}`;
export const ListBuildsDocument = gql`
    query listBuilds($pipeline: ID!) {
  pipeline(slug: $pipeline) {
    builds(first: 20) {
      edges {
        node {
          ...Build
        }
      }
    }
  }
}
    ${BuildFragmentDoc}`;
export const SearchPipelinesDocument = gql`
    query searchPipelines($org: ID!, $search: String) {
  organization(slug: $org) {
    pipelines(
      first: 20
      archived: false
      order: NAME_WITH_FAVORITES_FIRST
      search: $search
    ) {
      edges {
        node {
          ...Pipeline
        }
      }
    }
  }
}
    ${PipelineFragmentDoc}`;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    myBuilds(variables?: MyBuildsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MyBuildsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MyBuildsQuery>(MyBuildsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'myBuilds', 'query');
    },
    listBuilds(variables: ListBuildsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ListBuildsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ListBuildsQuery>(ListBuildsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'listBuilds', 'query');
    },
    searchPipelines(variables: SearchPipelinesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SearchPipelinesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<SearchPipelinesQuery>(SearchPipelinesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'searchPipelines', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;