import type { ModuleDoc } from "../types";

export const Kernel_SpecialForms: ModuleDoc = {
  functions: [],
  name: "Kernel.SpecialForms",
  callbacks: [],
  macros: [
    {
      name: "{}/1",
      type: "macro",
      specs: [],
      documentation:
        "Creates a tuple.\n\nMore information about the tuple data type and about functions to manipulate\ntuples can be found in the `Tuple` module; some functions for working with\ntuples are also available in `Kernel` (such as `Kernel.elem/2` or\n`Kernel.tuple_size/1`).\n\n## AST representation\n\nOnly two-element tuples are considered literals in Elixir and return themselves\nwhen quoted. Therefore, all other tuples are represented in the AST as calls to\nthe `:{}` special form.\n\n    iex> quote do\n    ...>   {1, 2}\n    ...> end\n    {1, 2}\n\n    iex> quote do\n    ...>   {1, 2, 3}\n    ...> end\n    {:{}, [], [1, 2, 3]}\n\n",
    },
    {
      name: "with/1",
      type: "macro",
      specs: [],
      documentation:
        'Combine matching clauses.\n\nOne of the ways to understand with is to show which code\npatterns it improves. Imagine you have a map where the fields\n`width` and `height` are optional and you want to compute its\narea, as `{:ok, area}` or return `:error`. We could implement\nthis function as:\n\n    def area(opts) do\n      case Map.fetch(opts, :width) do\n        {:ok, width} ->\n          case Map.fetch(opts, :height) do\n            {:ok, height} -> {:ok, width * height}\n            :error -> :error\n          end\n\n        :error ->\n          :error\n      end\n    end\n\nwhen called as `area(%{width: 10, height: 15})`, it should return\n`{:ok, 150}`. If any of the fields are missing, it returns `:error`.\n\nWhile the code above works, it is quite verbose. Using `with`,\nwe could rewrite it as:\n\n    def area(opts) do\n      with {:ok, width} <- Map.fetch(opts, :width),\n           {:ok, height} <- Map.fetch(opts, :height) do\n        {:ok, width * height}\n      end\n    end\n\nInstead of defining nested `case`s with clauses, we use `with`\nalongside the `PATTERN <- EXPRESSION` operator to match\nexpressions on its right side against the pattern on the left.\nConsider `<-` as a sibling to `=`, except that, while `=` raises\nin case of not matches, `<-` will simply abort the `with` chain\nand return the non-matched value.\n\nLet\'s give it a try on IEx:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nIf all clauses match, the `do` block is executed, returning its result.\nOtherwise the chain is aborted and the non-matched value is returned:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    :error\n\nGuards can be used in patterns as well:\n\n    iex> users = %{"melany" => "guest", "bob" => :admin}\n    iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, "bob") do\n    ...>   {:ok, to_string(role)}\n    ...> end\n    {:ok, "admin"}\n\nAs in `for/1`, variables bound inside `with/1` won\'t be accessible\noutside of `with/1`.\n\nExpressions without `<-` may also be used in clauses. For instance,\nyou can perform regular matches with the `=` operator:\n\n    iex> width = nil\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      double_width = width * 2,\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, double_width * height}\n    ...> end\n    {:ok, 300}\n    iex> width\n    nil\n\nThe behavior of any expression in a clause is the same as if it was\nwritten outside of `with`. For example, `=` will raise a `MatchError`\ninstead of returning the non-matched value:\n\n    with :foo = :bar, do: :ok\n    ** (MatchError) no match of right hand side value: :bar\n\nAs with any other function or macro call in Elixir, explicit parens can\nalso be used around the arguments before the `do`-`end` block:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with(\n    ...>   {:ok, width} <- Map.fetch(opts, :width),\n    ...>   {:ok, height} <- Map.fetch(opts, :height)\n    ...> ) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nThe choice between parens and no parens is a matter of preference.\n\n## Else clauses\n\nAn `else` option can be given to modify what is being returned from\n`with` in the case of a failed match:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> else\n    ...>   :error ->\n    ...>     {:error, :wrong_data}\n    ...>\n    ...>   _other_error ->\n    ...>     :unexpected_error\n    ...> end\n    {:error, :wrong_data}\n\nThe `else` block works like a `case` clause: it can have multiple clauses,\nand the first match will be used. Variables bound inside `with` (such as\n`width` in this example) are not available in the `else` block.\n\nIf an `else` block is used and there are no matching clauses, a `WithClauseError`\nexception is raised.\n\n### Beware!\n\nKeep in mind that, one of potential drawback of `with` is that all\nfailure clauses are flattened into a single `else` block. For example,\ntake this code that checks if a given path points to an Elixir file\nand that it exists before creating a backup copy:\n\n    with ".ex" <- Path.extname(path),\n         true <- File.exists?(path) do\n      backup_path = path <> ".backup"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    else\n      binary when is_binary(binary) ->\n        {:error, :invalid_extension}\n\n      false ->\n        {:error, :missing_file}\n    end\n\nNote how we are having to reconstruct the result types of `Path.extname/1`\nand `File.exists?/1` to build error messages. In this case, it is better\nto refactor the code so each `<-` already return the desired format in case\nof errors, like this:\n\n    with :ok <- validate_extension(path),\n         :ok <- validate_exists(path) do\n      backup_path = path <> ".backup"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    end\n\n    defp validate_extension(path) do\n      if Path.extname(path) == ".ex", do: :ok, else: {:error, :invalid_extension}\n    end\n\n    defp validate_exists(path) do\n      if File.exists?(path), do: :ok, else: {:error, :missing_file}\n    end\n\nNote how the code above is better organized and clearer once we\nmake sure each `<-` in `with` returns a normalized format.\n',
    },
    {
      name: "unquote_splicing/1",
      type: "macro",
      specs: [],
      documentation:
        "Unquotes the given list expanding its arguments.\n\nSimilar to `unquote/1`.\n\n## Examples\n\n    iex> values = [2, 3, 4]\n    iex> quote do\n    ...>   sum(1, unquote_splicing(values), 5)\n    ...> end\n    {:sum, [], [1, 2, 3, 4, 5]}\n\n",
    },
    {
      name: "unquote/1",
      type: "macro",
      specs: [],
      documentation:
        "Unquotes the given expression inside a quoted expression.\n\nThis function expects a valid Elixir AST, also known as\nquoted expression, as argument. If you would like to `unquote`\nany value, such as a map or a four-element tuple, you should\ncall `Macro.escape/1` before unquoting.\n\n## Examples\n\nImagine the situation you have a quoted expression and\nyou want to inject it inside some quote. The first attempt\nwould be:\n\n    value =\n      quote do\n        13\n      end\n\n    quote do\n      sum(1, value, 3)\n    end\n\n\nWhich the argument for the `:sum` function call is not the\nexpected result:\n\n    {:sum, [], [1, {:value, [], Elixir}, 3]}\n\nFor this, we use `unquote`:\n\n    iex> value =\n    ...>   quote do\n    ...>     13\n    ...>   end\n    iex> quote do\n    ...>   sum(1, unquote(value), 3)\n    ...> end\n    {:sum, [], [1, 13, 3]}\n\nIf you want to unquote a value that is not a quoted expression,\nsuch as a map, you need to call `Macro.escape/1` before:\n\n    iex> value = %{foo: :bar}\n    iex> quote do\n    ...>   process_map(unquote(Macro.escape(value)))\n    ...> end\n    {:process_map, [], [{:%{}, [], [foo: :bar]}]}\n\nIf you forget to escape it, Elixir will raise an error\nwhen compiling the code.\n",
    },
    {
      name: "try/1",
      type: "macro",
      specs: [],
      documentation:
        'Evaluates the given expressions and handles any error, exit,\nor throw that may have happened.\n\n## Examples\n\n    try do\n      do_something_that_may_fail(some_arg)\n    rescue\n      ArgumentError ->\n        IO.puts("Invalid argument given")\n    catch\n      value ->\n        IO.puts("Caught #{inspect(value)}")\n    else\n      value ->\n        IO.puts("Success! The result was #{inspect(value)}")\n    after\n      IO.puts("This is printed regardless if it failed or succeeded")\n    end\n\nThe `rescue` clause is used to handle exceptions while the `catch`\nclause can be used to catch thrown values and exits.\nThe `else` clause can be used to control flow based on the result of\nthe expression. `catch`, `rescue`, and `else` clauses work based on\npattern matching (similar to the `case` special form).\n\nCalls inside `try/1` are not tail recursive since the VM needs to keep\nthe stacktrace in case an exception happens. To retrieve the stacktrace,\naccess `__STACKTRACE__/0` inside the `rescue` or `catch` clause.\n\n## `rescue` clauses\n\nBesides relying on pattern matching, `rescue` clauses provide some\nconveniences around exceptions that allow one to rescue an\nexception by its name. All the following formats are valid patterns\nin `rescue` clauses:\n\n    # Rescue a single exception without binding the exception\n    # to a variable\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      UndefinedFunctionError -> nil\n    end\n\n    # Rescue any of the given exception without binding\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      [UndefinedFunctionError, ArgumentError] -> nil\n    end\n\n    # Rescue and bind the exception to the variable "x"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x in [UndefinedFunctionError] -> nil\n    end\n\n    # Rescue all kinds of exceptions and bind the rescued exception\n    # to the variable "x"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x -> nil\n    end\n\n### Erlang errors\n\nErlang errors are transformed into Elixir ones when rescuing:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ArgumentError -> :ok\n    end\n    #=> :ok\n\nThe most common Erlang errors will be transformed into their\nElixir counterpart. Those which are not will be transformed\ninto the more generic `ErlangError`:\n\n    try do\n      :erlang.error(:unknown)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\nIn fact, `ErlangError` can be used to rescue any error that is\nnot a proper Elixir error. For example, it can be used to rescue\nthe earlier `:badarg` error too, prior to transformation:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\n## `catch` clauses\n\nThe `catch` clause can be used to catch thrown values, exits, and errors.\n\n### Catching thrown values\n\n`catch` can be used to catch values thrown by `Kernel.throw/1`:\n\n    try do\n      throw(:some_value)\n    catch\n      thrown_value ->\n        IO.puts("A value was thrown: #{inspect(thrown_value)}")\n    end\n\n### Catching values of any kind\n\nThe `catch` clause also supports catching exits and errors. To do that, it\nallows matching on both the *kind* of the caught value as well as the value\nitself:\n\n    try do\n      exit(:shutdown)\n    catch\n      :exit, value ->\n        IO.puts("Exited with value #{inspect(value)}")\n    end\n\n    try do\n      exit(:shutdown)\n    catch\n      kind, value when kind in [:exit, :throw] ->\n        IO.puts("Caught exit or throw with value #{inspect(value)}")\n    end\n\nThe `catch` clause also supports `:error` alongside `:exit` and `:throw` as\nin Erlang, although this is commonly avoided in favor of `raise`/`rescue` control\nmechanisms. One reason for this is that when catching `:error`, the error is\nnot automatically transformed into an Elixir error:\n\n    try do\n      :erlang.error(:badarg)\n    catch\n      :error, :badarg -> :ok\n    end\n    #=> :ok\n\n## `after` clauses\n\nAn `after` clause allows you to define cleanup logic that will be invoked both\nwhen the block of code passed to `try/1` succeeds and also when an error is raised. Note\nthat the process will exit as usual when receiving an exit signal that causes\nit to exit abruptly and so the `after` clause is not guaranteed to be executed.\nLuckily, most resources in Elixir (such as open files, ETS tables, ports, sockets,\nand so on) are linked to or monitor the owning process and will automatically clean\nthemselves up if that process exits.\n\n    File.write!("tmp/story.txt", "Hello, World")\n    try do\n      do_something_with("tmp/story.txt")\n    after\n      File.rm("tmp/story.txt")\n    end\n\nAlthough `after` clauses are invoked whether or not there was an error, they do not\nmodify the return value. All of the following examples return `:return_me`:\n\n    try do\n      :return_me\n    after\n      IO.puts("I will be printed")\n      :not_returned\n    end\n\n    try do\n      raise "boom"\n    rescue\n      _ -> :return_me\n    after\n      IO.puts("I will be printed")\n      :not_returned\n    end\n\n## `else` clauses\n\n`else` clauses allow the result of the body passed to `try/1` to be pattern\nmatched on:\n\n    x = 2\n    try do\n      1 / x\n    rescue\n      ArithmeticError ->\n        :infinity\n    else\n      y when y < 1 and y > -1 ->\n        :small\n      _ ->\n        :large\n    end\n\nIf an `else` clause is not present and no exceptions are raised,\nthe result of the expression will be returned:\n\n    x = 1\n    ^x =\n      try do\n        1 / x\n      rescue\n        ArithmeticError ->\n          :infinity\n      end\n\nHowever, when an `else` clause is present but the result of the expression\ndoes not match any of the patterns then an exception will be raised. This\nexception will not be caught by a `catch` or `rescue` in the same `try`:\n\n    x = 1\n    try do\n      try do\n        1 / x\n      rescue\n        # The TryClauseError cannot be rescued here:\n        TryClauseError ->\n          :error_a\n      else\n        0 ->\n          :small\n      end\n    rescue\n      # The TryClauseError is rescued here:\n      TryClauseError ->\n        :error_b\n    end\n\nSimilarly, an exception inside an `else` clause is not caught or rescued\ninside the same `try`:\n\n    try do\n      try do\n        nil\n      catch\n        # The exit(1) call below can not be caught here:\n        :exit, _ ->\n          :exit_a\n      else\n        _ ->\n          exit(1)\n      end\n    catch\n      # The exit is caught here:\n      :exit, _ ->\n        :exit_b\n    end\n\nThis means the VM no longer needs to keep the stacktrace once inside\nan `else` clause and so tail recursion is possible when using a `try`\nwith a tail call as the final call inside an `else` clause. The same\nis true for `rescue` and `catch` clauses.\n\nOnly the result of the tried expression falls down to the `else` clause.\nIf the `try` ends up in the `rescue` or `catch` clauses, their result\nwill not fall down to `else`:\n\n    try do\n      throw(:catch_this)\n    catch\n      :throw, :catch_this ->\n        :it_was_caught\n    else\n      # :it_was_caught will not fall down to this "else" clause.\n      other ->\n        {:else, other}\n    end\n\n## Variable handling\n\nSince an expression inside `try` may not have been evaluated\ndue to an exception, any variable created inside `try` cannot\nbe accessed externally. For instance:\n\n    try do\n      x = 1\n      do_something_that_may_fail(same_arg)\n      :ok\n    catch\n      _, _ -> :failed\n    end\n\n    x\n    #=> unbound variable "x"\n\nIn the example above, `x` cannot be accessed since it was defined\ninside the `try` clause. A common practice to address this issue\nis to return the variables defined inside `try`:\n\n    x =\n      try do\n        x = 1\n        do_something_that_may_fail(same_arg)\n        x\n      catch\n        _, _ -> :failed\n      end\n\n',
    },
    {
      name: "super/1",
      type: "macro",
      specs: [],
      documentation:
        "Calls the overridden function when overriding it with `Kernel.defoverridable/1`.\n\nSee `Kernel.defoverridable/1` for more information and documentation.\n",
    },
    {
      name: "require/2",
      type: "macro",
      specs: [],
      documentation:
        "Requires a module in order to use its macros.\n\n## Examples\n\nPublic functions in modules are globally available, but in order to use\nmacros, you need to opt-in by requiring the module they are defined in.\n\nLet's suppose you created your own `if/2` implementation in the module\n`MyMacros`. If you want to invoke it, you need to first explicitly\nrequire the `MyMacros`:\n\n    defmodule Math do\n      require MyMacros\n      MyMacros.if do_something, it_works\n    end\n\nAn attempt to call a macro that was not loaded will raise an error.\n\n## Alias shortcut\n\n`require/2` also accepts `:as` as an option so it automatically sets\nup an alias. Please check `alias/2` for more information.\n\n",
    },
    {
      name: "receive/1",
      type: "macro",
      specs: [],
      documentation:
        'Checks if there is a message matching any of the given clauses in the current\nprocess mailbox.\n\nIf there is no matching message, the current process waits until a matching\nmessage arrives or until after a given timeout value.\n\nAny new and existing messages that do not match will remain in the mailbox.\n\n## Examples\n\n    receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, "Unexpected message received")\n    end\n\nAn optional `after` clause can be given in case no matching message is\nreceived during the given timeout period, specified in milliseconds:\n\n    receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, "Unexpected message received")\n    after\n      5000 ->\n        IO.puts(:stderr, "No message in 5 seconds")\n    end\n\nThe `after` clause can be specified even if there are no match clauses.\nThe timeout value given to `after` can be any expression evaluating to\none of the allowed values:\n\n  * `:infinity` - the process should wait indefinitely for a matching\n    message, this is the same as not using the after clause\n\n  * `0` - if there is no matching message in the mailbox, the timeout\n    will occur immediately\n\n  * positive integer smaller than or equal to `4_294_967_295` (`0xFFFFFFFF`\n    in hexadecimal notation) - it should be possible to represent the timeout\n    value as an unsigned 32-bit integer.\n\n## Variable handling\n\nThe `receive/1` special form handles variables exactly as the `case/2`\nspecial macro. For more information, check the docs for `case/2`.\n',
    },
    {
      name: "quote/2",
      type: "macro",
      specs: [],
      documentation:
        'Gets the representation of any expression.\n\n## Examples\n\n    iex> quote do\n    ...>   sum(1, 2, 3)\n    ...> end\n    {:sum, [], [1, 2, 3]}\n\n## Elixir\'s AST (Abstract Syntax Tree)\n\nAny Elixir code can be represented using Elixir data structures.\nThe building block of Elixir macros is a tuple with three elements,\nfor example:\n\n    {:sum, [], [1, 2, 3]}\n\nThe tuple above represents a function call to `sum` passing 1, 2 and\n3 as arguments. The tuple elements are:\n\n  * The first element of the tuple is always an atom or\n    another tuple in the same representation.\n\n  * The second element of the tuple represents [metadata](`t:Macro.metadata/0`).\n\n  * The third element of the tuple are the arguments for the\n    function call. The third argument may be an atom, which is\n    usually a variable (or a local call).\n\nBesides the tuple described above, Elixir has a few literals that\nare also part of its AST. Those literals return themselves when\nquoted. They are:\n\n    :sum         #=> Atoms\n    1            #=> Integers\n    2.0          #=> Floats\n    [1, 2]       #=> Lists\n    "strings"    #=> Strings\n    {key, value} #=> Tuples with two elements\n\nAny other value, such as a map or a four-element tuple, must be escaped\n(`Macro.escape/1`) before being introduced into an AST.\n\n## Options\n\n  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n    given, `unquote/1` is automatically disabled.\n\n  * `:context` - sets the resolution context.\n\n  * `:generated` - marks the given chunk as generated so it does not emit warnings.\n    It is also useful to avoid dialyzer reporting errors when macros generate\n    unused clauses.\n\n  * `:file` - sets the quoted expressions to have the given file.\n\n  * `:line` - sets the quoted expressions to have the given line.\n\n  * `:location` - when set to `:keep`, keeps the current line and file from\n    quote. Read the "Stacktrace information" section below for more information.\n\n  * `:unquote` - when `false`, disables unquoting. This means any `unquote`\n    call will be kept as is in the AST, instead of replaced by the `unquote`\n    arguments. For example:\n\n        iex> quote do\n        ...>   unquote("hello")\n        ...> end\n        "hello"\n\n        iex> quote unquote: false do\n        ...>   unquote("hello")\n        ...> end\n        {:unquote, [], ["hello"]}\n\n## Quote and macros\n\n`quote/2` is commonly used with macros for code generation. As an exercise,\nlet\'s define a macro that multiplies a number by itself (squared). In practice,\nthere is no reason to define such a macro (and it would actually be\nseen as a bad practice), but it is simple enough that it allows us to focus\non the important aspects of quotes and macros:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          unquote(x) * unquote(x)\n        end\n      end\n    end\n\nWe can invoke it as:\n\n    import Math\n    IO.puts("Got #{squared(5)}")\n\nAt first, there is nothing in this example that actually reveals it is a\nmacro. But what is happening is that, at compilation time, `squared(5)`\nbecomes `5 * 5`. The argument `5` is duplicated in the produced code, we\ncan see this behavior in practice though because our macro actually has\na bug:\n\n    import Math\n    my_number = fn ->\n      IO.puts("Returning 5")\n      5\n    end\n    IO.puts("Got #{squared(my_number.())}")\n\nThe example above will print:\n\n    Returning 5\n    Returning 5\n    Got 25\n\nNotice how "Returning 5" was printed twice, instead of just once. This is\nbecause a macro receives an expression and not a value (which is what we\nwould expect in a regular function). This means that:\n\n    squared(my_number.())\n\nActually expands to:\n\n    my_number.() * my_number.()\n\nWhich invokes the function twice, explaining why we get the printed value\ntwice! In the majority of the cases, this is actually unexpected behavior,\nand that\'s why one of the first things you need to keep in mind when it\ncomes to macros is to **not unquote the same value more than once**.\n\nLet\'s fix our macro:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          x = unquote(x)\n          x * x\n        end\n      end\n    end\n\nNow invoking `squared(my_number.())` as before will print the value just\nonce.\n\nIn fact, this pattern is so common that most of the times you will want\nto use the `bind_quoted` option with `quote/2`:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote bind_quoted: [x: x] do\n          x * x\n        end\n      end\n    end\n\n`:bind_quoted` will translate to the same code as the example above.\n`:bind_quoted` can be used in many cases and is seen as good practice,\nnot only because it helps prevent us from running into common mistakes, but also\nbecause it allows us to leverage other tools exposed by macros, such as\nunquote fragments discussed in some sections below.\n\nBefore we finish this brief introduction, you will notice that, even though\nwe defined a variable `x` inside our quote:\n\n    quote do\n      x = unquote(x)\n      x * x\n    end\n\nWhen we call:\n\n    import Math\n    squared(5)\n    x\n    ** (CompileError) undefined variable "x"\n\nWe can see that `x` did not leak to the user context. This happens\nbecause Elixir macros are hygienic, a topic we will discuss at length\nin the next sections as well.\n\n## Hygiene in variables\n\nConsider the following example:\n\n    defmodule Hygiene do\n      defmacro no_interference do\n        quote do\n          a = 1\n        end\n      end\n    end\n\n    require Hygiene\n\n    a = 10\n    Hygiene.no_interference()\n    a\n    #=> 10\n\nIn the example above, `a` returns 10 even if the macro\nis apparently setting it to 1 because variables defined\nin the macro do not affect the context the macro is executed in.\nIf you want to set or get a variable in the caller\'s context, you\ncan do it with the help of the `var!` macro:\n\n    defmodule NoHygiene do\n      defmacro interference do\n        quote do\n          var!(a) = 1\n        end\n      end\n    end\n\n    require NoHygiene\n\n    a = 10\n    NoHygiene.interference()\n    a\n    #=> 1\n\nYou cannot even access variables defined in the same module unless\nyou explicitly give it a context:\n\n    defmodule Hygiene do\n      defmacro write do\n        quote do\n          a = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          a\n        end\n      end\n    end\n\n    require Hygiene\n    Hygiene.write()\n    Hygiene.read()\n    ** (CompileError) undefined variable "a" (context Hygiene)\n\nFor such, you can explicitly pass the current module scope as\nargument:\n\n    defmodule ContextHygiene do\n      defmacro write do\n        quote do\n          var!(a, ContextHygiene) = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          var!(a, ContextHygiene)\n        end\n      end\n    end\n\n    require Hygiene\n    ContextHygiene.write()\n    ContextHygiene.read()\n    #=> 1\n\nThe contexts of a variable is identified by the third element of the tuple.\nThe default context is `nil` and `quote` assigns another context to all\nvariables within:\n\n    quote(do: var)\n    #=> {:var, [], Elixir}\n\nIn case of variables returned by macros, there may also be a `:counter` key\nin the metadata, which is used to further refine its contexts and guarantee\nisolation between macro invocations as seen in the previous example.\n\n## Hygiene in aliases\n\nAliases inside quote are hygienic by default.\nConsider the following example:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    Hygiene.no_interference()\n    #=> %{}\n\nNote that, even though the alias `M` is not available\nin the context the macro is expanded, the code above works\nbecause `M` still expands to `Map`.\n\nSimilarly, even if we defined an alias with the same name\nbefore invoking a macro, it won\'t affect the macro\'s result:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    alias SomethingElse, as: M\n    Hygiene.no_interference()\n    #=> %{}\n\nIn some cases, you want to access an alias or a module defined\nin the caller. For such, you can use the `alias!` macro:\n\n    defmodule Hygiene do\n      # This will expand to Elixir.Nested.hello()\n      defmacro no_interference do\n        quote do\n          Nested.hello()\n        end\n      end\n\n      # This will expand to Nested.hello() for\n      # whatever is Nested in the caller\n      defmacro interference do\n        quote do\n          alias!(Nested).hello()\n        end\n      end\n    end\n\n    defmodule Parent do\n      defmodule Nested do\n        def hello, do: "world"\n      end\n\n      require Hygiene\n      Hygiene.no_interference()\n      ** (UndefinedFunctionError) ...\n\n      Hygiene.interference()\n      #=> "world"\n    end\n\n## Hygiene in imports\n\nSimilar to aliases, imports in Elixir are hygienic. Consider the\nfollowing code:\n\n    defmodule Hygiene do\n      defmacrop get_length do\n        quote do\n          length([1, 2, 3])\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        get_length\n      end\n    end\n\n    Hygiene.return_length()\n    #=> 3\n\nNotice how `Hygiene.return_length/0` returns `3` even though the `Kernel.length/1`\nfunction is not imported. In fact, even if `return_length/0`\nimported a function with the same name and arity from another\nmodule, it wouldn\'t affect the function result:\n\n    def return_length do\n      import String, only: [length: 1]\n      get_length\n    end\n\nCalling this new `return_length/0` will still return `3` as result.\n\nElixir is smart enough to delay the resolution to the latest\npossible moment. So, if you call `length([1, 2, 3])` inside quote,\nbut no `length/1` function is available, it is then expanded in\nthe caller:\n\n    defmodule Lazy do\n      defmacrop get_length do\n        import Kernel, except: [length: 1]\n\n        quote do\n          length("hello")\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        import String, only: [length: 1]\n        get_length\n      end\n    end\n\n    Lazy.return_length()\n    #=> 5\n\n## Stacktrace information\n\nWhen defining functions via macros, developers have the option of\nchoosing if runtime errors will be reported from the caller or from\ninside the quote. Let\'s see an example:\n\n    # adder.ex\n    defmodule Adder do\n      @doc "Defines a function that adds two numbers"\n      defmacro defadd do\n        quote location: :keep do\n          def add(a, b), do: a + b\n        end\n      end\n    end\n\n    # sample.ex\n    defmodule Sample do\n      import Adder\n      defadd\n    end\n\n    require Sample\n    Sample.add(:one, :two)\n    ** (ArithmeticError) bad argument in arithmetic expression\n        adder.ex:5: Sample.add/2\n\nWhen using `location: :keep` and invalid arguments are given to\n`Sample.add/2`, the stacktrace information will point to the file\nand line inside the quote. Without `location: :keep`, the error is\nreported to where `defadd` was invoked. `location: :keep` affects\nonly definitions inside the quote.\n\n> #### `location: :keep` and unquote {: .warning}\n>\n> Do not use `location: :keep` if the function definition\n> also `unquote`s some of the macro arguments. If you do so, Elixir\n> will store the file definition of the current location but the\n> unquoted arguments may contain line information of the macro caller,\n> leading to erroneous stacktraces.\n\n## Binding and unquote fragments\n\nElixir quote/unquote mechanisms provide a functionality called\nunquote fragments. Unquote fragments provide an easy way to generate\nfunctions on the fly. Consider this example:\n\n    kv = [foo: 1, bar: 2]\n    Enum.each(kv, fn {k, v} ->\n      def unquote(k)(), do: unquote(v)\n    end)\n\nIn the example above, we have generated the functions `foo/0` and\n`bar/0` dynamically. Now, imagine that we want to convert this\nfunctionality into a macro:\n\n    defmacro defkv(kv) do\n      Enum.map(kv, fn {k, v} ->\n        quote do\n          def unquote(k)(), do: unquote(v)\n        end\n      end)\n    end\n\nWe can invoke this macro as:\n\n    defkv [foo: 1, bar: 2]\n\nHowever, we can\'t invoke it as follows:\n\n    kv = [foo: 1, bar: 2]\n    defkv kv\n\nThis is because the macro is expecting its arguments to be a\nkeyword list at **compilation** time. Since in the example above\nwe are passing the representation of the variable `kv`, our\ncode fails.\n\nThis is actually a common pitfall when developing macros. We are\nassuming a particular shape in the macro. We can work around it\nby unquoting the variable inside the quoted expression:\n\n    defmacro defkv(kv) do\n      quote do\n        Enum.each(unquote(kv), fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIf you try to run our new macro, you will notice it won\'t\neven compile, complaining that the variables `k` and `v`\ndo not exist. This is because of the ambiguity: `unquote(k)`\ncan either be an unquote fragment, as previously, or a regular\nunquote as in `unquote(kv)`.\n\nOne solution to this problem is to disable unquoting in the\nmacro, however, doing that would make it impossible to inject the\n`kv` representation into the tree. That\'s when the `:bind_quoted`\noption comes to the rescue (again!). By using `:bind_quoted`, we\ncan automatically disable unquoting while still injecting the\ndesired variables into the tree:\n\n    defmacro defkv(kv) do\n      quote bind_quoted: [kv: kv] do\n        Enum.each(kv, fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIn fact, the `:bind_quoted` option is recommended every time\none desires to inject a value into the quote.\n',
    },
    {
      name: "import/2",
      type: "macro",
      specs: [],
      documentation:
        'Imports functions and macros from other modules.\n\n`import/2` allows one to easily access functions or macros from\nother modules without using the qualified name.\n\n## Examples\n\nIf you are using several functions from a given module, you can\nimport those functions and reference them as local functions,\nfor example:\n\n    iex> import List\n    iex> flatten([1, [2], 3])\n    [1, 2, 3]\n\n## Selector\n\nBy default, Elixir imports functions and macros from the given\nmodule, except the ones starting with an underscore (which are\nusually callbacks):\n\n    import List\n\nA developer can filter to import only functions, macros, or sigils\n(which can be functions or macros) via the `:only` option:\n\n    import List, only: :functions\n    import List, only: :macros\n    import Kernel, only: :sigils\n\nAlternatively, Elixir allows a developer to pass pairs of\nname/arities to `:only` or `:except` as a fine grained control\non what to import (or not):\n\n    import List, only: [flatten: 1]\n    import String, except: [split: 2]\n\nImporting the same module again will erase the previous imports,\nexcept when the `except` option is used, which is always exclusive\non a previously declared `import/2`. If there is no previous import,\nthen it applies to all functions and macros in the module. For\nexample:\n\n    import List, only: [flatten: 1, keyfind: 4]\n    import List, except: [flatten: 1]\n\nAfter the two import calls above, only `List.keyfind/4` will be\nimported.\n\n## Underscore functions\n\nBy default functions starting with `_` are not imported. If you really want\nto import a function starting with `_` you must explicitly include it in the\n`:only` selector.\n\n    import File.Stream, only: [__build__: 3]\n\n## Lexical scope\n\nIt is important to note that `import/2` is lexical. This means you\ncan import specific macros inside specific functions:\n\n    defmodule Math do\n      def some_function do\n        # 1) Disable "if/2" from Kernel\n        import Kernel, except: [if: 2]\n\n        # 2) Require the new "if/2" macro from MyMacros\n        import MyMacros\n\n        # 3) Use the new macro\n        if do_something, it_works\n      end\n    end\n\nIn the example above, we imported macros from `MyMacros`,\nreplacing the original `if/2` implementation by our own\nwithin that specific function. All other functions in that\nmodule will still be able to use the original one.\n\n## Warnings\n\nIf you import a module and you don\'t use any of the imported\nfunctions or macros from this module, Elixir is going to issue\na warning implying the import is not being used.\n\nIn case the import is generated automatically by a macro,\nElixir won\'t emit any warnings though, since the import\nwas not explicitly defined.\n\nBoth warning behaviors could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.\n\n## Ambiguous function/macro names\n\nIf two modules `A` and `B` are imported and they both contain\na `foo` function with an arity of `1`, an error is only emitted\nif an ambiguous call to `foo/1` is actually made; that is, the\nerrors are emitted lazily, not eagerly.\n',
    },
    {
      name: "for/1",
      type: "macro",
      specs: [],
      documentation:
        'Comprehensions allow you to quickly build a data structure from\nan enumerable or a bitstring.\n\nLet\'s start with an example:\n\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\nA comprehension accepts many generators and filters. `for` uses\nthe `<-` operator to extract values from the enumerable on its\nright side and match them against the pattern on the left.\nWe call them generators:\n\n    # A list generator:\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\n    # A comprehension with two generators\n    iex> for x <- [1, 2], y <- [2, 3], do: x * y\n    [2, 3, 4, 6]\n\nFilters can also be given:\n\n    # A comprehension with a generator and a filter\n    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n    [2, 4, 6]\n\nFilters must evaluate to truthy values (everything but `nil`\nand `false`). If a filter is falsy, then the current value is\ndiscarded.\n\nGenerators can also be used to filter as it removes any value\nthat doesn\'t match the pattern on the left side of `<-`:\n\n    iex> users = [user: "john", admin: "meg", guest: "barbara"]\n    iex> for {type, name} when type != :guest <- users do\n    ...>   String.upcase(name)\n    ...> end\n    ["JOHN", "MEG"]\n\nBitstring generators are also supported and are very useful when you\nneed to organize bitstring streams:\n\n    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n    iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}\n    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n\nVariable assignments inside the comprehension, be it in generators,\nfilters or inside the block, are not reflected outside of the\ncomprehension.\n\nVariable assignments inside filters must still return a truthy value,\notherwise values are discarded. Let\'s see an example. Imagine you have\na keyword list where the key is a programming language and the value\nis its direct parent. Then let\'s try to compute the grandparent of each\nlanguage. You could try this:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent = languages[parent], do: {language, grandparent}\n    [elixir: :prolog]\n\nGiven the grandparents of Erlang and Prolog were nil, those values were\nfiltered out. If you don\'t want this behavior, a simple option is to\nmove the filter inside the do-block:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages do\n    ...>   grandparent = languages[parent]\n    ...>   {language, grandparent}\n    ...> end\n    [elixir: :prolog, erlang: nil, prolog: nil]\n\nHowever, such option is not always available, as you may have further\nfilters. An alternative is to convert the filter into a generator by\nwrapping the right side of `=` in a list:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent <- [languages[parent]], do: {language, grandparent}\n    [elixir: :prolog, erlang: nil, prolog: nil]\n\n## The `:into` and `:uniq` options\n\nIn the examples above, the result returned by the comprehension was\nalways a list. The returned result can be configured by passing an\n`:into` option, that accepts any structure as long as it implements\nthe `Collectable` protocol.\n\nFor example, we can use bitstring generators with the `:into` option\nto easily remove all spaces in a string:\n\n    iex> for <<c <- " hello world ">>, c != ?\\s, into: "", do: <<c>>\n    "helloworld"\n\nThe `IO` module provides streams, that are both `Enumerable` and\n`Collectable`, here is an upcase echo server using comprehensions:\n\n    for line <- IO.stream(), into: IO.stream() do\n      String.upcase(line)\n    end\n\nSimilarly, `uniq: true` can also be given to comprehensions to guarantee\nthe results are only added to the collection if they were not returned\nbefore. For example:\n\n    iex> for x <- [1, 1, 2, 3], uniq: true, do: x * 2\n    [2, 4, 6]\n\n    iex> for <<x <- "abcabc">>, uniq: true, into: "", do: <<x - 32>>\n    "ABC"\n\n## The `:reduce` option\n\n*Available since Elixir v1.8*.\n\nWhile the `:into` option allows us to customize the comprehension behavior\nto a given data type, such as putting all of the values inside a map or inside\na binary, it is not always enough.\n\nFor example, imagine that you have a binary with letters where you want to\ncount how many times each lowercase letter happens, ignoring all uppercase\nones. For instance, for the string `"AbCabCABc"`, we want to return the map\n`%{"a" => 1, "b" => 2, "c" => 1}`.\n\nIf we were to use `:into`, we would need a data type that computes the\nfrequency of each element it holds. While there is no such data type in\nElixir, you could implement one yourself.\n\nA simpler option would be to use comprehensions for the mapping and\nfiltering of letters, and then we invoke `Enum.reduce/3` to build a map,\nfor example:\n\n    iex> letters = for <<x <- "AbCabCABc">>, x in ?a..?z, do: <<x>>\n    iex> Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end)\n    %{"a" => 1, "b" => 2, "c" => 1}\n\nWhile the above is straight-forward, it has the downside of traversing the\ndata at least twice. If you are expecting long strings as inputs, this can\nbe quite expensive.\n\nLuckily, comprehensions also support the `:reduce` option, which would allow\nus to fuse both steps above into a single step:\n\n    iex> for <<x <- "AbCabCABc">>, x in ?a..?z, reduce: %{} do\n    ...>   acc -> Map.update(acc, <<x>>, 1, & &1 + 1)\n    ...> end\n    %{"a" => 1, "b" => 2, "c" => 1}\n\nWhen the `:reduce` key is given, its value is used as the initial accumulator\nand the `do` block must be changed to use `->` clauses, where the left side\nof `->` receives the accumulated value of the previous iteration and the\nexpression on the right side must return the new accumulator value. Once there are no more\nelements, the final accumulated value is returned. If there are no elements\nat all, then the initial accumulator value is returned.\n',
    },
    {
      name: "fn/1",
      type: "macro",
      specs: [],
      documentation:
        "Defines an anonymous function.\n\nSee `Function` for more information.\n\n## Examples\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true\n\n",
    },
    {
      name: "cond/1",
      type: "macro",
      specs: [],
      documentation:
        'Evaluates the expression corresponding to the first clause that\nevaluates to a truthy value.\n\n## Examples\n\nThe following example has a single clause that always evaluates\nto true:\n\n    cond do\n      hd([1, 2, 3]) ->\n        "1 is considered as true"\n    end\n    #=> "1 is considered as true"\n\nIf all clauses evaluate to `nil` or `false`, `cond` raises an error.\nFor this reason, it may be necessary to add a final always-truthy condition\n(anything non-`false` and non-`nil`), which will always match:\n\n    cond do\n      1 + 1 == 1 ->\n        "This will never match"\n      2 * 2 != 4 ->\n        "Nor this"\n      true ->\n        "This will"\n    end\n    #=> "This will"\n\n\nIf your `cond` has two clauses, and the last one falls back to\n`true`, you may consider using `if/2` instead.\n',
    },
    {
      name: "case/2",
      type: "macro",
      specs: [],
      documentation:
        'Matches the given expression against the given clauses.\n\n`case/2` relies on pattern matching and guards to choose\nwhich clause to execute. If your logic cannot be expressed\nwithin patterns and guards, consider using `if/2` or `cond/1`\ninstead.\n\n## Examples\n\n    case File.read(file) do\n      {:ok, contents} when is_binary(contents) ->\n        String.split(contents, "\\n")\n\n      {:error, _reason} ->\n        Logger.warning "could not find #{file}, assuming empty..."\n        []\n    end\n\nIn the example above, we match the result of `File.read/1`\nagainst each clause "head" and execute the clause "body"\ncorresponding to the first clause that matches.\n\nIf no clause matches, an error is raised. For this reason,\nit may be necessary to add a final catch-all clause (like `_`)\nwhich will always match.\n\n    x = 10\n\n    case x do\n      0 ->\n        "This clause won\'t match"\n\n      _ ->\n        "This clause would match any value (x = #{x})"\n    end\n    #=> "This clause would match any value (x = 10)"\n\nIf you find yourself nesting `case` expressions inside\n`case` expressions, consider using `with/1`.\n\n## Variable handling\n\nNote that variables bound in a clause do not leak to the outer context:\n\n    case data do\n      {:ok, value} -> value\n      :error -> nil\n    end\n\n    value\n    #=> unbound variable value\n\nVariables in the outer context cannot be overridden either:\n\n    value = 7\n\n    case lucky? do\n      false -> value = 13\n      true -> true\n    end\n\n    value\n    #=> 7\n\nIn the example above, `value` is going to be `7` regardless of the value of\n`lucky?`. The variable `value` bound in the clause and the variable `value`\nbound in the outer context are two entirely separate variables.\n\nIf you want to pattern match against an existing variable,\nyou need to use the `^/1` operator:\n\n    x = 1\n\n    case 10 do\n      ^x -> "Won\'t match"\n      _ -> "Will match"\n    end\n    #=> "Will match"\n\n## Using guards to match against multiple values\n\nWhile it is not possible to match against multiple patterns in a single\nclause, it\'s possible to match against multiple values by using guards:\n\n    case data do\n      value when value in [:one, :two] ->\n        "#{value} has been matched"\n\n      :three ->\n        "three has been matched"\n    end\n\n',
    },
    {
      name: "alias/2",
      type: "macro",
      specs: [],
      documentation:
        "`alias/2` is used to set up aliases, often useful with modules' names.\n\n## Examples\n\n`alias/2` can be used to set up an alias for any module:\n\n    defmodule Math do\n      alias MyKeyword, as: Keyword\n    end\n\nIn the example above, we have set up `MyKeyword` to be aliased\nas `Keyword`. So now, any reference to `Keyword` will be\nautomatically replaced by `MyKeyword`.\n\nIn case one wants to access the original `Keyword`, it can be done\nby accessing `Elixir`:\n\n    Keyword.values #=> uses MyKeyword.values\n    Elixir.Keyword.values #=> uses Keyword.values\n\nNote that calling `alias` without the `:as` option automatically\nsets an alias based on the last part of the module. For example:\n\n    alias Foo.Bar.Baz\n\nIs the same as:\n\n    alias Foo.Bar.Baz, as: Baz\n\nWe can also alias multiple modules in one line:\n\n    alias Foo.{Bar, Baz, Biz}\n\nIs the same as:\n\n    alias Foo.Bar\n    alias Foo.Baz\n    alias Foo.Biz\n\n## Lexical scope\n\n`import/2`, `require/2` and `alias/2` are called directives and all\nhave lexical scope. This means you can set up aliases inside\nspecific functions and it won't affect the overall scope.\n\n## Warnings\n\nIf you alias a module and you don't use the alias, Elixir is\ngoing to issue a warning implying the alias is not being used.\n\nIn case the alias is generated automatically by a macro,\nElixir won't emit any warnings though, since the alias\nwas not explicitly defined.\n\nBoth warning behaviors could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.\n\n",
    },
    {
      name: "__cursor__/1",
      type: "macro",
      specs: [],
      documentation:
        "Internal special form for cursor position.\n\nThis is the special form used whenever we need to represent\nthe cursor position in Elixir's AST. See `Code.Fragment` for\nmore information.\n",
    },
    {
      name: "__block__/1",
      type: "macro",
      specs: [],
      documentation:
        "Internal special form for block expressions.\n\nThis is the special form used whenever we have a block\nof expressions in Elixir. This special form is private\nand should not be invoked directly:\n\n    iex> quote do\n    ...>   1\n    ...>   2\n    ...>   3\n    ...> end\n    {:__block__, [], [1, 2, 3]}\n\n",
    },
    {
      name: "__aliases__/1",
      type: "macro",
      specs: [],
      documentation:
        "Internal special form to hold aliases information.\n\nIt is usually compiled to an atom:\n\n    iex> quote do\n    ...>   Foo.Bar\n    ...> end\n    {:__aliases__, [alias: false], [:Foo, :Bar]}\n\nElixir represents `Foo.Bar` as `__aliases__` so calls can be\nunambiguously identified by the operator `:.`. For example:\n\n    iex> quote do\n    ...>   Foo.bar()\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n\nWhenever an expression iterator sees a `:.` as the tuple key,\nit can be sure that it represents a call and the second argument\nin the list is an atom.\n\nOn the other hand, aliases hold some properties:\n\n  1. The head element of aliases can be any term that must expand to\n     an atom at compilation time.\n\n  2. The tail elements of aliases are guaranteed to always be atoms.\n\n  3. When the head element of aliases is the atom `:Elixir`, no expansion happens.\n\n",
    },
    {
      name: "__STACKTRACE__/0",
      type: "macro",
      specs: [],
      documentation:
        "Returns the stacktrace for the currently handled exception.\n\nIt is available only in the `catch` and `rescue` clauses of `try/1`\nexpressions.\n\nTo retrieve the stacktrace of the current process, use\n`Process.info(self(), :current_stacktrace)` instead.\n",
    },
    {
      name: "__MODULE__/0",
      type: "macro",
      specs: [],
      documentation:
        "Returns the current module name as an atom or `nil` otherwise.\n\nAlthough the module can be accessed in the `__ENV__/0`, this macro\nis a convenient shortcut.\n",
    },
    {
      name: "__ENV__/0",
      type: "macro",
      specs: [],
      documentation:
        "Returns the current environment information as a `Macro.Env` struct.\n\nIn the environment you can access the current filename,\nline numbers, set up aliases, the current function and others.\n",
    },
    {
      name: "__DIR__/0",
      type: "macro",
      specs: [],
      documentation:
        "Returns the absolute path of the directory of the current file as a binary.\n\nAlthough the directory can be accessed as `Path.dirname(__ENV__.file)`,\nthis macro is a convenient shortcut.\n",
    },
    {
      name: "__CALLER__/0",
      type: "macro",
      specs: [],
      documentation:
        "Returns the current calling environment as a `Macro.Env` struct.\n\nIn the environment you can access the filename, line numbers,\nset up aliases, the function and others.\n",
    },
    {
      name: "^/1",
      type: "macro",
      specs: [],
      documentation:
        "Pin operator. Accesses an already bound variable in match clauses.\n\n## Examples\n\nElixir allows variables to be rebound via static single assignment:\n\n    iex> x = 1\n    iex> x = x + 1\n    iex> x\n    2\n\nHowever, in some situations, it is useful to match against an existing\nvalue, instead of rebinding. This can be done with the `^` special form,\ncolloquially known as the pin operator:\n\n    iex> x = 1\n    iex> ^x = List.first([1])\n    iex> ^x = List.first([2])\n    ** (MatchError) no match of right hand side value: 2\n\nNote that `^x` always refers to the value of `x` prior to the match. The\nfollowing example will match:\n\n    iex> x = 0\n    iex> {x, ^x} = {1, 0}\n    iex> x\n    1\n\n",
    },
    {
      name: "=/2",
      type: "macro",
      specs: [],
      documentation:
        "Match operator. Matches the value on the right against the pattern on the left.\n",
    },
    {
      name: "<<>>/1",
      type: "macro",
      specs: [],
      documentation:
        'Defines a new bitstring.\n\n## Examples\n\n    iex> <<1, 2, 3>>\n    <<1, 2, 3>>\n\n## Types\n\nA bitstring is made of many segments and each segment has a\ntype. There are 9 types used in bitstrings:\n\n- `integer`\n- `float`\n- `bits` (alias for `bitstring`)\n- `bitstring`\n- `binary`\n- `bytes` (alias for `binary`)\n- `utf8`\n- `utf16`\n- `utf32`\n\nWhen no type is specified, the default is `integer`:\n\n    iex> <<1, 2, 3>>\n    <<1, 2, 3>>\n\nElixir also accepts by default the segment to be a literal\nstring which expands to integers:\n\n    iex> <<0, "foo">>\n    <<0, 102, 111, 111>>\n\nYou can use one of `utf8` (the default), `utf16`, and `utf32` to\ncontrol how the string is encoded:\n\n    iex> <<"foo"::utf16>>\n    <<0, 102, 0, 111, 0, 111>>\n\nWhich is equivalent to writing:\n\n    iex> <<?f::utf16, ?o::utf16, ?o::utf16>>\n    <<0, 102, 0, 111, 0, 111>>\n\nAt runtime, binaries need to be explicitly tagged as `binary`:\n\n    iex> rest = "oo"\n    iex> <<102, rest::binary>>\n    "foo"\n\nOtherwise we get an `ArgumentError` when constructing the binary:\n\n    rest = "oo"\n    <<102, rest>>\n    ** (ArgumentError) argument error\n\n## Options\n\nMany options can be given by using `-` as separator. Order is\narbitrary, so the following are all equivalent:\n\n    <<102::integer-native, rest::binary>>\n    <<102::native-integer, rest::binary>>\n    <<102::unsigned-big-integer, rest::binary>>\n    <<102::unsigned-big-integer-size(8), rest::binary>>\n    <<102::unsigned-big-integer-8, rest::binary>>\n    <<102::8-integer-big-unsigned, rest::binary>>\n    <<102, rest::binary>>\n\n### Unit and Size\n\nThe length of the match is equal to the `unit` (a number of bits) times the\n`size` (the number of repeated segments of length `unit`).\n\nType      | Default Unit\n--------- | ------------\n`integer` | 1 bit\n`float`   | 1 bit\n`binary`  | 8 bits\n\nSizes for types are a bit more nuanced. The default size for integers is 8.\n\nFor floats, it is 64. For floats, `size * unit` must result in 16, 32, or 64,\ncorresponding to [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)\nbinary16, binary32, and binary64, respectively.\n\nFor binaries, the default is the size of the binary. Only the last binary in a\nmatch can use the default size. All others must have their size specified\nexplicitly, even if the match is unambiguous. For example:\n\n    iex> <<name::binary-size(5), " the ", species::binary>> = <<"Frank the Walrus">>\n    "Frank the Walrus"\n    iex> {name, species}\n    {"Frank", "Walrus"}\n\nThe size can be a variable or any valid guard expression:\n\n    iex> name_size = 5\n    iex> <<name::binary-size(^name_size), " the ", species::binary>> = <<"Frank the Walrus">>\n    iex> {name, species}\n    {"Frank", "Walrus"}\n\nThe size can access prior variables defined in the binary itself:\n\n    iex> <<name_size::size(8), name::binary-size(name_size), " the ", species::binary>> = <<5, "Frank the Walrus">>\n    iex> {name, species}\n    {"Frank", "Walrus"}\n\nHowever, it cannot access variables defined in the match outside of the binary/bitstring:\n\n    {name_size, <<name::binary-size(name_size), _rest::binary>>} = {5, <<"Frank the Walrus">>}\n    ** (CompileError): undefined variable "name_size" in bitstring segment\n\nFailing to specify the size for the non-last causes compilation to fail:\n\n    <<name::binary, " the ", species::binary>> = <<"Frank the Walrus">>\n    ** (CompileError): a binary field without size is only allowed at the end of a binary pattern\n\n#### Shortcut Syntax\n\nSize and unit can also be specified using a syntax shortcut\nwhen passing integer values:\n\n    iex> x = 1\n    iex> <<x::8>> == <<x::size(8)>>\n    true\n    iex> <<x::8*4>> == <<x::size(8)-unit(4)>>\n    true\n\nThis syntax reflects the fact the effective size is given by\nmultiplying the size by the unit.\n\n### Modifiers\n\nSome types have associated modifiers to clear up ambiguity in byte\nrepresentation.\n\nModifier             | Relevant Type(s)\n-------------------- | ----------------\n`signed`             | `integer`\n`unsigned` (default) | `integer`\n`little`             | `integer`, `float`, `utf16`, `utf32`\n`big` (default)      | `integer`, `float`, `utf16`, `utf32`\n`native`             | `integer`, `float`, `utf16`, `utf32`\n\n### Sign\n\nIntegers can be `signed` or `unsigned`, defaulting to `unsigned`.\n\n    iex> <<int::integer>> = <<-100>>\n    <<156>>\n    iex> int\n    156\n    iex> <<int::integer-signed>> = <<-100>>\n    <<156>>\n    iex> int\n    -100\n\n`signed` and `unsigned` are only used for matching binaries (see below) and\nare only used for integers.\n\n    iex> <<-100::signed, _rest::binary>> = <<-100, "foo">>\n    <<156, 102, 111, 111>>\n\n### Endianness\n\nElixir has three options for endianness: `big`, `little`, and `native`.\nThe default is `big`:\n\n    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    256\n    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    1\n\n`native` is determined by the VM at startup and will depend on the\nhost operating system.\n\n## Binary/Bitstring Matching\n\nBinary matching is a powerful feature in Elixir that is useful for extracting\ninformation from binaries as well as pattern matching.\n\nBinary matching can be used by itself to extract information from binaries:\n\n    iex> <<"Hello, ", place::binary>> = "Hello, World"\n    "Hello, World"\n    iex> place\n    "World"\n\nOr as a part of function definitions to pattern match:\n\n    defmodule ImageType do\n      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n                       13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n      @jpg_signature <<255::size(8), 216::size(8)>>\n\n      def type(<<@png_signature, _rest::binary>>), do: :png\n      def type(<<@jpg_signature, _rest::binary>>), do: :jpg\n      def type(_), do: :unknown\n    end\n\n### Performance & Optimizations\n\nThe Erlang compiler can provide a number of optimizations on binary creation\nand matching. To see optimization output, set the `bin_opt_info` compiler\noption:\n\n    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n\nTo learn more about specific optimizations and performance considerations,\ncheck out the\n["Constructing and matching binaries" chapter of the Erlang\'s Efficiency Guide](https://www.erlang.org/doc/efficiency_guide/binaryhandling.html).\n',
    },
    {
      name: "::/2",
      type: "macro",
      specs: [],
      documentation:
        "Type operator. Used by types and bitstrings to specify types.\n\nThis operator is used in two distinct occasions in Elixir.\nIt is used in typespecs to specify the type of a variable,\nfunction or of a type itself:\n\n    @type number :: integer | float\n    @spec add(number, number) :: number\n\nIt may also be used in bit strings to specify the type\nof a given bit segment:\n\n    <<int::integer-little, rest::bits>> = bits\n\nRead the documentation on the [Typespecs page](typespecs.md) and\n`<<>>/1` for more information on typespecs and\nbitstrings respectively.\n",
    },
    {
      name: "./2",
      type: "macro",
      specs: [],
      documentation:
        'Dot operator. Defines a remote call, a call to an anonymous function, or an alias.\n\nThe dot (`.`) in Elixir can be used for remote calls:\n\n    iex> String.downcase("FOO")\n    "foo"\n\nIn this example above, we have used `.` to invoke `downcase` in the\n`String` module, passing `"FOO"` as argument.\n\nThe dot may be used to invoke anonymous functions too:\n\n    iex> (fn n -> n end).(7)\n    7\n\nin which case there is a function on the left hand side.\n\nWe can also use the dot for creating aliases:\n\n    iex> Hello.World\n    Hello.World\n\nThis time, we have joined two aliases, defining the final alias\n`Hello.World`.\n\n## Syntax\n\nThe right side of `.` may be a word starting with an uppercase letter, which represents\nan alias, a word starting with lowercase or underscore, any valid language\noperator or any name wrapped in single- or double-quotes. Those are all valid\nexamples:\n\n    iex> Kernel.Sample\n    Kernel.Sample\n\n    iex> Kernel.length([1, 2, 3])\n    3\n\n    iex> Kernel.+(1, 2)\n    3\n\n    iex> Kernel."+"(1, 2)\n    3\n\nWrapping the function name in single- or double-quotes is always a\nremote call. Therefore `Kernel."Foo"` will attempt to call the function "Foo"\nand not return the alias `Kernel.Foo`. This is done by design as module names\nare more strict than function names.\n\nWhen the dot is used to invoke an anonymous function there is only one\noperand, but it is still written using a postfix notation:\n\n    iex> negate = fn n -> -n end\n    iex> negate.(7)\n    -7\n\n## Quoted expression\n\nWhen `.` is used, the quoted expression may take two distinct\nforms. When the right side starts with a lowercase letter (or\nunderscore):\n\n    iex> quote do\n    ...>   String.downcase("FOO")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}\n\nNote that we have an inner tuple, containing the atom `:.` representing\nthe dot as first element:\n\n    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n\nThis tuple follows the general quoted expression structure in Elixir,\nwith the name as first argument, some keyword list as metadata as second,\nand the list of arguments as third. In this case, the arguments are the\nalias `String` and the atom `:downcase`. The second argument in a remote call\nis **always** an atom.\n\nIn the case of calls to anonymous functions, the inner tuple with the dot\nspecial form has only one argument, reflecting the fact that the operator is\nunary:\n\n    iex> quote do\n    ...>   negate.(0)\n    ...> end\n    {{:., [], [{:negate, [], __MODULE__}]}, [], [0]}\n\nWhen the right side is an alias (i.e. starts with uppercase), we get instead:\n\n    iex> quote do\n    ...>   Hello.World\n    ...> end\n    {:__aliases__, [alias: false], [:Hello, :World]}\n\nWe go into more details about aliases in the `__aliases__/1` special form\ndocumentation.\n\n## Unquoting\n\nWe can also use unquote to generate a remote call in a quoted expression:\n\n    iex> x = :downcase\n    iex> quote do\n    ...>   String.unquote(x)("FOO")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}\n\nSimilar to `Kernel."FUNCTION_NAME"`, `unquote(x)` will always generate a remote call,\nindependent of the value of `x`. To generate an alias via the quoted expression,\none needs to rely on `Module.concat/2`:\n\n    iex> x = Sample\n    iex> quote do\n    ...>   Module.concat(String, unquote(x))\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n     [{:__aliases__, [alias: false], [:String]}, Sample]}\n\n',
    },
    {
      name: "&/1",
      type: "macro",
      specs: [],
      documentation:
        'Capture operator. Captures or creates an anonymous function.\n\n## Capture\n\nThe capture operator is most commonly used to capture a\nfunction with given name and arity from a module:\n\n    iex> fun = &Kernel.is_atom/1\n    iex> fun.(:atom)\n    true\n    iex> fun.("string")\n    false\n\nIn the example above, we captured `Kernel.is_atom/1` as an\nanonymous function and then invoked it.\n\nThe capture operator can also be used to capture local functions,\nincluding private ones, and imported functions by omitting the\nmodule name:\n\n    &local_function/1\n\nSee also `Function.capture/3`.\n\n## Anonymous functions\n\nThe capture operator can also be used to partially apply\nfunctions, where `&1`, `&2` and so on can be used as value\nplaceholders. For example:\n\n    iex> double = &(&1 * 2)\n    iex> double.(2)\n    4\n\nIn other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n\nWe can partially apply a remote function with placeholder:\n\n    iex> take_five = &Enum.take(&1, 5)\n    iex> take_five.(1..10)\n    [1, 2, 3, 4, 5]\n\nAnother example while using an imported or local function:\n\n    iex> first_elem = &elem(&1, 0)\n    iex> first_elem.({0, 1})\n    0\n\nThe `&` operator can be used with more complex expressions:\n\n    iex> fun = &(&1 + &2 + &3)\n    iex> fun.(1, 2, 3)\n    6\n\nAs well as with lists and tuples:\n\n    iex> fun = &{&1, &2}\n    iex> fun.(1, 2)\n    {1, 2}\n\n    iex> fun = &[&1 | &2]\n    iex> fun.(1, [2, 3])\n    [1, 2, 3]\n\nThe only restrictions when creating anonymous functions is that at\nleast one placeholder must be present, i.e. it must contain at least\n`&1`, and that block expressions are not supported:\n\n    # No placeholder, fails to compile.\n    &(:foo)\n\n    # Block expression, fails to compile.\n    &(&1; &2)\n\n',
    },
    {
      name: "%{}/1",
      type: "macro",
      specs: [],
      documentation:
        'Creates a map.\n\nSee the `Map` module for more information about maps, their syntax, and ways to\naccess and manipulate them.\n\n## AST representation\n\nRegardless of whether `=>` or the keyword syntax is used, key-value pairs in\nmaps are always represented internally as a list of two-element tuples for\nsimplicity:\n\n    iex> quote do\n    ...>   %{"a" => :b, c: :d}\n    ...> end\n    {:%{}, [], [{"a", :b}, {:c, :d}]}\n\n',
    },
    {
      name: "%/2",
      type: "macro",
      specs: [],
      documentation:
        'Matches on or builds a struct.\n\nA struct is a tagged map that allows developers to provide\ndefault values for keys, tags to be used in polymorphic\ndispatches and compile time assertions.\n\nStructs are usually defined with the `Kernel.defstruct/1` macro:\n\n    defmodule User do\n      defstruct name: "john", age: 27\n    end\n\nNow a struct can be created as follows:\n\n    %User{}\n\nUnderneath a struct is just a map with a `:__struct__` key\npointing to the `User` module:\n\n    %User{} == %{__struct__: User, name: "john", age: 27}\n\nThe struct fields can be given when building the struct:\n\n    %User{age: 31}\n    #=> %{__struct__: User, name: "john", age: 31}\n\nOr also on pattern matching to extract values out:\n\n    %User{age: age} = user\n\nAn update operation specific for structs is also available:\n\n    %User{user | age: 28}\n\nThe advantage of structs is that they validate that the given\nkeys are part of the defined struct. The example below will fail\nbecause there is no key `:full_name` in the `User` struct:\n\n    %User{full_name: "john doe"}\n\nThe syntax above will guarantee the given keys are valid at\ncompilation time and it will guarantee at runtime the given\nargument is a struct, failing with `BadStructError` otherwise.\n\nAlthough structs are maps, by default structs do not implement\nany of the protocols implemented for maps. Check\n`Kernel.defprotocol/2` for more information on how structs\ncan be used with protocols for polymorphic dispatch. Also\nsee `Kernel.struct/2` and `Kernel.struct!/2` for examples on\nhow to create and update structs dynamically.\n\n## Pattern matching on struct names\n\nBesides allowing pattern matching on struct fields, such as:\n\n    %User{age: age} = user\n\nStructs also allow pattern matching on the struct name:\n\n    %struct_name{} = user\n    struct_name #=> User\n\nYou can also assign the struct name to `_` when you want to\ncheck if something is a struct but you are not interested in\nits name:\n\n    %_{} = user\n\n',
    },
  ],
  types: [],
};
