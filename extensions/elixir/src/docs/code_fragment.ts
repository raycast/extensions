import type { ModuleDoc } from "../types";

export const Code_Fragment: ModuleDoc = {
  functions: [
    {
      name: "surround_context/3",
      type: "function",
      specs: [
        "@spec surround_context(List.Chars.t(), position(), keyword()) ::\n        %{begin: position(), end: position(), context: context} | :none\n      when context:\n             {:alias, charlist()}\n             | {:alias, inside_alias, charlist()}\n             | {:dot, inside_dot, charlist()}\n             | {:local_or_var, charlist()}\n             | {:local_arity, charlist()}\n             | {:local_call, charlist()}\n             | {:module_attribute, charlist()}\n             | {:operator, charlist()}\n             | {:sigil, charlist()}\n             | {:struct, inside_struct}\n             | {:unquoted_atom, charlist()}\n             | {:keyword, charlist()},\n           inside_dot:\n             {:alias, charlist()}\n             | {:alias, inside_alias, charlist()}\n             | {:dot, inside_dot, charlist()}\n             | {:module_attribute, charlist()}\n             | {:unquoted_atom, charlist()}\n             | {:var, charlist()}\n             | :expr,\n           inside_alias:\n             {:local_or_var, charlist()} | {:module_attribute, charlist()},\n           inside_struct:\n             charlist()\n             | {:alias, inside_alias, charlist()}\n             | {:local_or_var, charlist()}\n             | {:module_attribute, charlist()}\n             | {:dot, inside_dot, charlist()}",
      ],
      documentation:
        "Receives a string and returns the surround context.\n\nThis function receives a string with an Elixir code fragment\nand a `position`. It returns a map containing the beginning\nand ending of the identifier alongside its context, or `:none`\nif there is nothing with a known context. This is useful to\nprovide mouse-over and highlight functionality in editors.\n\nThe difference between `cursor_context/2` and `surround_context/3`\nis that the former assumes the expression in the code fragment\nis incomplete. For example, `do` in `cursor_context/2` may be\na keyword or a variable or a local call, while `surround_context/3`\nassumes the expression in the code fragment is complete, therefore\n`do` would always be a keyword.\n\nThe `position` contains both the `line` and `column`, both starting\nwith the index of 1. The column must precede the surrounding expression.\nFor example, the expression `foo`, will return something for the columns\n1, 2, and 3, but not 4:\n\n    foo\n    ^ column 1\n\n    foo\n     ^ column 2\n\n    foo\n      ^ column 3\n\n    foo\n       ^ column 4\n\nThe returned map contains the column the expression starts and the\nfirst column after the expression ends.\n\nSimilar to `cursor_context/2`, this function is also token-based\nand may not be accurate under all circumstances. See the\n\"Return values\" and \"Limitations\" section under `cursor_context/2`\nfor more information.\n\n## Examples\n\n    iex> Code.Fragment.surround_context(\"foo\", {1, 1})\n    %{begin: {1, 1}, context: {:local_or_var, ~c\"foo\"}, end: {1, 4}}\n\n## Differences to `cursor_context/2`\n\nBecause `surround_context/3` attempts to capture complex expressions,\nit has some differences to `cursor_context/2`:\n\n  * `dot_call`/`dot_arity` and `operator_call`/`operator_arity`\n    are collapsed into `dot` and `operator` contexts respectively\n    as there aren't any meaningful distinctions between them\n\n  * On the other hand, this function still makes a distinction between\n    `local_call`/`local_arity` and `local_or_var`, since the latter can\n    be a local or variable\n\n  * `@` when not followed by any identifier is returned as `{:operator, '@'}`\n    (in contrast to `{:module_attribute, ''}` in `cursor_context/2`\n\n  * This function never returns empty sigils `{:sigil, ''}` or empty structs\n    `{:struct, ''}` as context\n\n  * This function returns keywords as `{:keyword, 'do'}`\n\n  * This function never returns `:expr`\n\nWe recommend looking at the test suite of this function for a complete list\nof examples and their return values.\n",
    },
    {
      name: "cursor_context/2",
      type: "function",
      specs: [
        "@spec cursor_context(\n        List.Chars.t(),\n        keyword()\n      ) ::\n        {:alias, charlist()}\n        | {:alias, inside_alias, charlist()}\n        | {:dot, inside_dot, charlist()}\n        | {:dot_arity, inside_dot, charlist()}\n        | {:dot_call, inside_dot, charlist()}\n        | :expr\n        | {:local_or_var, charlist()}\n        | {:local_arity, charlist()}\n        | {:local_call, charlist()}\n        | {:anonymous_call, inside_caller}\n        | {:module_attribute, charlist()}\n        | {:operator, charlist()}\n        | {:operator_arity, charlist()}\n        | {:operator_call, charlist()}\n        | :none\n        | {:sigil, charlist()}\n        | {:struct, inside_struct}\n        | {:unquoted_atom, charlist()}\n      when inside_dot:\n             {:alias, charlist()}\n             | {:alias, inside_alias, charlist()}\n             | {:dot, inside_dot, charlist()}\n             | {:module_attribute, charlist()}\n             | {:unquoted_atom, charlist()}\n             | {:var, charlist()}\n             | :expr,\n           inside_alias:\n             {:local_or_var, charlist()} | {:module_attribute, charlist()},\n           inside_struct:\n             charlist()\n             | {:alias, inside_alias, charlist()}\n             | {:local_or_var, charlist()}\n             | {:module_attribute, charlist()}\n             | {:dot, inside_dot, charlist()},\n           inside_caller: {:var, charlist()} | {:module_attribute, charlist()}",
      ],
      documentation:
        'Receives a string and returns the cursor context.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and based on the string, it\nprovides contextual information about the latest token.\nThe return of this function can then be used to provide tips,\nsuggestions, and autocompletion functionality.\n\nThis function performs its analyses on tokens. This means\nit does not understand how constructs are nested within each\nother. See the "Limitations" section below.\n\nConsider adding a catch-all clause when handling the return\ntype of this function as new cursor information may be added\nin future releases.\n\n## Examples\n\n    iex> Code.Fragment.cursor_context("")\n    :expr\n\n    iex> Code.Fragment.cursor_context("hello_wor")\n    {:local_or_var, ~c"hello_wor"}\n\n## Return values\n\n  * `{:alias, charlist}` - the context is an alias, potentially\n    a nested one, such as `Hello.Wor` or `HelloWor`\n\n  * `{:alias, inside_alias, charlist}` - the context is an alias, potentially\n    a nested one, where `inside_alias` is an expression `{:module_attribute, charlist}`\n    or `{:local_or_var, charlist}` and `charlist` is a static part\n    Examples are `__MODULE__.Submodule` or `@hello.Submodule`\n\n  * `{:dot, inside_dot, charlist}` - the context is a dot\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, this may either be a remote call or a map\n    field access. Examples are `Hello.wor`, `:hello.wor`, `hello.wor`,\n    `Hello.nested.wor`, `hello.nested.wor`, and `@hello.world`. If `charlist`\n    is empty and `inside_dot` is an alias, then the autocompletion may either\n    be an alias or a remote call.\n\n  * `{:dot_arity, inside_dot, charlist}` - the context is a dot arity\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote arity. Examples are\n    `Hello.world/`, `:hello.world/`, `hello.world/2`, and `@hello.world/2`\n\n  * `{:dot_call, inside_dot, charlist}` - the context is a dot\n    call. This means parentheses or space have been added after the expression.\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote call. Examples are\n    `Hello.world(`, `:hello.world(`, `Hello.world `, `hello.world(`, `hello.world `,\n    and `@hello.world(`\n\n  * `:expr` - may be any expression. Autocompletion may suggest an alias,\n    local or var\n\n  * `{:local_or_var, charlist}` - the context is a variable or a local\n    (import or local) call, such as `hello_wor`\n\n  * `{:local_arity, charlist}` - the context is a local (import or local)\n    arity, such as `hello_world/`\n\n  * `{:local_call, charlist}` - the context is a local (import or local)\n    call, such as `hello_world(` and `hello_world `\n\n  * `{:anonymous_call, inside_caller}` - the context is an anonymous\n    call, such as `fun.(` and `@fun.(`.\n\n  * `{:module_attribute, charlist}` - the context is a module attribute,\n    such as `@hello_wor`\n\n  * `{:operator, charlist}` - the context is an operator, such as `+` or\n    `==`. Note textual operators, such as `when` do not appear as operators\n    but rather as `:local_or_var`. `@` is never an `:operator` and always a\n    `:module_attribute`\n\n  * `{:operator_arity, charlist}` - the context is an operator arity, which\n    is an operator followed by /, such as `+/`, `not/` or `when/`\n\n  * `{:operator_call, charlist}` - the context is an operator call, which is\n    an operator followed by space, such as `left + `, `not ` or `x when `\n\n  * `:none` - no context possible\n\n  * `{:sigil, charlist}` - the context is a sigil. It may be either the beginning\n    of a sigil, such as `~` or `~s`, or an operator starting with `~`, such as\n    `~>` and `~>>`\n\n  * `{:struct, inside_struct}` - the context is a struct, such as `%`, `%UR` or `%URI`.\n    `inside_struct` can either be a `charlist` in case of a static alias or an\n    expression `{:alias, inside_alias, charlist}`, `{:module_attribute, charlist}`,\n    `{:local_or_var, charlist}`, `{:dot, inside_dot, charlist}`\n\n  * `{:unquoted_atom, charlist}` - the context is an unquoted atom. This\n    can be any atom or an atom representing a module\n\nWe recommend looking at the test suite of this function for a complete list\nof examples and their return values.\n\n## Limitations\n\nThe analysis is based on the current token, by analysing the last line of\nthe input. For example, this code:\n\n    iex> Code.Fragment.cursor_context("%URI{")\n    :expr\n\nreturns `:expr`, which suggests any variable, local function or alias\ncould be used. However, given we are inside a struct, the best suggestion\nwould be a struct field. In such cases, you can use\n`container_cursor_to_quoted`, which will return the container of the AST\nthe cursor is currently within. You can then analyse this AST to provide\ncompletion of field names.\n\nAs a consequence of its token-based implementation, this function considers\nonly the last line of the input. This means it will show suggestions inside\nstrings, heredocs, etc, which is intentional as it helps with doctests,\nreferences, and more.\n',
    },
    {
      name: "container_cursor_to_quoted/2",
      type: "function",
      specs: [
        "@spec container_cursor_to_quoted(\n        List.Chars.t(),\n        keyword()\n      ) ::\n        {:ok, Macro.t()}\n        | {:error,\n           {location :: keyword(), binary() | {binary(), binary()}, binary()}}",
      ],
      documentation:
        'Receives a string and returns a quoted expression\nwith the cursor AST position within its parent expression.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and converts such string to\nAST with the inclusion of special `__cursor__()` node representing\nthe cursor position within its container (i.e. its parent).\n\nFor example, take this code, which would be given as input:\n\n    max(some_value,\n\nThis function will return the AST equivalent to:\n\n    max(some_value, __cursor__())\n\nIn other words, this function is capable of closing any open\nbrackets and insert the cursor position. Other content at the\ncursor position which is not a parent is discarded.\nFor example, if this is given as input:\n\n    max(some_value, another_val\n\nIt will return the same AST:\n\n    max(some_value, __cursor__())\n\nSimilarly, if only this is given:\n\n    max(some_va\n\nThen it returns:\n\n    max(__cursor__())\n\nCalls without parenthesis are also supported, as we assume the\nbrackets are implicit.\n\nTuples, lists, maps, and binaries all retain the cursor position:\n\n    max(some_value, [1, 2,\n\nReturns the following AST:\n\n    max(some_value, [1, 2, __cursor__()])\n\nKeyword lists (and do-end blocks) are also retained. The following:\n\n    if(some_value, do:\n    if(some_value, do: :token\n    if(some_value, do: 1 + val\n\nall return:\n\n    if(some_value, do: __cursor__())\n\nFor multi-line blocks, all previous lines are preserved.\n\nThe AST returned by this function is not safe to evaluate but\nit can be analyzed and expanded.\n\n## Examples\n\nFunction call:\n\n    iex> Code.Fragment.container_cursor_to_quoted("max(some_value, ")\n    {:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\nContainers (for example, a list):\n\n    iex> Code.Fragment.container_cursor_to_quoted("[some, value")\n    {:ok, [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}\n\nIf an expression is complete, then the whole expression is discarded\nand only the parent is returned:\n\n    iex> Code.Fragment.container_cursor_to_quoted("if(is_atom(var)")\n    {:ok, {:if, [line: 1], [{:__cursor__, [line: 1], []}]}}\n\nthis means complete expressions themselves return only the cursor:\n\n    iex> Code.Fragment.container_cursor_to_quoted("if(is_atom(var))")\n    {:ok, {:__cursor__, [line: 1], []}}\n\nOperators are also included from Elixir v1.15:\n\n    iex> Code.Fragment.container_cursor_to_quoted("foo +")\n    {:ok, {:+, [line: 1], [{:foo, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `"nofile"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:token_metadata` - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` - a function to encode literals in the AST.\n    See the documentation for `Code.string_to_quoted/2` for more information.\n\n',
    },
  ],
  name: "Code.Fragment",
  callbacks: [],
  macros: [],
  types: [
    {
      name: "position/0",
      type: "type",
      specs: [
        "@type position() :: {line :: pos_integer(), column :: pos_integer()}",
      ],
      documentation: null,
    },
  ],
};
