{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "svelte-docs",
  "title": "Search Svelte Docs",
  "description": "Search the svelte docs directly in Raycast",
  "icon": "svelte-logo-square.png",
  "author": "paolo_ricciuti",
  "categories": [
    "Data",
    "Developer Tools",
    "Documentation",
    "Web"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "index",
      "title": "Search Svelte Docs",
      "description": "Search the svelte docs directly in Raycast",
      "mode": "view"
    }
  ],
  "tools": [
    {
      "name": "search-svelte-docs",
      "title": "Search Svelte Docs",
      "description": "Return the list of all the svelte docs paragraphs filtered by query"
    }
  ],
  "dependencies": {
    "@raycast/api": "^1.64.4",
    "@raycast/utils": "^1.10.1",
    "valibot": "^1.0.0"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.6",
    "@types/node": "20.8.10",
    "@types/react": "18.2.27",
    "eslint": "^8.51.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "scripts": {
    "build": "ray build -e dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish"
  },
  "ai": {
    "evals": [
      {
        "input": "@svelte-docs how can i create state in svelte?",
        "mocks": {
          "search-svelte-docs": [
            {
              "breadcrumbs": [
                "Docs",
                "CLI",
                "Introduction",
                "Overview",
                "Usage"
              ],
              "content": "The easiest way to run sv is with `npx` (or the equivalent command if you're using a different package manager — for example, pnpx if you're using pnpm):npx sv <command> <args>If you're inside a project where sv is already installed, this will use the local installation, otherwise it will download the latest version and run it without installing it, which is particularly useful for `sv create`.",
              "href": "/docs/cli/overview#Usage"
            },
            {
              "breadcrumbs": [
                "Docs",
                "CLI",
                "Commands",
                "sv create"
              ],
              "content": "sv create sets up a new SvelteKit project, with options to setup additional functionality.",
              "href": "/docs/cli/sv-create"
            },
            {
              "breadcrumbs": [
                "Docs",
                "CLI",
                "Commands",
                "sv create",
                "Usage"
              ],
              "content": "npx sv create [options] [path]",
              "href": "/docs/cli/sv-create#Usage"
            },
            {
              "breadcrumbs": [
                "Docs",
                "CLI",
                "Commands",
                "sv create",
                "Options",
                "Programmatic interface"
              ],
              "content": "// TODO: this gives type checking errors in the docs site when not commented out. Need to release sv, install it in the site, and uncomment this.\n// import { create } from 'sv';\n\n// // todo: check if this is right\n// create(cwd, {\n// \t// add your options here\n// \t// todo: list available option\n// });-->",
              "href": "/docs/cli/sv-create#Options-Programmatic-interface"
            },
            {
              "breadcrumbs": [
                "Docs",
                "CLI",
                "Commands",
                "sv migrate",
                "Migrations",
                "app-state"
              ],
              "content": "Migrates $app/stores usage to $app/state in .svelte files. See the migration guide for more details.",
              "href": "/docs/cli/sv-migrate#Migrations-app-state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Creating a project"
              ],
              "content": "The easiest way to start building a SvelteKit app is to run npx sv create:npx sv create my-app\ncd my-app\nnpm install\nnpm run devThe first command will scaffold a new project in the my-app directory asking you if you'd like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173.There are two basic concepts:undefined\nTry editing the files to get a feel for how everything works.",
              "href": "/docs/kit/creating-a-project"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Project types",
                "Library"
              ],
              "content": "You can create a library to be used by other Svelte apps with the `@sveltejs/package` add-on to SvelteKit by choosing the library option when running `sv create`.",
              "href": "/docs/kit/project-types#Library"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Project structure"
              ],
              "content": "A typical SvelteKit project looks like this:my-project/\n├ src/\n│ ├ lib/\n│ │ ├ server/\n│ │ │ └ [your server-only lib files]\n│ │ └ [your lib files]\n│ ├ params/\n│ │ └ [your param matchers]\n│ ├ routes/\n│ │ └ [your routes]\n│ ├ app.html\n│ ├ error.html\n│ ├ hooks.client.js\n│ ├ hooks.server.js\n│ └ service-worker.js\n├ static/\n│ └ [your static assets]\n├ tests/\n│ └ [your tests]\n├ package.json\n├ svelte.config.js\n├ tsconfig.json\n└ vite.config.jsYou'll also find common files like .gitignore and .npmrc (and .prettierrc and eslint.config.js and so on, if you chose those options when running npx sv create).",
              "href": "/docs/kit/project-structure"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Project structure",
                "Project files",
                "src"
              ],
              "content": "The src directory contains the meat of your project. Everything except src/routes and src/app.html is optional.undefined\n(Whether the project contains .js or .ts files depends on whether you opt to use TypeScript when you create your project.)If you added Vitest when you set up your project, your unit tests will live in the src directory with a .test.js extension.",
              "href": "/docs/kit/project-structure#Project-files-src"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Project structure",
                "Project files",
                "package.json"
              ],
              "content": "Your package.json file must include @sveltejs/kit, svelte and vite as devDependencies.When you create a project with npx sv create, you'll also notice that package.json includes &quot;type&quot;: &quot;module&quot;. This means that .js files are interpreted as native JavaScript modules with import and export keywords. Legacy CommonJS files need a .cjs file extension.",
              "href": "/docs/kit/project-structure#Project-files-package.json"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Project structure",
                "Project files",
                "tsconfig.json"
              ],
              "content": "This file (or jsconfig.json, if you prefer type-checked .js files over .ts files) configures TypeScript, if you added typechecking during npx sv create. Since SvelteKit relies on certain configuration being set a specific way, it generates its own .svelte-kit/tsconfig.json file which your own config extends.",
              "href": "/docs/kit/project-structure#Project-files-tsconfig.json"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Getting started",
                "Web standards",
                "Fetch APIs",
                "Headers"
              ],
              "content": "The `Headers` interface allows you to read incoming request.headers and set outgoing response.headers. For example, you can get the request.headers as shown below, and use the `json` convenience function to send modified response.headers: \n \nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ request }) {\n\t// log all headers\n\tconsole.log(...request.headers);\n\n\t// create a JSON Response using a header we received\n\treturn json({\n\t\t// retrieve a specific header\n\t\tuserAgent: request.headers.get('user-agent')\n\t}, {\n\t\t// set a header on the response\n\t\theaders: { 'x-custom-header': 'potato' }\n\t});\n}",
              "href": "/docs/kit/web-standards#Fetch-APIs-Headers"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Routing",
                "+error"
              ],
              "content": "If an error occurs during load, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an +error.svelte file:<!--- file: src/routes/blog/[slug]/+error.svelte --->\n<script>\n\timport { page } from '$app/state';\n</script>\n\n<h1>{page.status}: {page.error.message}</h1>[!LEGACY]\n`$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\nSvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try src/routes/blog/+error.svelte and then src/routes/+error.svelte before rendering the default error page. If that fails (or if the error was thrown from the load function of the root +layout, which sits 'above' the root +error), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a src/error.html file.If the error occurs inside a load function in +layout(.server).js, the closest error boundary in the tree is an +error.svelte file above that layout (not next to it).If no route can be found (404), src/routes/+error.svelte (or the default error page, if that file does not exist) will be used.[!NOTE] `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#Server-hooks-handle) or a [+server.js](#server) request handler.\nYou can read more about error handling here.",
              "href": "/docs/kit/routing#error"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Routing",
                "+layout",
                "+layout.svelte"
              ],
              "content": "To create a layout that applies to every page, make a file called src/routes/+layout.svelte. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...<script>\n\tlet { children } = $props();\n</script>\n\n{@render children()}...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a @render tag for the page content. For example, let's add a nav bar:<!--- file: src/routes/+layout.svelte --->\n<script>\n\tlet { children } = $props();\n</script>\n\n<nav>\n\t<a href=\"/\">Home</a>\n\t<a href=\"/about\">About</a>\n\t<a href=\"/settings\">Settings</a>\n</nav>\n\n{@render children()}If we create pages for /, /about and /settings... \n<h1>Home</h1> \n<h1>About</h1> \n<h1>Settings</h1>...the nav will always be visible, and clicking between the three pages will only result in the <h1> being replaced.Layouts can be nested. Suppose we don't just have a single /settings page, but instead have nested pages like /settings/profile and /settings/notifications with a shared submenu (for a real-life example, see github.com/settings).We can create a layout that only applies to pages below /settings (while inheriting the root layout with the top-level nav):<!--- file: src/routes/settings/+layout.svelte --->\n<script>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n</script>\n\n<h1>Settings</h1>\n\n<div class=\"submenu\">\n\t{#each data.sections as section}\n\t\t<a href=\"/settings/{section.slug}\">{section.title}</a>\n\t{/each}\n</div>\n\n{@render children()}[!LEGACY]\n`LayoutProps` was added in 2.16.0. In earlier versions, you had to [type the properties manually instead](#\\$types).\nYou can see how data is populated by looking at the +layout.js example in the next section just below.By default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, advanced layouts can help you.",
              "href": "/docs/kit/routing#layout-layout.svelte"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Routing",
                "+server"
              ],
              "content": "As well as pages, you can define routes with a +server.js file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your +server.js file exports functions corresponding to HTTP verbs like GET, POST, PATCH, PUT, DELETE, OPTIONS, and HEAD that take a RequestEvent argument and return a `Response` object.For example we could create an /api/random-number route with a GET handler: \nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\tconst max = Number(url.searchParams.get('max') ?? '1');\n\n\tconst d = max - min;\n\n\tif (isNaN(d) || d < 0) {\n\t\terror(400, 'min and max must be numbers, and min must be less than max');\n\t}\n\n\tconst random = min + Math.random() * d;\n\n\treturn new Response(String(random));\n}The first argument to Response can be a `ReadableStream`, making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).You can use the `error`, `redirect` and `json` methods from @sveltejs/kit for convenience (but you don't have to).If an error is thrown (either error(...) or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via src/error.html — depending on the Accept header. The `+error.svelte` component will not be rendered in this case. You can read more about error handling here.[!NOTE] When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers — these will not be present in production unless you add them.\n[!NOTE] `+layout` files have no effect on `+server.js` files. If you want to run some logic before each request, add it to the server [`handle`](hooks#Server-hooks-handle) hook.",
              "href": "/docs/kit/routing#server"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Routing",
                "+server",
                "Receiving data"
              ],
              "content": "By exporting POST/PUT/PATCH/DELETE/OPTIONS/HEAD handlers, +server.js files can be used to create a complete API:<!--- file: src/routes/add/+page.svelte --->\n<script>\n\tlet a = 0;\n\tlet b = 0;\n\tlet total = 0;\n\n\tasync function add() {\n\t\tconst response = await fetch('/api/add', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ a, b }),\n\t\t\theaders: {\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\ttotal = await response.json();\n\t}\n</script>\n\n<input type=\"number\" bind:value={a}> +\n<input type=\"number\" bind:value={b}> =\n{total}\n\n<button onclick={add}>Calculate</button> \nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}[!NOTE] In general, [form actions](form-actions) are a better way to submit data from the browser to the server.\n[!NOTE] If a `GET` handler is exported, a `HEAD` request will return the `content-length` of the `GET` handler's response body.",
              "href": "/docs/kit/routing#server-Receiving-data"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Routing",
                "$types"
              ],
              "content": "Throughout the examples above, we've been importing types from a $types.d.ts file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.For example, annotating let { data } = $props() with PageProps (or LayoutProps, for a +layout.svelte file) tells TypeScript that the type of data is whatever was returned from load:<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n</script>[!NOTE]\nThe `PageProps` and `LayoutProps` types, added in 2.16.0, are a shortcut for typing the `data` prop as `PageData` or `LayoutData`, as well as other props, such as `form` for pages, or `children` for layouts. In earlier versions, you had to type these properties manually. For example, for a page:\n\n```js\n/// file: +page.svelte\n/** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\nlet { data, form } = $props();\n```\n\nOr, for a layout:\n\n```js\n/// file: +layout.svelte\n/** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\nlet { data, children } = $props();\n```\nIn turn, annotating the load function with PageLoad, PageServerLoad, LayoutLoad or LayoutServerLoad (for +page.js, +page.server.js, +layout.js and +layout.server.js respectively) ensures that params and the return value are correctly typed.If you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types entirely! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool svelte-check.You can read more about omitting $types in our blog post about it.",
              "href": "/docs/kit/routing#$types"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Loading data",
                "Layout data"
              ],
              "content": "Your +layout.svelte files can also load data, via +layout.js or +layout.server.js.import * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}<!--- file: src/routes/blog/[slug]/+layout.svelte --->\n<script>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n</script>\n\n<main>\n\t<!-- +page.svelte is `@render`ed here -->\n\t{@render children()}\n</main>\n\n<aside>\n\t<h2>More posts</h2>\n\t<ul>\n\t\t{#each data.posts as post}\n\t\t\t<li>\n\t\t\t\t<a href=\"/blog/{post.slug}\">\n\t\t\t\t\t{post.title}\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</aside>[!LEGACY]\n`LayoutProps` was added in 2.16.0. In earlier versions, properties had to be typed individually:\n```js\n/// file: +layout.svelte\n/** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\nlet { data, children } = $props();\n```\nData returned from layout load functions is available to child +layout.svelte components and the +page.svelte component as well as the layout that it 'belongs' to. \n<script>\n\t+++import { page } from '$app/state';+++\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\t// we can access `data.posts` because it's returned from\n\t// the parent layout `load` function\n\tlet index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));\n\tlet next = $derived(data.posts[index + 1]);+++\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n+++{#if next}\n\t<p>Next post: <a href=\"/blog/{next.slug}\">{next.title}</a></p>\n{/if}+++[!NOTE] If multiple `load` functions return data with the same key, the last one 'wins' — the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`.",
              "href": "/docs/kit/load#Layout-data"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Loading data",
                "page.data"
              ],
              "content": "The +page.svelte component, and each +layout.svelte component above it, has access to its own data plus all the data from its parents.In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a title property returned from a load function in +page.js or +page.server.js. This can be done with page.data:<!--- file: src/routes/+layout.svelte --->\n<script>\n\timport { page } from '$app/state';\n</script>\n\n<svelte:head>\n\t<title>{page.data.title}</title>\n</svelte:head>Type information for page.data is provided by App.PageData.[!LEGACY]\n`$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\nIt provides a `page` store with the same interface that you can subscribe to, e.g. `$page.data.title`.",
              "href": "/docs/kit/load#page.data"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Loading data",
                "Redirects"
              ],
              "content": "To redirect users, use the redirect helper from @sveltejs/kit to specify the location to which they should be redirected alongside a 3xx status code. Like error(...), calling redirect(...) will throw an exception, making it easy to stop execution from inside helper functions.import { redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}[!NOTE] Don't use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the catch statement.\nIn the browser, you can also navigate programmatically outside of a load function using `goto` from `$app.navigation`.[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `redirect` yourself",
              "href": "/docs/kit/load#Redirects"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Loading data",
                "Streaming with promises"
              ],
              "content": "When using a server load, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\t// make sure the `await` happens at the end, otherwise we\n\t\t// can't start loading comments until we've loaded the post\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}This is useful for creating skeleton loading states, for example:<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n\tLoading comments...\n{:then comments}\n\t{#each comments as comment}\n\t\t<p>{comment.content}</p>\n\t{/each}\n{:catch error}\n\t<p>error loading comments: {error.message}</p>\n{/await}When streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an &quot;unhandled promise rejection&quot; error if a lazy-loaded promise fails before rendering starts (at which point it's caught) and isn't handling the error in some way. When using SvelteKit's fetch directly in the load function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-catch to the promise to mark it as handled. \n/** @type {import('./$types').PageServerLoad} */\nexport function load({ fetch }) {\n\tconst ok_manual = Promise.reject();\n\tok_manual.catch(() => {});\n\n\treturn {\n\t\tok_manual,\n\t\tok_fetch: fetch('/fetch/that/could/fail'),\n\t\tdangerous_unhandled: Promise.reject()\n\t};\n}[!NOTE] On platforms that do not support streaming, such as AWS Lambda or Firebase, responses will be buffered. This means the page will only render once all promises resolve. If you are using a proxy (e.g. NGINX), make sure it does not buffer responses from the proxied server.\n[!NOTE] Streaming data will only work when JavaScript is enabled. You should avoid returning promises from a universal `load` function if the page is server rendered, as these are _not_ streamed — instead, the promise is recreated when the function reruns in the browser.\n[!NOTE] The headers and status code of a response cannot be changed once the response has started streaming, therefore you cannot `setHeaders` or throw redirects inside a streamed promise.\n[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#Top-level-promises-are-no-longer-awaited) top-level promises were automatically awaited, only nested promises were streamed.",
              "href": "/docs/kit/load#Streaming-with-promises"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Loading data",
                "Rerunning load functions",
                "When do load functions rerun?"
              ],
              "content": "To summarize, a load function will rerun in the following situations:undefined\nparams and url can change in response to a <a href=&quot;..&quot;> link click, a `<form>` interaction, a `goto` invocation, or a `redirect`.Note that rerunning a load function will update the data prop inside the corresponding +layout.svelte or +page.svelte; it does not cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an `afterNavigate` callback, and/or wrap your component in a `{#key ...}` block.",
              "href": "/docs/kit/load#Rerunning-load-functions-When-do-load-functions-rerun"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Form actions",
                "Anatomy of an action"
              ],
              "content": "Each action receives a RequestEvent object, allowing you to read the data with request.formData(). After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the form property on the corresponding page and through page.form app-wide until the next update.import * as db from '$lib/server/db';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ cookies }) {\n\tconst user = await db.getUserFromSession(cookies.get('sessionid'));\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};<!--- file: src/routes/login/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data, form } = $props();\n</script>\n\n{#if form?.success}\n\t<!-- this message is ephemeral; it exists because the page was rendered in\n\t       response to a form submission. it will vanish if the user reloads -->\n\t<p>Successfully logged in! Welcome back, {data.user.name}</p>\n{/if}[!LEGACY]\n`PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` and `form` properties individually:\n```js\n/// file: +page.svelte\n/** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\nlet { data, form } = $props();\n```\n\nIn Svelte 4, you'd use `export let data` and `export let form` instead to declare properties.",
              "href": "/docs/kit/form-actions#Anatomy-of-an-action"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Form actions",
                "Anatomy of an action",
                "Validation errors"
              ],
              "content": "If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The fail function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through page.status and the data through form:+++import { fail } from '@sveltejs/kit';+++\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n+++\t\tif (!email) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}+++\n\n\t\tconst user = await db.getUser(email);\n\n+++\t\tif (!user || user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}+++\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};[!NOTE] Note that as a precaution, we only return the email back to the page — not the password.\n \n<form method=\"POST\" action=\"?/login\">\n+++\t{#if form?.missing}<p class=\"error\">The email field is required</p>{/if}\n\t{#if form?.incorrect}<p class=\"error\">Invalid credentials!</p>{/if}+++\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\" +++value={form?.email ?? ''}+++>\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n\t<button formaction=\"?/register\">Register</button>\n</form>The returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which <form> the returned form data referred to with an id property or similar.",
              "href": "/docs/kit/form-actions#Anatomy-of-an-action-Validation-errors"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Form actions",
                "Anatomy of an action",
                "Redirects"
              ],
              "content": "Redirects (and errors) work exactly the same as in `load`:import { fail, +++redirect+++ } from '@sveltejs/kit';\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request, +++url+++ }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tif (!user) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}\n\n\t\tif (user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n+++\t\tif (url.searchParams.has('redirectTo')) {\n\t\t\tredirect(303, url.searchParams.get('redirectTo'));\n\t\t}+++\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};",
              "href": "/docs/kit/form-actions#Anatomy-of-an-action-Redirects"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Form actions",
                "GET vs POST"
              ],
              "content": "As we've seen, to invoke a form action you must use method=&quot;POST&quot;.Some forms don't need to POST data to the server — search inputs, for example. For these you can use method=&quot;GET&quot; (or, equivalently, no method at all), and SvelteKit will treat them like <a> elements, using the client-side router instead of a full page navigation:<form action=\"/search\">\n\t<label>\n\t\tSearch\n\t\t<input name=\"q\">\n\t</label>\n</form>Submitting this form will navigate to /search?q=... and invoke your load function but will not invoke an action. As with <a> elements, you can set the `data-sveltekit-reload`, `data-sveltekit-replacestate`, `data-sveltekit-keepfocus` and `data-sveltekit-noscroll` attributes on the <form> to control the router's behaviour.",
              "href": "/docs/kit/form-actions#GET-vs-POST"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Page options",
                "prerender",
                "Route conflicts"
              ],
              "content": "Because prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, src/routes/foo/+server.js and src/routes/foo/bar/+server.js would try to create foo and foo/bar, which is impossible.For that reason among others, it's recommended that you always include a file extension — src/routes/foo.json/+server.js and src/routes/foo/bar.json/+server.js would result in foo.json and foo/bar.json files living harmoniously side-by-side.For pages, we skirt around this problem by writing foo/index.html instead of foo.",
              "href": "/docs/kit/page-options#prerender-Route-conflicts"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "Page options",
                "trailingSlash"
              ],
              "content": "By default, SvelteKit will remove trailing slashes from URLs — if you visit /about/, it will respond with a redirect to /about. You can change this behaviour with the trailingSlash option, which can be one of 'never' (the default), 'always', or 'ignore'.As with other page options, you can export this value from a +layout.js or a +layout.server.js and it will apply to all child pages. You can also export the configuration from +server.js files. \nexport const trailingSlash = 'always';This option also affects prerendering. If trailingSlash is always, a route like /about will result in an about/index.html file, otherwise it will create about.html, mirroring static webserver conventions.[!NOTE] Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO.",
              "href": "/docs/kit/page-options#trailingSlash"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management"
              ],
              "content": "If you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.",
              "href": "/docs/kit/state-management"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "Avoid shared state on the server"
              ],
              "content": "Browsers are stateful — state is stored in memory as the user interacts with the application. Servers, on the other hand, are stateless — the content of the response is determined entirely by the content of the request.Conceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code: \n \nlet user;\n\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async ({ request }) => {\n\t\tconst data = await request.formData();\n\n\t\t// NEVER DO THIS!\n\t\tuser = {\n\t\t\tname: data.get('name'),\n\t\t\tembarrassingSecret: data.get('secret')\n\t\t};\n\t}\n}The user variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.Instead, you should authenticate the user using `cookies` and persist the data to a database.",
              "href": "/docs/kit/state-management#Avoid-shared-state-on-the-server"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "No side-effects in load"
              ],
              "content": "For the same reason, your load functions should be pure — no side-effects (except maybe the occasional console.log(...)). For example, you might be tempted to write to a store or global state inside a load function so that you can use the value in your components:import { user } from '$lib/user';\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n\t// NEVER DO THIS!\n\tuser.set(await response.json());\n}As with the previous example, this puts one user's information in a place that is shared by all users. Instead, just return the data... \n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n+++\treturn {\n\t\tuser: await response.json()\n\t};+++\n}...and pass it around to the components that need it, or use `page.data`.If you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your load functions — your application will be much easier to reason about without them.",
              "href": "/docs/kit/state-management#No-side-effects-in-load"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "Using state and stores with context"
              ],
              "content": "You might wonder how we're able to use page.data and other app state (or app stores) if we can't use global state. The answer is that app state and app stores on the server use Svelte's context API — the state (or store) is attached to the component tree with setContext, and when you subscribe you retrieve it with getContext. We can do the same thing with our own state:<!--- file: src/routes/+layout.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data } = $props();\n\n\t// Pass a function referencing our state\n\t// to the context for child components to access\n\tsetContext('user', () => data.user);\n</script><!--- file: src/routes/user/+page.svelte --->\n<script>\n\timport { getContext } from 'svelte';\n\n\t// Retrieve user store from context\n\tconst user = getContext('user');\n</script>\n\n<p>Welcome {user().name}</p>[!NOTE] We're passing a function into `setContext` to keep reactivity across boundaries. Read more about it [here](/docs/svelte/$state#Passing-state-into-functions)\n[!LEGACY]\nYou also use stores from `svelte/store` for this, but when using Svelte 5 it is recommended to make use of universal reactivity instead.\nUpdating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values 'flashing' during state updates during hydration, it is generally recommended to pass state down into components rather than up.If you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API.",
              "href": "/docs/kit/state-management#Using-state-and-stores-with-context"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "Component and page state is preserved"
              ],
              "content": "When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\t// THIS CODE IS BUGGY!\n\tconst wordCount = data.content.split(' ').length;\n\tconst estimatedReadingTime = wordCount / 250;\n</script>\n\n<header>\n\t<h1>{data.title}</h1>\n\t<p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>\n</header>\n\n<div>{@html data.content}</div>...then navigating from /blog/my-short-post to /blog/my-long-post won't cause the layout, page and any other components within to be destroyed and recreated. Instead the data prop (and by extension data.title and data.content) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like onMount and onDestroy won't rerun and estimatedReadingTime won't be recalculated.Instead, we need to make the value _reactive_: \n<script>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\tlet wordCount = $derived(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);+++\n</script>[!NOTE] If your code in `onMount` and `onDestroy` has to run again after navigation you can use [afterNavigate]($app-navigation#afterNavigate) and [beforeNavigate]($app-navigation#beforeNavigate) respectively.\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:<script>\n\timport { page } from '$app/state';\n</script>\n\n{#key page.url.pathname}\n\t<BlogPost title={data.title} content={data.title} />\n{/key}",
              "href": "/docs/kit/state-management#Component-and-page-state-is-preserved"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "Storing state in the URL"
              ],
              "content": "If you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like ?sort=price&amp;order=ascending) are a good place to put them. You can put them in <a href=&quot;...&quot;> or <form action=&quot;...&quot;> attributes, or set them programmatically via goto('?key=value'). They can be accessed inside load functions via the url parameter, and inside components via page.url.searchParams.",
              "href": "/docs/kit/state-management#Storing-state-in-the-URL"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Core concepts",
                "State management",
                "Storing ephemeral state in snapshots"
              ],
              "content": "Some UI state, such as 'is the accordion open?', is disposable — if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you do want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides snapshots, which let you associate component state with a history entry.",
              "href": "/docs/kit/state-management#Storing-ephemeral-state-in-snapshots"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Building your app"
              ],
              "content": "Building a SvelteKit app happens in two stages, which both happen when you run vite build (usually via npm run build).Firstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). Prerendering is executed at this stage, if appropriate.Secondly, an adapter takes this production build and tunes it for your target environment — more on this on the following pages.",
              "href": "/docs/kit/building-your-app"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Zero-config deployments"
              ],
              "content": "When you create a new SvelteKit project with npx sv create, it installs `adapter-auto` by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:undefined\nIt's recommended to install the appropriate adapter to your devDependencies once you've settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI.",
              "href": "/docs/kit/adapter-auto"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Node servers",
                "Deploying"
              ],
              "content": "First, build your app with npm run build. This will create the production server in the output directory specified in the adapter options, defaulting to build.You will need the output directory, the project's package.json, and the production dependencies in node_modules to run the application. Production dependencies can be generated by copying the package.json and package-lock.json and then running npm ci --omit dev (you can skip this step if your app doesn't have any dependencies). You can then start your app with this command:node buildDevelopment dependencies will be bundled into your app using Rollup. To control whether a given package is bundled or externalised, place it in devDependencies or dependencies respectively in your package.json.",
              "href": "/docs/kit/adapter-node#Deploying"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Node servers",
                "Options",
                "out"
              ],
              "content": "The directory to build the server to. It defaults to build — i.e. node build would start the server locally after it has been created.",
              "href": "/docs/kit/adapter-node#Options-out"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Node servers",
                "Socket activation"
              ],
              "content": "Most Linux operating systems today use a modern process manager called systemd to start the server and run and manage services. You can configure your server to allocate a socket and start and scale your app on demand. This is called socket activation. In this case, the OS will pass two environment variables to your app — LISTEN_PID and LISTEN_FDS. The adapter will then listen on file descriptor 3 which refers to a systemd socket unit that you will have to create.[!NOTE] You can still use [`envPrefix`](#Options-envPrefix) with systemd socket activation. `LISTEN_PID` and `LISTEN_FDS` are always read without a prefix.\nTo take advantage of socket activation follow these steps.undefined\n \n[Service]\nEnvironment=NODE_ENV=production IDLE_TIMEOUT=60\nExecStart=/usr/bin/node /usr/bin/myapp/buildundefined\n \n[Socket]\nListenStream=3000\n\n[Install]\nWantedBy=sockets.targetundefined",
              "href": "/docs/kit/adapter-node#Socket-activation"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Node servers",
                "Custom server"
              ],
              "content": "The adapter creates two files in your build directory — index.js and handler.js. Running index.js — e.g. node build, if you use the default build directory — will start a server on the configured port.Alternatively, you can import the handler.js file, which exports a handler suitable for use with Express, Connect or Polka (or even just the built-in `http.createServer`) and set up your own server: \n \nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\n\n// add a route that lives separately from the SvelteKit app\napp.get('/healthcheck', (req, res) => {\n\tres.end('ok');\n});\n\n// let SvelteKit handle everything else, including serving prerendered pages and static assets\napp.use(handler);\n\napp.listen(3000, () => {\n\tconsole.log('listening on port 3000');\n});",
              "href": "/docs/kit/adapter-node#Custom-server"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Static site generation",
                "Usage"
              ],
              "content": "Install with npm i -D @sveltejs/adapter-static, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown. On some platforms\n\t\t\t// these options are set automatically — see below\n\t\t\tpages: 'build',\n\t\t\tassets: 'build',\n\t\t\tfallback: undefined,\n\t\t\tprecompress: false,\n\t\t\tstrict: true\n\t\t})\n\t}\n};...and add the `prerender` option to your root layout: \n// This can be false if you're using a fallback (i.e. SPA mode)\nexport const prerender = true;[!NOTE] You must ensure SvelteKit's [`trailingSlash`](page-options#trailingSlash) option is set appropriately for your environment. If your host does not render `/a.html` upon receiving a request for `/a` then you will need to set `trailingSlash: 'always'` in your root layout to create `/a/index.html` instead.",
              "href": "/docs/kit/adapter-static#Usage"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Single-page apps"
              ],
              "content": "You can turn any SvelteKit app, using any adapter, into a fully client-rendered single-page app (SPA) by disabling SSR at the root layout: \nexport const ssr = false;[!NOTE] In most situations this is not recommended: it harms SEO, tends to slow down perceived performance, and makes your app inaccessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).\nIf you don't have any server-side logic (i.e. +page.server.js, +layout.server.js or +server.js files) you can use `adapter-static` to create your SPA by adding a fallback page.",
              "href": "/docs/kit/single-page-apps"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Single-page apps",
                "Usage"
              ],
              "content": "Install with npm i -D @sveltejs/adapter-static, then add the adapter to your svelte.config.js with the following options: \n \nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '200.html' // may differ from host to host\n\t\t})\n\t}\n};The fallback page is an HTML page created by SvelteKit from your page template (e.g. app.html) that loads your app and navigates to the correct route. For example Surge, a static web host, lets you add a 200.html file that will handle any requests that don't correspond to static assets or prerendered pages.On some hosts it may be index.html or something else entirely — consult your platform's documentation.[!NOTE] Note that the fallback page will always contain absolute asset paths (i.e. beginning with `/` rather than `.`) regardless of the value of [`paths.relative`](configuration#paths), since it is used to respond to requests for arbitrary paths.",
              "href": "/docs/kit/single-page-apps#Usage"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Cloudflare Pages",
                "Options",
                "routes"
              ],
              "content": "Only for Cloudflare Pages. Allows you to customise the `_routes.json` file generated by adapter-cloudflare.undefined\nYou can have up to 100 include and exclude rules combined. Generally you can omit the routes options, but if (for example) your <prerendered> paths exceed that limit, you may find it helpful to manually create an exclude list that includes '/articles/*' instead of the auto-generated ['/articles/foo', '/articles/bar', '/articles/baz', ...].",
              "href": "/docs/kit/adapter-cloudflare#Options-routes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Cloudflare Pages",
                "Runtime APIs",
                "Testing locally"
              ],
              "content": "Cloudflare specific values in the platform property are emulated during dev and preview modes. Local bindings are created based on your Wrangler configuration file and are used to populate platform.env during development and preview. Use the adapter config `platformProxy` option to change your preferences for the bindings.For testing the build, you should use Wrangler version 4. Once you have built your site, run wrangler dev .svelte-kit/cloudflare if you're testing for Cloudflare Workers or wrangler pages dev .svelte-kit/cloudflare for Cloudflare Pages.",
              "href": "/docs/kit/adapter-cloudflare#Runtime-APIs-Testing-locally"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Cloudflare Workers",
                "Runtime APIs",
                "Testing Locally"
              ],
              "content": "Cloudflare Workers specific values in the platform property are emulated during dev and preview modes. Local bindings are created based on your Wrangler configuration file and are used to populate platform.env during development and preview. Use the adapter config `platformProxy` option to change your preferences for the bindings.For testing the build, you should use Wrangler version 4. Once you have built your site, run wrangler dev.",
              "href": "/docs/kit/adapter-cloudflare-workers#Runtime-APIs-Testing-Locally"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Netlify",
                "Usage"
              ],
              "content": "Install with npm i -D @sveltejs/adapter-netlify, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\t// default options are shown\n\t\tadapter: adapter({\n\t\t\t// if true, will create a Netlify Edge Function rather\n\t\t\t// than using standard Node-based functions\n\t\t\tedge: false,\n\n\t\t\t// if true, will split your app into multiple functions\n\t\t\t// instead of creating a single one for the entire app.\n\t\t\t// if `edge` is true, this option cannot be used\n\t\t\tsplit: false\n\t\t})\n\t}\n};Then, make sure you have a netlify.toml file in the project root. This will determine where to write static assets based on the build.publish settings, as per this sample configuration:[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"If the netlify.toml file or the build.publish value is missing, a default value of &quot;build&quot; will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in netlify.toml too, or use the default value of &quot;build&quot;.",
              "href": "/docs/kit/adapter-netlify#Usage"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Netlify",
                "Usage",
                "Node version"
              ],
              "content": "New projects will use the current Node LTS version by default. However, if you're upgrading a project you created a while ago it may be stuck on an older version. See the Netlify docs for details on manually specifying a current Node version.",
              "href": "/docs/kit/adapter-netlify#Usage-Node-version"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Netlify",
                "Netlify Edge Functions"
              ],
              "content": "SvelteKit supports Netlify Edge Functions. If you pass the option edge: true to the adapter function, server-side rendering will happen in a Deno-based edge function that's deployed close to the site visitor. If set to false (the default), the site will deploy to Node-based Netlify Functions. \n \nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// will create a Netlify Edge Function using Deno-based\n\t\t\t// rather than using standard Node-based functions\n\t\t\tedge: true\n\t\t})\n\t}\n};",
              "href": "/docs/kit/adapter-netlify#Netlify-Edge-Functions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Netlify",
                "Netlify alternatives to SvelteKit functionality",
                "Redirect rules"
              ],
              "content": "During compilation, redirect rules are automatically appended to your _redirects file. (If it doesn't exist yet, it will be created.) That means:undefined",
              "href": "/docs/kit/adapter-netlify#Netlify-alternatives-to-SvelteKit-functionality-Redirect-rules"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Vercel",
                "Skew protection"
              ],
              "content": "When a new version of your app is deployed, assets belonging to the previous version may no longer be accessible. If a user is actively using your app when this happens, it can cause errors when they navigate — this is known as version skew. SvelteKit mitigates this by detecting errors resulting from version skew and causing a hard reload to get the latest version of the app, but this will cause any client-side state to be lost. (You can also proactively mitigate it by observing the `updated` store value, which tells clients when a new version has been deployed.)Skew protection is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment. (The updated store is exempted from this behaviour, and so will continue to report new deployments.) To enable it, visit the Advanced section of your project settings on Vercel.Cookie-based skew protection comes with one caveat: if a user has multiple versions of your app open in multiple tabs, requests from older versions will be routed to the newer one, meaning they will fall back to SvelteKit's built-in skew protection.",
              "href": "/docs/kit/adapter-vercel#Skew-protection"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Vercel",
                "Notes",
                "Node version"
              ],
              "content": "Projects created before a certain date may default to using an older Node version than what SvelteKit currently requires. You can change the Node version in your project settings.",
              "href": "/docs/kit/adapter-vercel#Notes-Node-version"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Build and deploy",
                "Writing adapters"
              ],
              "content": "If an adapter for your preferred environment doesn't yet exist, you can build your own. We recommend looking at the source for an adapter to a platform similar to yours and copying it as a starting point.Adapter packages implement the following API, which creates an Adapter:/** @param {AdapterSpecificOptions} options */\nexport default function (options) {\n\t/** @type {import('@sveltejs/kit').Adapter} */\n\tconst adapter = {\n\t\tname: 'adapter-package-name',\n\t\tasync adapt(builder) {\n\t\t\t// adapter implementation\n\t\t},\n\t\tasync emulate() {\n\t\t\treturn {\n\t\t\t\tasync platform({ config, prerender }) {\n\t\t\t\t\t// the returned object becomes `event.platform` during dev, build and\n\t\t\t\t\t// preview. Its shape is that of `App.Platform`\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsupports: {\n\t\t\tread: ({ config, route }) => {\n\t\t\t\t// Return `true` if the route with the given `config` can use `read`\n\t\t\t\t// from `$app/server` in production, return `false` if it can't.\n\t\t\t\t// Or throw a descriptive error describing how to configure the deployment\n\t\t\t}\n\t\t}\n\t};\n\n\treturn adapter;\n}Of these, name and adapt are required. emulate and supports are optional.Within the adapt method, there are a number of things that an adapter should do:undefined\nWhere possible, we recommend putting the adapter output under the build/ directory with any intermediate output placed under .svelte-kit/[adapter-name].",
              "href": "/docs/kit/writing-adapters"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Advanced routing",
                "Rest parameters",
                "404 pages"
              ],
              "content": "Rest parameters also allow you to render custom 404s. Given these routes...src/routes/\n├ marx-brothers/\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte...the marx-brothers/+error.svelte file will not be rendered if you visit /marx-brothers/karl, because no route was matched. If you want to render the nested error page, you should create a route that matches any /marx-brothers/* request, and return a 404 from it:src/routes/\n├ marx-brothers/\n+++| ├ [...path]/+++\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte \nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\terror(404, 'Not Found');\n}[!NOTE] If you don't handle 404 cases, they will appear in [`handleError`](hooks#Shared-hooks-handleError)",
              "href": "/docs/kit/advanced-routing#Rest-parameters-404-pages"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Advanced routing",
                "Encoding"
              ],
              "content": "Some characters can't be used on the filesystem — / on Linux and Mac, \\ / : * ? &quot; < > | on Windows. The # and % characters have special meaning in URLs, and the [ ] ( ) characters have special meaning to SvelteKit, so these also can't be used directly as part of your route.To use these characters in your routes, you can use hexadecimal escape sequences, which have the format [x+nn] where nn is a hexadecimal character code:undefined\nFor example, to create a /smileys/:-) route, you would create a src/routes/smileys/[x+3a]-[x+29]/+page.svelte file.You can determine the hexadecimal code for a character with JavaScript:':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'You can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if — for some reason — you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:src/routes/[u+d83e][u+dd2a]/+page.svelte\nsrc/routes/🤪/+page.svelteThe format for a Unicode escape sequence is [u+nnnn] where nnnn is a valid value between 0000 and 10ffff. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above ffff.) To learn more about Unicode encodings, consult Programming with Unicode.[!NOTE] Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`",
              "href": "/docs/kit/advanced-routing#Encoding"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Advanced routing",
                "Advanced layouts",
                "When to use layout groups"
              ],
              "content": "Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex (group) nesting, or that you don't want to introduce a (group) for a single outlier. It's perfectly fine to use other means such as composition (reusable load functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:<!--- file: src/routes/nested/route/+layout@.svelte --->\n<script>\n\timport ReusableLayout from '$lib/ReusableLayout.svelte';\n\tlet { data, children } = $props();\n</script>\n\n<ReusableLayout {data}>\n\t{@render children()}\n</ReusableLayout>import { reusableLoad } from '$lib/reusable-load-function';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\t// Add additional logic here, if needed\n\treturn reusableLoad(event);\n}",
              "href": "/docs/kit/advanced-routing#Advanced-layouts-When-to-use-layout-groups"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Hooks",
                "Shared hooks",
                "init"
              ],
              "content": "This function runs once, when the server is created or the app starts in the browser, and is a useful place to do asynchronous work such as initializing a database connection.[!NOTE] If your environment supports top-level await, the `init` function is really no different from writing your initialisation logic at the top level of the module, but some environments — most notably, Safari — don't.\n \nimport * as db from '$lib/server/database';\n\n/** @type {import('@sveltejs/kit').ServerInit} */\nexport async function init() {\n\tawait db.connect();\n}[!NOTE]\nIn the browser, asynchronous work in `init` will delay hydration, so be mindful of what you put in there.",
              "href": "/docs/kit/hooks#Shared-hooks-init"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Errors",
                "Expected errors"
              ],
              "content": "An expected error is one created with the `error` helper imported from @sveltejs/kit:import { error } from '@sveltejs/kit';\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await db.getPost(params.slug);\n\n\tif (!post) {\n\t\terror(404, {\n\t\t\tmessage: 'Not found'\n\t\t});\n\t}\n\n\treturn { post };\n}This throws an exception that SvelteKit catches, causing it to set the response status code to 404 and render an `+error.svelte` component, where page.error is the object provided as the second argument to error(...).<!--- file: src/routes/+error.svelte --->\n<script>\n\timport { page } from '$app/state';\n</script>\n\n<h1>{page.error.message}</h1>[!LEGACY]\n`$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\nYou can add extra properties to the error object if needed...error(404, {\n\tmessage: 'Not found',\n\t+++code: 'NOT_FOUND'+++\n});...otherwise, for convenience, you can pass a string as the second argument:---error(404, { message: 'Not found' });---\n+++error(404, 'Not found');+++[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `error` yourself",
              "href": "/docs/kit/errors#Expected-errors"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Link options",
                "data-sveltekit-replacestate"
              ],
              "content": "Sometimes you don't want navigation to create a new entry in the browser's session history. Adding a data-sveltekit-replacestate attribute to a link...<a data-sveltekit-replacestate href=\"/path\">Path</a>...will replace the current history entry rather than creating a new one with pushState when the link is clicked.",
              "href": "/docs/kit/link-options#data-sveltekit-replacestate"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Snapshots"
              ],
              "content": "Ephemeral DOM state — like scroll positions on sidebars, the content of <input> elements and so on — is discarded when you navigate from one page to another.For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a snapshot of DOM state, which can then be restored if the user navigates back.To do this, export a snapshot object with capture and restore methods from a +page.svelte or +layout.svelte:<!--- file: +page.svelte --->\n<script>\n\tlet comment = $state('');\n\n\t/** @type {import('./$types').Snapshot<string>} */\n\texport const snapshot = {\n\t\tcapture: () => comment,\n\t\trestore: (value) => comment = value\n\t};\n</script>\n\n<form method=\"POST\">\n\t<label for=\"comment\">Comment</label>\n\t<textarea id=\"comment\" bind:value={comment} />\n\t<button>Post comment</button>\n</form>When you navigate away from this page, the capture function is called immediately before the page updates, and the returned value is associated with the current entry in the browser's history stack. If you navigate back, the restore function is called with the stored value as soon as the page is updated.The data must be serializable as JSON so that it can be persisted to sessionStorage. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.[!NOTE] Avoid returning very large objects from `capture` — once captured, objects will be retained in memory for the duration of the session, and in extreme cases may be too large to persist to `sessionStorage`.",
              "href": "/docs/kit/snapshots"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Shallow routing"
              ],
              "content": "As you navigate around a SvelteKit app, you create history entries. Clicking the back and forward buttons traverses through this list of entries, re-running any load functions and replacing page components as necessary.Sometimes, it's useful to create history entries without navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is not associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page.SvelteKit makes this possible with the `pushState` and `replaceState` functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:<!--- file: +page.svelte --->\n<script>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\n\tfunction showModal() {\n\t\tpushState('', {\n\t\t\tshowModal: true\n\t\t});\n\t}\n</script>\n\n{#if page.state.showModal}\n\t<Modal close={() => history.back()} />\n{/if}The modal can be dismissed by navigating back (unsetting page.state.showModal) or by interacting with it in a way that causes the close callback to run, which will navigate back programmatically.",
              "href": "/docs/kit/shallow-routing"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Shallow routing",
                "API"
              ],
              "content": "The first argument to pushState is the URL, relative to the current URL. To stay on the current URL, use ''.The second argument is the new page state, which can be accessed via the page object as page.state. You can make page state type-safe by declaring an `App.PageState` interface (usually in src/app.d.ts).To set page state without creating a new history entry, use replaceState instead of pushState.[!LEGACY]\n`page.state` from `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$page.state` from `$app/stores` instead.",
              "href": "/docs/kit/shallow-routing#API"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Shallow routing",
                "Loading data for a route"
              ],
              "content": "When shallow routing, you may want to render another +page.svelte inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page.For this to work, you need to load the data that the +page.svelte expects. A convenient way to do this is to use `preloadData` inside the click handler of an <a> element. If the element (or a parent) uses `data-sveltekit-preload-data`, the data will have already been requested, and preloadData will reuse that request.<!--- file: src/routes/photos/+page.svelte --->\n<script>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\timport PhotoPage from './[id]/+page.svelte';\n\n\tlet { data } = $props();\n</script>\n\n{#each data.thumbnails as thumbnail}\n\t<a\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\tonclick={async (e) => {\n\t\t\tif (innerWidth < 640        // bail if the screen is too small\n\t\t\t\t|| e.shiftKey             // or the link is opened in a new window\n\t\t\t\t|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n\t\t\t\t// should also consider clicking with a mouse scroll wheel\n\t\t\t) return;\n\n\t\t\t// prevent navigation\n\t\t\te.preventDefault();\n\n\t\t\tconst { href } = e.currentTarget;\n\n\t\t\t// run `load` functions (or rather, get the result of the `load` functions\n\t\t\t// that are already running because of `data-sveltekit-preload-data`)\n\t\t\tconst result = await preloadData(href);\n\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\t// something bad happened! try navigating\n\t\t\t\tgoto(href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t<img alt={thumbnail.alt} src={thumbnail.src} />\n\t</a>\n{/each}\n\n{#if page.state.selected}\n\t<Modal onclose={() => history.back()}>\n\t\t<!-- pass page data to the +page.svelte component,\n\t\t     just like SvelteKit would on navigation -->\n\t\t<PhotoPage data={page.state.selected} />\n\t</Modal>\n{/if}",
              "href": "/docs/kit/shallow-routing#Loading-data-for-a-route"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Shallow routing",
                "Caveats"
              ],
              "content": "During server-side rendering, page.state is always an empty object. The same is true for the first page the user lands on — if the user reloads the page (or returns from another document), state will not be applied until they navigate.Shallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn't available.",
              "href": "/docs/kit/shallow-routing#Caveats"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging"
              ],
              "content": "You can use SvelteKit to build apps as well as component libraries, using the @sveltejs/package package (npx sv create has an option to set this up for you).When you're creating an app, the contents of src/routes is the public-facing stuff; `src/lib` contains your app's internal library.A component library has the exact same structure as a SvelteKit app, except that src/lib is the public-facing bit, and your root package.json is used to publish the package. src/routes might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.Running the svelte-package command from @sveltejs/package will take the contents of src/lib and generate a dist directory (which can be configured) containing the following:undefined\n[!NOTE] `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you're still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions.",
              "href": "/docs/kit/packaging"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging",
                "Anatomy of a package.json",
                "exports"
              ],
              "content": "The &quot;exports&quot; field contains the package's entry points. If you set up a new library project through npx sv create, it's set to a single export, the package root:{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n\t\t\t\"svelte\": \"./dist/index.js\"\n\t\t}\n\t}\n}This tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this: \nimport { Something } from 'your-library';The types and svelte keys are export conditions. They tell tooling what file to import when they look up the your-library import:undefined\n[!NOTE] Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.\nYou can adjust exports to your liking and provide more entry points. For example, if instead of a src/lib/index.js file that re-exported components you wanted to expose a src/lib/Foo.svelte component directly, you could create the following export map...{\n\t\"exports\": {\n\t\t\"./Foo.svelte\": {\n\t\t\t\"types\": \"./dist/Foo.svelte.d.ts\",\n\t\t\t\"svelte\": \"./dist/Foo.svelte\"\n\t\t}\n\t}\n}...and a consumer of your library could import the component like so:import Foo from 'your-library/Foo.svelte';[!NOTE] Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#TypeScript)\nIn general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.Read more about exports here.",
              "href": "/docs/kit/packaging#Anatomy-of-a-package.json-exports"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging",
                "Anatomy of a package.json",
                "sideEffects"
              ],
              "content": "The sideEffects field in package.json is used by bundlers to determine if a module may contain code that has side effects. A module is considered to have side effects if it makes changes that are observable from other scripts outside the module when it's imported. For example, side effects include modifying global variables or the prototype of built-in JavaScript objects. Because a side effect could potentially affect the behavior of other parts of the application, these files/modules will be included in the final bundle regardless of whether their exports are used in the application. It is a best practice to avoid side effects in your code.Setting the sideEffects field in package.json can help the bundler to be more aggressive in eliminating unused exports from the final bundle, a process known as tree-shaking. This results in smaller and more efficient bundles. Different bundlers handle sideEffects in various manners. While not necessary for Vite, we recommend that libraries state that all CSS files have side effects so that your library will be compatible with webpack. This is the configuration that comes with newly created projects: \n{\n\t\"sideEffects\": [\"**/*.css\"]\n}If the scripts in your library have side effects, ensure that you update the `sideEffects` field. All scripts are marked as side effect free by default in newly created projects. If a file with side effects is incorrectly marked as having no side effects, it can result in broken functionality.\nIf your package has files with side effects, you can specify them in an array: \n{\n    \"sideEffects\": [\n    \t\"**/*.css\",\n    \t\"./dist/sideEffectfulFile.js\"\n    ]\n}This will treat only the specified files as having side effects.",
              "href": "/docs/kit/packaging#Anatomy-of-a-package.json-sideEffects"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging",
                "TypeScript"
              ],
              "content": "You should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. @sveltejs/package makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the types condition in the exports map points to the correct files. When initialising a library project through npx sv create, this is automatically setup for the root export.If you have something else than a root export however — for example providing a your-library/foo import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will not resolve the types condition for an export like { &quot;./foo&quot;: { &quot;types&quot;: &quot;./dist/foo.d.ts&quot;, ... }}. Instead, it will search for a foo.d.ts relative to the root of your library (i.e. your-library/foo.d.ts instead of your-library/dist/foo.d.ts). To fix this, you have two options:The first option is to require people using your library to set the moduleResolution option in their tsconfig.json (or jsconfig.json) to bundler (available since TypeScript 5, the best and recommended option in the future), node16 or nodenext. This opts TypeScript into actually looking at the exports map and resolving the types correctly.The second option is to (ab)use the typesVersions feature from TypeScript to wire up the types. This is a field inside package.json TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned foo export above, the corresponding typesVersions looks like this:{\n\t\"exports\": {\n\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\"\n\t\t}\n\t},\n\t\"typesVersions\": {\n\t\t\">4.0\": {\n\t\t\t\"foo\": [\"./dist/foo.d.ts\"]\n\t\t}\n\t}\n}>4.0 tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for your-library/foo are found within ./dist/foo.d.ts, which essentially replicates the exports condition. You also have * as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into typesVersions you have to declare all type imports through it, including the root import (which is defined as &quot;index.d.ts&quot;: [..]).You can read more about that feature here.",
              "href": "/docs/kit/packaging#TypeScript"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging",
                "Best practices"
              ],
              "content": "You should avoid using SvelteKit-specific modules like $app/environment in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using import { browser } from '$app/environment' you could use import { BROWSER } from 'esm-env' (see esm-env docs). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on $app/state, $app/navigation, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.Ensure that you add aliases via svelte.config.js (not vite.config.js or tsconfig.json), so that they are processed by svelte-package.You should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from exports or any export conditions inside them from your existing library, that should be regarded as a breaking change.{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n// changing `svelte` to `default` is a breaking change:\n---\t\t\t\"svelte\": \"./dist/index.js\"---\n+++\t\t\t\"default\": \"./dist/index.js\"+++\n\t\t},\n// removing this is a breaking change:\n---\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\",\n\t\t\t\"default\": \"./dist/foo.js\"\n\t\t},---\n// adding this is ok:\n+++\t\t\"./bar\": {\n\t\t\t\"types\": \"./dist/bar.d.ts\",\n\t\t\t\"svelte\": \"./dist/bar.js\",\n\t\t\t\"default\": \"./dist/bar.js\"\n\t\t}+++\n\t}\n}",
              "href": "/docs/kit/packaging#Best-practices"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Advanced",
                "Packaging",
                "Source maps"
              ],
              "content": "You can create so-called declaration maps (d.ts.map files) by setting &quot;declarationMap&quot;: true in your tsconfig.json. This will allow editors such as VS Code to go to the original .ts or .svelte file when using features like Go to Definition. This means you also need to publish your source files alongside your dist folder in a way that the relative path inside the declaration files leads to a file on disk. Assuming that you have all your library code inside src/lib as suggested by Svelte's CLI, this is as simple as adding src/lib to files in your package.json:{\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"!dist/**/*.test.*\",\n\t\t\"!dist/**/*.spec.*\",\n\t\t+++\"src/lib\",\n\t\t\"!src/lib/**/*.test.*\",\n\t\t\"!src/lib/**/*.spec.*\"+++\n\t]\n}",
              "href": "/docs/kit/packaging#Source-maps"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "Auth",
                "Guides"
              ],
              "content": "Lucia is a good reference for session-based web app auth. It contains example code snippets and projects for implementing session-based auth within SvelteKit and other JS projects. You can add code which follows the Lucia guide to your project with npx sv create when creating a new project or npx sv add lucia for an existing project.An auth system is tightly coupled to a web framework because most of the code lies in validating user input, handling errors, and directing users to the appropriate next page. As a result, many of the generic JS auth libraries include one or more web frameworks within them. For this reason, many users will find it preferrable to follow a SvelteKit-specific guide such as the examples found in Lucia rather than having multiple web frameworks inside their project.",
              "href": "/docs/kit/auth#Guides"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "Performance",
                "Navigation",
                "Preloading"
              ],
              "content": "You can speed up client-side navigations by eagerly preloading the necessary code and data, using link options. This is configured by default on the <body> element when you create a new SvelteKit app.",
              "href": "/docs/kit/performance#Navigation-Preloading"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "Performance",
                "Hosting"
              ],
              "content": "Your frontend should be located in the same data center as your backend to minimize latency. For sites with no central backend, many SvelteKit adapters support deploying to the edge, which means handling each user's requests from a nearby server. This can reduce load times significantly. Some adapters even support configuring deployment on a per-route basis. You should also consider serving images from a CDN (which are typically edge networks) — the hosts for many SvelteKit adapters will do this automatically.Ensure your host uses HTTP/2 or newer. Vite's code splitting creates numerous small files for improved cacheability, which results in excellent performance, but this does assume that your files can be loaded in parallel with HTTP/2.",
              "href": "/docs/kit/performance#Hosting"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "Images",
                "@sveltejs/enhanced-img"
              ],
              "content": "@sveltejs/enhanced-img is a plugin offered on top of Vite's built-in asset handling. It provides plug and play image processing that serves smaller file formats like avif or webp, automatically sets the intrinsic width and height of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects.[!NOTE] As a build plugin, `@sveltejs/enhanced-img` can only optimize files located on your machine during the build process. If you have an image located elsewhere (such as a path served from your database, CMS, or backend), please read about [loading images dynamically from a CDN](#Loading-images-dynamically-from-a-CDN).\n\n**WARNING**: The `@sveltejs/enhanced-img` package is experimental. It uses pre-1.0 versioning and may introduce breaking changes with every minor version release.",
              "href": "/docs/kit/images#sveltejs-enhanced-img"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "Images",
                "@sveltejs/enhanced-img",
                "Dynamically choosing an image"
              ],
              "content": "You can also manually import an image asset and pass it to an <enhanced:img>. This is useful when you have a collection of static images and would like to dynamically choose one or iterate over them. In this case you will need to update both the import statement and <img> element as shown below to indicate you'd like process them.<script>\n\timport MyImage from './path/to/your/image.jpg?enhanced';\n</script>\n\n<enhanced:img src={MyImage} alt=\"some alt text\" />You can also use Vite's `import.meta.glob`. Note that you will have to specify enhanced via a custom query:<script>\n\tconst imageModules = import.meta.glob(\n\t\t'/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',\n\t\t{\n\t\t\teager: true,\n\t\t\tquery: {\n\t\t\t\tenhanced: true\n\t\t\t}\n\t\t}\n\t)\n</script>\n\n{#each Object.entries(imageModules) as [_path, module]}\n\t<enhanced:img src={module.default} alt=\"some alt text\" />\n{/each}",
              "href": "/docs/kit/images#sveltejs-enhanced-img-Dynamically-choosing-an-image"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "SEO"
              ],
              "content": "The most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well.",
              "href": "/docs/kit/seo"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "SEO",
                "Manual setup",
                "&lt;title&gt; and &lt;meta&gt;"
              ],
              "content": "Every page should have well-written and unique <title> and <meta name=&quot;description&quot;> elements inside a `<svelte:head>`. Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's Lighthouse SEO audits documentation.[!NOTE] A common pattern is to return SEO-related `data` from page [`load`](load) functions, then use it (as [`page.data`]($app-state)) in a `<svelte:head>` in your root [layout](routing#layout).",
              "href": "/docs/kit/seo#Manual-setup-title-and-meta"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "SEO",
                "Manual setup",
                "Sitemaps"
              ],
              "content": "Sitemaps help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint: \nexport async function GET() {\n\treturn new Response(\n\t\t`\n\t\t<?xml version=\"0\" encoding=\"UTF-8\" ?>\n\t\t<urlset\n\t\t\txmlns=\"https://www.sitemaps.org/schemas/sitemap/0.9\"\n\t\t\txmlns:xhtml=\"https://www.w3.org/1999/xhtml\"\n\t\t\txmlns:mobile=\"https://www.google.com/schemas/sitemap-mobile/1.0\"\n\t\t\txmlns:news=\"https://www.google.com/schemas/sitemap-news/0.9\"\n\t\t\txmlns:image=\"https://www.google.com/schemas/sitemap-image/1.1\"\n\t\t\txmlns:video=\"https://www.google.com/schemas/sitemap-video/1.1\"\n\t\t>\n\t\t\t<!-- <url> elements go here -->\n\t\t</urlset>`.trim(),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/xml'\n\t\t\t}\n\t\t}\n\t);\n}",
              "href": "/docs/kit/seo#Manual-setup-Sitemaps"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Best practices",
                "SEO",
                "Manual setup",
                "AMP"
              ],
              "content": "An unfortunate reality of modern web development is that it is sometimes necessary to create an Accelerated Mobile Pages (AMP) version of your site. In SvelteKit this can be done by setting the `inlineStyleThreshold` option... \n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\t// since <link rel=\"stylesheet\"> isn't\n\t\t// allowed, inline all styles\n\t\tinlineStyleThreshold: Infinity\n\t}\n};\n\nexport default config;...disabling csr in your root +layout.js/+layout.server.js... \nexport const csr = false;...adding amp to your app.html<html amp>\n......and transforming the HTML using transformPageChunk along with transform imported from @sveltejs/amp: \nimport * as amp from '@sveltejs/amp';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\t\t\tif (done) return amp.transform(buffer);\n\t\t}\n\t});\n}To prevent shipping any unused CSS as a result of transforming the page to amp, we can use `dropcss`: \n \nimport * as amp from '@sveltejs/amp';\nimport dropcss from 'dropcss';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\n\t\t\tif (done) {\n\t\t\t\tlet css = '';\n\t\t\t\tconst markup = amp\n\t\t\t\t\t.transform(buffer)\n\t\t\t\t\t.replace('⚡', 'amp') // dropcss can't handle this character\n\t\t\t\t\t.replace(/<style amp-custom([^>]*?)>([^]+?)<\\/style>/, (match, attributes, contents) => {\n\t\t\t\t\t\tcss = contents;\n\t\t\t\t\t\treturn `<style amp-custom${attributes}></style>`;\n\t\t\t\t\t});\n\n\t\t\t\tcss = dropcss({ css, html: markup }).css;\n\t\t\t\treturn markup.replace('</style>', `${css}</style>`);\n\t\t\t}\n\t\t}\n\t});\n}\n[!NOTE] It's a good idea to use the `handle` hook to validate the transformed HTML using `amphtml-validator`, but only if you're prerendering pages since it's very slow.",
              "href": "/docs/kit/seo#Manual-setup-AMP"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Frequently asked questions",
                "How do I set up a database?"
              ],
              "content": "Put the code to query your database in a server route - don't query the database in .svelte files. You can create a db.js or similar that sets up a connection immediately and makes the client accessible throughout the app as a singleton. You can execute any one-time setup code in hooks.server.js and import your database helpers into any endpoint that needs them.You can use the Svelte CLI to automatically set up database integrations.",
              "href": "/docs/kit/faq#How-do-I-set-up-a-database"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Frequently asked questions",
                "How do I use Yarn?",
                "How do I use with Yarn 3?"
              ],
              "content": "Currently ESM Support within the latest Yarn (version 3) is considered experimental.The below seems to work although your results may vary.First create a new application:yarn create svelte myapp\ncd myappAnd enable Yarn Berry:yarn set version berry\nyarn install",
              "href": "/docs/kit/faq#How-do-I-use-Yarn-How-do-I-use-with-Yarn-3"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Migrating to SvelteKit v2",
                "goto(...) changes"
              ],
              "content": "goto(...) no longer accepts external URLs. To navigate to an external URL, use window.location.href = url. The state object now determines $page.state and must adhere to the App.PageState interface, if declared. See shallow routing for more details.",
              "href": "/docs/kit/migrating-to-sveltekit-2#goto()-changes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Migrating to SvelteKit v2",
                "Generated `tsconfig.json` is more strict"
              ],
              "content": "Previously, the generated tsconfig.json was trying its best to still produce a somewhat valid config when your tsconfig.json included paths or baseUrl. In SvelteKit 2, the validation is more strict and will warn when you use either paths or baseUrl in your tsconfig.json. These settings are used to generate path aliases and you should use the `alias` config option in your svelte.config.js instead, to also create a corresponding alias for the bundler.",
              "href": "/docs/kit/migrating-to-sveltekit-2#Generated-tsconfig.json-is-more-strict"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Migrating to SvelteKit v2",
                "SvelteKit 2.12: $app/stores deprecated"
              ],
              "content": "SvelteKit 2.12 introduced $app/state based on the Svelte 5 runes API. $app/state provides everything that $app/stores provides but with more flexibility as to where and how you use it. Most importantly, the page object is now fine-grained, e.g. updates to page.state will not invalidate page.data and vice-versa.As a consequence, $app/stores is deprecated and subject to be removed in SvelteKit 3. We recommend upgrading to Svelte 5, if you haven't already, and then migrate away from $app/stores. Most of the replacements should be pretty simple: Replace the $app/stores import with $app/state and remove the $ prefixes from the usage sites.<script>\n\t---import { page } from '$app/stores';---\n\t+++import { page } from '$app/state';+++\n</script>\n\n---{$page.data}---\n+++{page.data}+++Use npx sv migrate app-state to auto-migrate most of your $app/stores usages inside .svelte components.",
              "href": "/docs/kit/migrating-to-sveltekit-2#SvelteKit-2.12:-$app-stores-deprecated"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Migrating from Sapper",
                "Pages and layouts",
                "Stores"
              ],
              "content": "In Sapper, you would get references to provided stores like so:import { stores } from '@sapper/app';\nconst { preloading, page, session } = stores();The page store still exists; preloading has been replaced with a navigating store that contains from and to properties. page now has url and params properties, but no path or query.You access them differently in SvelteKit. stores is now getStores, but in most cases it is unnecessary since you can import navigating, and page directly from `$app/stores`. If you're on Svelte 5 and SvelteKit 2.12 or higher, consider using `$app/state` instead.",
              "href": "/docs/kit/migrating#Pages-and-layouts-Stores"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Appendix",
                "Glossary",
                "Hydration"
              ],
              "content": "Svelte components store some state and update the DOM when the state is updated. When fetching data during SSR, by default SvelteKit will store this data and transmit it to the client along with the server-rendered HTML. The components can then be initialized on the client with that data without having to call the same API endpoints again. Svelte will then check that the DOM is in the expected state and attach event listeners in a process called hydration. Once the components are fully hydrated, they can react to changes to their properties just like any newly created Svelte component.In SvelteKit, pages will be hydrated by default, but you can turn off JavaScript with the `csr = false` page option.",
              "href": "/docs/kit/glossary#Hydration"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit",
                "Builder"
              ],
              "content": "This object is passed to the adapt function of adapters.\nIt contains various methods and properties that are useful for adapting the app.\ninterface Builder {/*…*/}\nlog: Logger;\nPrint messages to the console. log.info and log.minor are silent unless Vite's logLevel is info.\n\nrimraf: (dir: string) => void;\nRemove dir and all its contents.\n\nmkdirp: (dir: string) => void;\nCreate dir and any required parent directories.\n\nconfig: ValidatedConfig;\nThe fully resolved svelte.config.js.\n\nprerendered: Prerendered;\nInformation about prerendered pages and assets, if any.\n\nroutes: RouteDefinition[];\nAn array of all routes (including prerendered)\n\ncreateEntries: (fn: (route: RouteDefinition) => AdapterEntry) => Promise<void>;\n\nundefined\n\nCreate separate functions that map to one or more routes of your app.\n\nfindServerAssets: (routes: RouteDefinition[]) => string[];\nFind all the assets imported by server files belonging to routes\n\ngenerateFallback: (dest: string) => Promise<void>;\nGenerate a fallback page for a static webserver to use when no route is matched. Useful for single-page apps.\n\ngenerateEnvModule: () => void;\nGenerate a module exposing build-time environment variables as $env/dynamic/public.\n\ngenerateManifest: (opts: { relativePath: string; routes?: RouteDefinition[] }) => string;\n\nundefined\n\nGenerate a server-side manifest to initialise the SvelteKit server with.\n\ngetBuildDirectory: (name: string) => string;\n\nundefined\n\nResolve a path to the name directory inside outDir, e.g. /path/to/.svelte-kit/my-adapter.\n\ngetClientDirectory: () => string;\nGet the fully resolved path to the directory containing client-side assets, including the contents of your static directory.\n\ngetServerDirectory: () => string;\nGet the fully resolved path to the directory containing server-side code.\n\ngetAppPath: () => string;\nGet the application path including any configured base path, e.g. my-base-path/_app.\n\nwriteClient: (dest: string) => string[];\n\nundefined\n\nWrite client assets to dest.\n\nwritePrerendered: (dest: string) => string[];\n\nundefined\n\nWrite prerendered files to dest.\n\nwriteServer: (dest: string) => string[];\n\nundefined\n\nWrite server-side code to dest.\n\ncopy: (\n\tfrom: string,\n\tto: string,\n\topts?: {\n\t\tfilter?(basename: string): boolean;\n\t\treplace?: Record<string, string>;\n\t}\n) => string[];\n\nundefined\n\nCopy a file or directory.\n\ncompress: (directory: string) => Promise<void>;\n\nundefined\n\nCompress files in directory with gzip and brotli, where appropriate. Generates .gz and .br files alongside the originals.",
              "href": "/docs/kit/@sveltejs-kit#Builder"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit",
                "NavigationType"
              ],
              "content": "undefined\n\ntype NavigationType =\n\t| 'enter'\n\t| 'form'\n\t| 'leave'\n\t| 'link'\n\t| 'goto'\n\t| 'popstate';",
              "href": "/docs/kit/@sveltejs-kit#NavigationType"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit",
                "Page"
              ],
              "content": "The shape of the `page` reactive object and the `$page` store.\ninterface Page<\n\tParams extends Record<string, string> = Record<\n\t\tstring,\n\t\tstring\n\t>,\n\tRouteId extends string | null = string | null\n> {/*…*/}\nurl: URL;\nThe URL of the current page.\n\nparams: Params;\nThe parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object.\n\nroute: {/*…*/}\nInfo about the current route.\nid: RouteId;\nThe ID of the current route - e.g. for src/routes/blog/[slug], it would be /blog/[slug]. It is null when no route is matched.\n\n\nstatus: number;\nHTTP status code of the current page.\n\nerror: App.Error | null;\nThe error object of the current page, if any. Filled from the handleError hooks.\n\ndata: App.PageData & Record<string, any>;\nThe merged result of all data from all load functions on the current page. You can type a common denominator through App.PageData.\n\nstate: App.PageState;\nThe page state, which can be manipulated using the `pushState` and `replaceState` functions from $app/navigation.\n\nform: any;\nFilled only after a form submission. See form actions for more info.",
              "href": "/docs/kit/@sveltejs-kit#Page"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit",
                "AdapterEntry"
              ],
              "content": "interface AdapterEntry {/*…*/}\nid: string;\nA string that uniquely identifies an HTTP service (e.g. serverless function) and is used for deduplication.\nFor example, /foo/a-[b] and /foo/[c] are different routes, but would both\nbe represented in a Netlify _redirects file as /foo/:param, so they share an ID\n\nfilter(route: RouteDefinition): boolean;\nA function that compares the candidate route with the current route to determine\nif it should be grouped with the current route.Use cases:undefined\n\n\ncomplete(entry: { generateManifest(opts: { relativePath: string }): string }): MaybePromise<void>;\nA function that is invoked once the entry has been created. This is where you\nshould write the function to the filesystem and generate redirect manifests.",
              "href": "/docs/kit/@sveltejs-kit#AdapterEntry"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit/node"
              ],
              "content": "import {\n\tcreateReadableStream,\n\tgetRequest,\n\tsetResponse\n} from '@sveltejs/kit/node';",
              "href": "/docs/kit/@sveltejs-kit-node"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "@sveltejs/kit/node",
                "createReadableStream"
              ],
              "content": "Available since 2.4.0\nConverts a file on disk to a readable stream\nfunction createReadableStream(file: string): ReadableStream;",
              "href": "/docs/kit/@sveltejs-kit-node#createReadableStream"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/navigation",
                "goto"
              ],
              "content": "Allows you to navigate programmatically to a given route, with options such as keeping the current element focused.\nReturns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified url.For external URLs, use window.location = url instead of calling goto(url).\nfunction goto(\n\turl: string | URL,\n\topts?:\n\t\t| {\n\t\t\t\treplaceState?: boolean | undefined;\n\t\t\t\tnoScroll?: boolean | undefined;\n\t\t\t\tkeepFocus?: boolean | undefined;\n\t\t\t\tinvalidateAll?: boolean | undefined;\n\t\t\t\tinvalidate?:\n\t\t\t\t\t| (string | URL | ((url: URL) => boolean))[]\n\t\t\t\t\t| undefined;\n\t\t\t\tstate?: App.PageState | undefined;\n\t\t  }\n\t\t| undefined\n): Promise<void>;",
              "href": "/docs/kit/$app-navigation#goto"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/navigation",
                "invalidate"
              ],
              "content": "Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).\nTo create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.\nThis can be useful if you want to invalidate based on a pattern instead of a exact match.// Example: Match '/path' regardless of the query parameters\nimport { invalidate } from '$app/navigation';\n\ninvalidate((url) => url.pathname === '/path');\nfunction invalidate(\n\tresource: string | URL | ((url: URL) => boolean)\n): Promise<void>;",
              "href": "/docs/kit/$app-navigation#invalidate"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/navigation",
                "pushState"
              ],
              "content": "Programmatically create a new history entry with the given page.state. To use the current URL, you can pass '' as the first argument. Used for shallow routing.\nfunction pushState(\n\turl: string | URL,\n\tstate: App.PageState\n): void;",
              "href": "/docs/kit/$app-navigation#pushState"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/navigation",
                "replaceState"
              ],
              "content": "Programmatically replace the current history entry with the given page.state. To use the current URL, you can pass '' as the first argument. Used for shallow routing.\nfunction replaceState(\n\turl: string | URL,\n\tstate: App.PageState\n): void;",
              "href": "/docs/kit/$app-navigation#replaceState"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/state"
              ],
              "content": "SvelteKit makes three read-only state objects available via the $app/state module — page, navigating and updated.[!NOTE]\nThis module was added in 2.12. If you're using an earlier version of SvelteKit, use [`$app/stores`]($app-stores) instead.\n \nimport { navigating, page, updated } from '$app/state';",
              "href": "/docs/kit/$app-state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/state",
                "navigating"
              ],
              "content": "A read-only object representing an in-progress navigation, with from, to, type and (if type === 'popstate') delta properties.\nValues are null when no navigation is occurring, or during server rendering.\nconst navigating:\n\t| import('@sveltejs/kit').Navigation\n\t| {\n\t\t\tfrom: null;\n\t\t\tto: null;\n\t\t\ttype: null;\n\t\t\twillUnload: null;\n\t\t\tdelta: null;\n\t\t\tcomplete: null;\n\t  };",
              "href": "/docs/kit/$app-state#navigating"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/state",
                "page"
              ],
              "content": "A read-only reactive object with information about the current page, serving several use cases:undefined\n<!--- file: +layout.svelte --->\n<script>\n\timport { page } from '$app/state';\n</script>\n\n<p>Currently at {page.url.pathname}</p>\n\n{#if page.error}\n\t<span class=\"red\">Problem detected</span>\n{:else}\n\t<span class=\"small\">All systems operational</span>\n{/if}Changes to page are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes)<!--- file: +page.svelte --->\n<script>\n\timport { page } from '$app/state';\n\tconst id = $derived(page.params.id); // This will correctly update id for usage on this page\n\t$: badId = page.params.id; // Do not use; will never update after initial load\n</script>On the server, values can only be read during rendering (in other words not in e.g. load functions). In the browser, the values can be read at any time.\nconst page: import('@sveltejs/kit').Page;",
              "href": "/docs/kit/$app-state#page"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/stores"
              ],
              "content": "This module contains store-based equivalents of the exports from `$app/state`. If you're using SvelteKit 2.12 or later, use that module instead. \nimport { getStores, navigating, page, updated } from '$app/stores';",
              "href": "/docs/kit/$app-stores"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/stores",
                "navigating"
              ],
              "content": "Use navigating from $app/state instead (requires Svelte 5, see docs for more info)\nA readable store.\nWhen navigating starts, its value is a Navigation object with from, to, type and (if type === 'popstate') delta properties.\nWhen navigating finishes, its value reverts to null.On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\nconst navigating: import('svelte/store').Readable<\n\timport('@sveltejs/kit').Navigation | null\n>;",
              "href": "/docs/kit/$app-stores#navigating"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/stores",
                "page"
              ],
              "content": "Use page from $app/state instead (requires Svelte 5, see docs for more info)\nA readable store whose value contains page data.On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\nconst page: import('svelte/store').Readable<\n\timport('@sveltejs/kit').Page\n>;",
              "href": "/docs/kit/$app-stores#page"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "$app/stores",
                "updated"
              ],
              "content": "Use updated from $app/state instead (requires Svelte 5, see docs for more info)\nA readable store whose initial value is false. If `version.pollInterval` is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to true when it detects one. updated.check() will force an immediate check, regardless of polling.On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\nconst updated: import('svelte/store').Readable<boolean> & {\n\tcheck(): Promise<boolean>;\n};",
              "href": "/docs/kit/$app-stores#updated"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Configuration",
                "alias"
              ],
              "content": "undefined\n\nAn object containing zero or more aliases used to replace values in import statements. These aliases are automatically passed to Vite and TypeScript. \n \n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\talias: {\n\t\t\t// this will match a file\n\t\t\t'my-file': 'path/to/my-file.js',\n\n\t\t\t// this will match a directory and its contents\n\t\t\t// (`my-directory/x` resolves to `path/to/my-directory/x`)\n\t\t\t'my-directory': 'path/to/my-directory',\n\n\t\t\t// an alias ending /* will only match\n\t\t\t// the contents of a directory, not the directory itself\n\t\t\t'my-directory/*': 'path/to/my-directory/*'\n\t\t}\n\t}\n};[!NOTE] The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.\n[!NOTE] You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.",
              "href": "/docs/kit/configuration#alias"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Configuration",
                "embedded"
              ],
              "content": "undefined\n\nWhether or not the app is embedded inside a larger app. If true, SvelteKit will add its event listeners related to navigation etc on the parent of %sveltekit.body% instead of window, and will pass params from the server rather than inferring them from location.pathname.\nNote that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance).",
              "href": "/docs/kit/configuration#embedded"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Configuration",
                "version"
              ],
              "content": "Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn't, the app's route manifest may point to a JavaScript file that no longer exists.\nSvelteKit helps you solve this problem through version management.\nIf SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the name specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation.\nNot all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the pollInterval and then using beforeNavigate: \n<script>\n\timport { beforeNavigate } from '$app/navigation';\n\timport { updated } from '$app/state';\n\n\tbeforeNavigate(({ willUnload, to }) => {\n\t\tif (updated.current && !willUnload && to?.url) {\n\t\t\tlocation.href = to.url.href;\n\t\t}\n\t});\n</script>If you set pollInterval to a non-zero value, SvelteKit will poll for new versions in the background and set the value of `updated.current` true when it detects one.\n\n \nname?: string;\nThe current app version string. If specified, this must be deterministic (e.g. a commit ref rather than Math.random() or Date.now().toString()), otherwise defaults to a timestamp of the build.For example, to use the current commit hash, you could do use git rev-parse HEAD: \n \nimport * as child_process from 'node:child_process';\n\nexport default {\n\tkit: {\n\t\tversion: {\n\t\t\tname: child_process.execSync('git rev-parse HEAD').toString().trim()\n\t\t}\n\t}\n};\n \npollInterval?: number;\n\nundefined\n\nThe interval in milliseconds to poll for version changes. If this is 0, no polling occurs.",
              "href": "/docs/kit/configuration#version"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Command Line Interface",
                "svelte-kit sync"
              ],
              "content": "svelte-kit sync creates the tsconfig.json and all generated types (which you can import as ./$types inside routing files) for your project. When you create a new project, it is listed as the prepare script and will be run automatically as part of the npm lifecycle, so you should not ordinarily have to run this command.",
              "href": "/docs/kit/cli#svelte-kit-sync"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Types",
                "PageData"
              ],
              "content": "Defines the common shape of the page.data state and $page.data store - that is, the data that is shared between all pages.\nThe Load and ServerLoad functions in ./$types will be narrowed accordingly.\nUse optional properties for data that is only present on specific pages. Do not add an index signature ([key: string]: any).\ninterface PageData {}",
              "href": "/docs/kit/types#PageData"
            },
            {
              "breadcrumbs": [
                "Docs",
                "SvelteKit",
                "Reference",
                "Types",
                "PageState"
              ],
              "content": "The shape of the page.state object, which can be manipulated using the `pushState` and `replaceState` functions from $app/navigation.\ninterface PageState {}",
              "href": "/docs/kit/types#PageState"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Introduction",
                "Getting started"
              ],
              "content": "We recommend using SvelteKit, which lets you build almost anything. It's the official application framework from the Svelte team and powered by Vite. Create a new project with:npx sv create myapp\ncd myapp\nnpm install\nnpm run devDon't worry if you don't know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.",
              "href": "/docs/svelte/getting-started"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Introduction",
                "Getting started",
                "Alternatives to SvelteKit"
              ],
              "content": "You can also use Svelte directly with Vite by running npm create vite@latest and selecting the svelte option. With this, npm run build will generate HTML, JS, and CSS files inside the dist directory using vite-plugin-svelte. In most cases, you will probably need to choose a routing library as well.[!NOTE] Vite is often used in standalone mode to build [single page apps (SPAs)](../kit/glossary#SPA), which you can also [build with SvelteKit](../kit/single-page-apps).\nThere are also plugins for Rollup, Webpack and a few others, but we recommend Vite.",
              "href": "/docs/svelte/getting-started#Alternatives-to-SvelteKit"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Introduction",
                ".svelte files",
                "<script>"
              ],
              "content": "A <script> block contains JavaScript (or TypeScript, when adding the lang=&quot;ts&quot; attribute) that runs when a component instance is created. Variables declared (or imported) at the top level can be referenced in the component's markup.In addition to normal JavaScript, you can use runes to declare component props and add reactivity to your component. Runes are covered in the next section.",
              "href": "/docs/svelte/svelte-files#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Introduction",
                ".svelte files",
                "<script module>"
              ],
              "content": "A <script> tag with a module attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.<script module>\n\tlet total = 0;\n</script>\n\n<script>\n\ttotal += 1;\n\tconsole.log(`instantiated ${total} times`);\n</script>You can export bindings from this block, and they will become exports of the compiled module. You cannot export default, since the default export is the component itself.[!NOTE] If you are using TypeScript and import such exports from a `module` block into a `.ts` file, make sure to have your editor setup so that TypeScript knows about them. This is the case for our VS Code extension and the IntelliJ plugin, but in other cases you might need to setup our [TypeScript editor plugin](https://www.npmjs.com/package/typescript-svelte-plugin).\n[!LEGACY]\nIn Svelte 4, this script tag was created using `<script context=\"module\">`",
              "href": "/docs/svelte/svelte-files#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Introduction",
                ".svelte.js and .svelte.ts files"
              ],
              "content": "Besides .svelte files, Svelte also operates on .svelte.js and .svelte.ts files.These behave like any other .js or .ts module, except that you can use runes. This is useful for creating reusable reactive logic, or sharing reactive state across your app (though note that you cannot export reassigned state).[!LEGACY]\nThis is a concept that didn't exist prior to Svelte 5",
              "href": "/docs/svelte/svelte-js-files"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "What are runes?"
              ],
              "content": "[!NOTE] **rune** /ruːn/ _noun_\n\nA letter or mark used as a mystical or magic symbol.\nRunes are symbols that you use in .svelte and .svelte.js/.svelte.ts files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are keywords.Runes have a $ prefix and look like functions:let message = $state('hello');They differ from normal JavaScript functions in important ways, however:undefined\n[!LEGACY]\nRunes didn't exist prior to Svelte 5.",
              "href": "/docs/svelte/what-are-runes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$state"
              ],
              "content": "The $state rune allows you to create reactive state, which means that your UI reacts when it changes.<script>\n\tlet count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n\tclicks: {count}\n</button>Unlike other frameworks you may have encountered, there is no API for interacting with state — count is just a number, rather than an object or a function, and you can update it like you would update any other variable.Deep state\nIf $state is used with an array or a simple object, the result is a deeply reactive state proxy. Proxies allow Svelte to run code when you read or write properties, including via methods like array.push(...), triggering granular updates.[!NOTE] Classes like `Set` and `Map` will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from [`svelte/reactivity`](./svelte-reactivity).\nState is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...let todos = $state([\n\t{\n\t\tdone: false,\n\t\ttext: 'add more todos'\n\t}\n]);...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:todos[0].done = !todos[0].done;If you push a new object to the array, it will also be proxified:todos.push({\n\tdone: false,\n\ttext: 'eat lunch'\n});[!NOTE] When you update properties of proxies, the original object is _not_ mutated.\nNote that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:let { done, text } = todos[0];\n\n// this will not affect the value of `done`\ntodos[0].done = !todos[0].done;Classes\nYou can also use $state in class fields (whether public or private): \nclass Todo {\n\tdone = $state(false);\n\ttext = $state();\n\n\tconstructor(text) {\n\t\tthis.text = text;\n\t}\n\n\treset() {\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}[!NOTE] The compiler transforms `done` and `text` into `get`/`set` methods on the class prototype referencing private fields. This means the properties are not enumerable.\nWhen calling methods in JavaScript, the value of `this` matters. This won't work, because this inside the reset method will be the <button> rather than the Todo:<button onclick={todo.reset}>\n\treset\n</button>You can either use an inline function...<button onclick=+++{() => todo.reset()}>+++\n\treset\n</button>...or use an arrow function in the class definition: \nclass Todo {\n\tdone = $state(false);\n\ttext = $state();\n\n\tconstructor(text) {\n\t\tthis.text = text;\n\t}\n\n\t+++reset = () => {+++\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}",
              "href": "/docs/svelte/$state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$state",
                "$state.raw"
              ],
              "content": "In cases where you don't want objects and arrays to be deeply reactive you can use $state.raw.State declared with $state.raw cannot be mutated; it can only be reassigned. In other words, rather than assigning to a property of an object, or using an array method like push, replace the object or array altogether if you'd like to update it:let person = $state.raw({\n\tname: 'Heraclitus',\n\tage: 49\n});\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = {\n\tname: 'Heraclitus',\n\tage: 50\n};This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can contain reactive state (for example, a raw array of reactive objects).",
              "href": "/docs/svelte/$state#$state.raw"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$state",
                "$state.snapshot"
              ],
              "content": "To take a static snapshot of a deeply reactive $state proxy, use $state.snapshot:<script>\n\tlet counter = $state({ count: 0 });\n\n\tfunction onclick() {\n\t\t// Will log `{ count: ... }` rather than `Proxy { ... }`\n\t\tconsole.log($state.snapshot(counter));\n\t}\n</script>This is handy when you want to pass some state to an external library or API that doesn't expect a proxy, such as structuredClone.",
              "href": "/docs/svelte/$state#$state.snapshot"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$state",
                "Passing state into functions"
              ],
              "content": "JavaScript is a pass-by-value language — when you call a function, the arguments are the values rather than the variables. In other words:/**\n * @param {number} a\n * @param {number} b\n */\nfunction add(a, b) {\n\treturn a + b;\n}\n\nlet a = 1;\nlet b = 2;\nlet total = add(a, b);\nconsole.log(total); // 3\n\na = 3;\nb = 4;\nconsole.log(total); // still 3!If add wanted to have access to the current values of a and b, and to return the current total value, you would need to use functions instead:/**\n * @param {() => number} getA\n * @param {() => number} getB\n */\nfunction add(+++getA, getB+++) {\n\treturn +++() => getA() + getB()+++;\n}\n\nlet a = 1;\nlet b = 2;\nlet total = add+++(() => a, () => b)+++;\nconsole.log(+++total()+++); // 3\n\na = 3;\nb = 4;\nconsole.log(+++total()+++); // 7State in Svelte is no different — when you reference something declared with the $state rune...let a = +++$state(1)+++;\nlet b = +++$state(2)+++;...you're accessing its current value.Note that 'functions' is broad — it encompasses properties of proxies and `get`/`set` properties.../**\n * @param {{ a: number, b: number }} input\n */\nfunction add(input) {\n\treturn {\n\t\tget value() {\n\t\t\treturn input.a + input.b;\n\t\t}\n\t};\n}\n\nlet input = $state({ a: 1, b: 2 });\nlet total = add(input);\nconsole.log(total.value); // 3\n\ninput.a = 3;\ninput.b = 4;\nconsole.log(total.value); // 7...though if you find yourself writing code like that, consider using classes instead.",
              "href": "/docs/svelte/$state#Passing-state-into-functions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$state",
                "Passing state across modules"
              ],
              "content": "You can declare state in .svelte.js and .svelte.ts files, but you can only export that state if it's not directly reassigned. In other words you can't do this: \nexport let count = $state(0);\n\nexport function increment() {\n\tcount += 1;\n}That's because every reference to count is transformed by the Svelte compiler — the code above is roughly equivalent to this:export let count = $.state(0);\n\nexport function increment() {\n\t$.set(count, $.get(count) + 1);\n}[!NOTE] You can see the code Svelte generates by clicking the 'JS Output' tab in the [playground](/playground).\nSince the compiler only operates on one file at a time, if another file imports count Svelte doesn't know that it needs to wrap each reference in $.get and $.set:import { count } from './state.svelte.js';\n\nconsole.log(typeof count); // 'object', not 'number'This leaves you with two options for sharing state between modules — either don't reassign it...// This is allowed — since we're updating\n// `counter.count` rather than `counter`,\n// Svelte doesn't wrap it in `$.state`\nexport const counter = $state({\n\tcount: 0\n});\n\nexport function increment() {\n\tcounter.count += 1;\n}...or don't directly export it:let count = $state(0);\n\nexport function getCount() {\n\treturn count;\n}\n\nexport function increment() {\n\tcount += 1;\n}",
              "href": "/docs/svelte/$state#Passing-state-across-modules"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$derived"
              ],
              "content": "Derived state is declared with the $derived rune:<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n</script>\n\n<button onclick={() => count++}>\n\t{doubled}\n</button>\n\n<p>{count} doubled is {doubled}</p>The expression inside $derived(...) should be free of side-effects. Svelte will disallow state changes (e.g. count++) inside derived expressions.As with $state, you can mark class fields as $derived.[!NOTE] Code in Svelte components is only executed once at creation. Without the `$derived` rune, `doubled` would maintain its original value even when `count` changes.",
              "href": "/docs/svelte/$derived"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$derived",
                "$derived.by"
              ],
              "content": "Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use $derived.by which accepts a function as its argument.<script>\n\tlet numbers = $state([1, 2, 3]);\n\tlet total = $derived.by(() => {\n\t\tlet total = 0;\n\t\tfor (const n of numbers) {\n\t\t\ttotal += n;\n\t\t}\n\t\treturn total;\n\t});\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n\t{numbers.join(' + ')} = {total}\n</button>In essence, $derived(expression) is equivalent to $derived.by(() => expression).",
              "href": "/docs/svelte/$derived#$derived.by"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$derived",
                "Understanding dependencies"
              ],
              "content": "Anything read synchronously inside the $derived expression (or $derived.by function body) is considered a dependency of the derived state. When the state changes, the derived will be marked as dirty and recalculated when it is next read.To exempt a piece of state from being treated as a dependency, use `untrack`.",
              "href": "/docs/svelte/$derived#Understanding-dependencies"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$derived",
                "Deriveds and reactivity"
              ],
              "content": "Unlike $state, which converts objects and arrays to deeply reactive proxies, $derived values are left as-is. For example, in a case like this...let items = $state([...]);\n\nlet index = $state(0);\nlet selected = $derived(items[index]);...you can change (or bind: to) properties of selected and it will affect the underlying items array. If items was not deeply reactive, mutating selected would have no effect.",
              "href": "/docs/svelte/$derived#Deriveds-and-reactivity"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$derived",
                "Update propagation"
              ],
              "content": "Svelte uses something called push-pull reactivity — when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull').If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when large changes, not when count changes, even though large depends on count:<script>\n\tlet count = $state(0);\n\tlet large = $derived(count > 10);\n</script>\n\n<button onclick={() => count++}>\n\t{large}\n</button>",
              "href": "/docs/svelte/$derived#Update-propagation"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$effect"
              ],
              "content": "Effects are functions that run when state updates, and can be used for things like calling third-party libraries, drawing on <canvas> elements, or making network requests. They only run in the browser, not during server-side rendering.Generally speaking, you should not update state inside effects, as it will make code more convoluted and will often lead to never-ending update cycles. If you find yourself doing so, see when not to use `$effect` to learn about alternative approaches.You can create an effect with the $effect rune (demo):<script>\n\tlet size = $state(50);\n\tlet color = $state('#ff3e00');\n\n\tlet canvas;\n\n\t$effect(() => {\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t\t// this will re-run whenever `color` or `size` change\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillRect(0, 0, size, size);\n\t});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\"></canvas>When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside `untrack`), and re-runs the function when that state later changes.[!NOTE] If you're having difficulty understanding why your `$effect` is rerunning or is not running see [understanding dependencies](#Understanding-dependencies). Effects are triggered differently than the `$:` blocks you may be used to if coming from Svelte 4.\nUnderstanding lifecycle\nYour effects run after the component has been mounted to the DOM, and in a microtask after state changes. Re-runs are batched (i.e. changing color and size in the same moment won't cause two separate runs), and happen after any DOM updates have been applied.You can use $effect anywhere, not just at the top level of a component, as long as it is called while a parent effect is running.[!NOTE] Svelte uses effects internally to represent logic and expressions in your template — this is how `<h1>hello {name}!</h1>` updates when `name` changes.\nAn effect can return a teardown function which will run immediately before the effect re-runs (demo).<script>\n\tlet count = $state(0);\n\tlet milliseconds = $state(1000);\n\n\t$effect(() => {\n\t\t// This will be recreated whenever `milliseconds` changes\n\t\tconst interval = setInterval(() => {\n\t\t\tcount += 1;\n\t\t}, milliseconds);\n\n\t\treturn () => {\n\t\t\t// if a teardown function is provided, it will run\n\t\t\t// a) immediately before the effect re-runs\n\t\t\t// b) when the component is destroyed\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>Teardown functions also run when the effect is destroyed, which happens when its parent is destroyed (for example, a component is unmounted) or the parent effect re-runs.Understanding dependencies\n$effect automatically picks up any reactive values ($state, $derived, $props) that are synchronously read inside its function body (including indirectly, via function calls) and registers them as dependencies. When those dependencies change, the $effect schedules a re-run.If $state and $derived are used directly inside the $effect (for example, during creation of a reactive class), those values will not be treated as dependencies.Values that are read asynchronously — after an await or inside a setTimeout, for example — will not be tracked. Here, the canvas will be repainted when color changes, but not when size changes (demo):$effect(() => {\n\tconst context = canvas.getContext('2d');\n\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t// this will re-run whenever `color` changes...\n\tcontext.fillStyle = color;\n\n\tsetTimeout(() => {\n\t\t// ...but not when `size` changes\n\t\tcontext.fillRect(0, 0, size, size);\n\t}, 0);\n});An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes inside an object at dev time, you can use `$inspect`.)<script>\n\tlet state = $state({ value: 0 });\n\tlet derived = $derived({ value: state.value * 2 });\n\n\t// this will run once, because `state` is never reassigned (only mutated)\n\t$effect(() => {\n\t\tstate;\n\t});\n\n\t// this will run whenever `state.value` changes...\n\t$effect(() => {\n\t\tstate.value;\n\t});\n\n\t// ...and so will this, because `derived` is a new object each time\n\t$effect(() => {\n\t\tderived;\n\t});\n</script>\n\n<button onclick={() => (state.value += 1)}>\n\t{state.value}\n</button>\n\n<p>{state.value} doubled is {derived.value}</p>An effect only depends on the values that it read the last time it ran. This has interesting implications for effects that have conditional code.For instance, if condition is true in the code snippet below, the code inside the if block will run and color will be evaluated. As such, changes to either condition or color will cause the effect to re-run.Conversely, if condition is false, color will not be evaluated, and the effect will only re-run again when condition changes.import confetti from 'canvas-confetti';\n\nlet condition = $state(true);\nlet color = $state('#ff3e00');\n\n$effect(() => {\n\tif (condition) {\n\t\tconfetti({ colors: [color] });\n\t} else {\n\t\tconfetti();\n\t}\n});",
              "href": "/docs/svelte/$effect"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$effect",
                "$effect.pre"
              ],
              "content": "In rare cases, you may need to run code before the DOM updates. For this we can use the $effect.pre rune:<script>\n\timport { tick } from 'svelte';\n\n\tlet div = $state();\n\tlet messages = $state([]);\n\n\t// ...\n\n\t$effect.pre(() => {\n\t\tif (!div) return; // not yet mounted\n\n\t\t// reference `messages` array length so that this code re-runs whenever it changes\n\t\tmessages.length;\n\n\t\t// autoscroll when new messages are added\n\t\tif (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n\t\t\ttick().then(() => {\n\t\t\t\tdiv.scrollTo(0, div.scrollHeight);\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n<div bind:this={div}>\n\t{#each messages as message}\n\t\t<p>{message}</p>\n\t{/each}\n</div>Apart from the timing, $effect.pre works exactly like $effect.",
              "href": "/docs/svelte/$effect#$effect.pre"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$effect",
                "$effect.tracking"
              ],
              "content": "The $effect.tracking rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template (demo):<script>\n\tconsole.log('in component setup:', $effect.tracking()); // false\n\n\t$effect(() => {\n\t\tconsole.log('in effect:', $effect.tracking()); // true\n\t});\n</script>\n\n<p>in template: {$effect.tracking()}</p> <!-- true -->It is used to implement abstractions like `createSubscriber`, which will create listeners to update reactive values but only if those values are being tracked (rather than, for example, read inside an event handler).",
              "href": "/docs/svelte/$effect#$effect.tracking"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$effect",
                "$effect.root"
              ],
              "content": "The $effect.root rune is an advanced feature that creates a non-tracked scope that doesn't auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for the creation of effects outside of the component initialisation phase.const destroy = $effect.root(() => {\n\t$effect(() => {\n\t\t// setup\n\t});\n\n\treturn () => {\n\t\t// cleanup\n\t};\n});\n\n// later...\ndestroy();",
              "href": "/docs/svelte/$effect#$effect.root"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$effect",
                "When not to use `$effect`"
              ],
              "content": "In general, $effect is best considered something of an escape hatch — useful for things like analytics and direct DOM manipulation — rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this...<script>\n\tlet count = $state(0);\n\tlet doubled = $state();\n\n\t// don't do this!\n\t$effect(() => {\n\t\tdoubled = count * 2;\n\t});\n</script>...do this:<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n</script>[!NOTE] For things that are more complicated than a simple expression like `count * 2`, you can also use `$derived.by`.\nIf you're using an effect because you want to be able to reassign the derived value (to build an optimistic UI, for example) note that deriveds can be directly overridden as of Svelte 5.25.You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for &quot;money spent&quot; and &quot;money left&quot; that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this (demo):<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\tlet left = $state(total);\n\n\t$effect(() => {\n\t\tleft = total - spent;\n\t});\n\n\t$effect(() => {\n\t\tspent = total - left;\n\t});\n</script>\n\n<label>\n\t<input type=\"range\" bind:value={spent} max={total} />\n\t{spent}/{total} spent\n</label>\n\n<label>\n\t<input type=\"range\" bind:value={left} max={total} />\n\t{left}/{total} left\n</label>Instead, use oninput callbacks or — better still — function bindings where possible (demo):<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\tlet left = $state(total);\n\n\tfunction updateSpent(value) {\n\t\tspent = value;\n\t\tleft = total - spent;\n\t}\n\n\tfunction updateLeft(value) {\n\t\tleft = value;\n\t\tspent = total - left;\n\t}\n</script>\n\n<label>\n\t<input type=\"range\" bind:value={() => spent, updateSpent} max={total} />\n\t{spent}/{total} spent\n</label>\n\n<label>\n\t<input type=\"range\" bind:value={() => left, updateLeft} max={total} />\n\t{left}/{total} left\n</label>If you absolutely have to update $state within an effect and run into an infinite loop because you read and write to the same $state, use untrack.",
              "href": "/docs/svelte/$effect#When-not-to-use-$effect"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$props",
                "Fallback values"
              ],
              "content": "Destructuring allows us to declare fallback values, which are used if the parent component does not set a given prop (or the value is undefined):let { adjective = 'happy' } = $props();[!NOTE] Fallback values are not turned into reactive state proxies (see [Updating props](#Updating-props) for more info)",
              "href": "/docs/svelte/$props#Fallback-values"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$props",
                "Updating props"
              ],
              "content": "References to a prop inside a component update when the prop itself updates — when count changes in App.svelte, it will also change inside Child.svelte. But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state (demo):<!--- file: App.svelte --->\n<script>\n\timport Child from './Child.svelte';\n\n\tlet count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n\tclicks (parent): {count}\n</button>\n\n<Child {count} /><!--- file: Child.svelte --->\n<script>\n\tlet { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n\tclicks (child): {count}\n</button>While you can temporarily reassign props, you should not mutate props unless they are bindable.If the prop is a regular object, the mutation will have no effect (demo):<!--- file: App.svelte --->\n<script>\n\timport Child from './Child.svelte';\n</script>\n\n<Child object={{ count: 0 }} /><!--- file: Child.svelte --->\n<script>\n\tlet { object } = $props();\n</script>\n\n<button onclick={() => {\n\t// has no effect\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n</button>If the prop is a reactive state proxy, however, then mutations will have an effect but you will see an `ownership_invalid_mutation` warning, because the component is mutating state that does not 'belong' to it (demo):<!--- file: App.svelte --->\n<script>\n\timport Child from './Child.svelte';\n\n\tlet object = $state({count: 0});\n</script>\n\n<Child {object} /><!--- file: Child.svelte --->\n<script>\n\tlet { object } = $props();\n</script>\n\n<button onclick={() => {\n\t// will cause the count below to update,\n\t// but with a warning. Don't mutate\n\t// objects you don't own!\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n</button>The fallback value of a prop not declared with $bindable is left untouched — it is not turned into a reactive state proxy — meaning mutations will not cause updates (demo)<!--- file: Child.svelte --->\n<script>\n\tlet { object = { count: 0 } } = $props();\n</script>\n\n<button onclick={() => {\n\t// has no effect if the fallback value is used\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n</button>In summary: don't mutate props. Either use callback props to communicate changes, or — if parent and child should share the same object — use the `$bindable` rune.",
              "href": "/docs/svelte/$props#Updating-props"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$bindable"
              ],
              "content": "Ordinarily, props go one way, from parent to child. This makes it easy to understand how data flows around your app.In Svelte, component props can be bound, which means that data can also flow up from child to parent. This isn't something you should do often, but it can simplify your code if used sparingly and carefully.It also means that a state proxy can be mutated in the child.[!NOTE] Mutation is also possible with normal props, but is strongly discouraged — Svelte will warn you if it detects that a component is mutating state it does not 'own'.\nTo mark a prop as bindable, we use the $bindable rune:\n \n<script>\n\tlet { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n\n<style>\n\tinput {\n\t\tfont-family: 'Comic Sans MS';\n\t\tcolor: deeppink;\n\t}\n</style>Now, a component that uses <FancyInput> can add the `bind:` directive (demo):\n \n<script>\n\timport FancyInput from './FancyInput.svelte';\n\n\tlet message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<p>{message}</p>The parent component doesn't have to use bind: — it can just pass a normal prop. Some parents don't want to listen to what their children have to say.In this case, you can specify a fallback value for when no prop is passed at all: \nlet { value = $bindable('fallback'), ...props } = $props();",
              "href": "/docs/svelte/$bindable"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$inspect"
              ],
              "content": "[!NOTE] `$inspect` only works during development. In a production build it becomes a noop.\nThe $inspect rune is roughly equivalent to console.log, with the exception that it will re-run whenever its argument changes. $inspect tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire (demo):<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />",
              "href": "/docs/svelte/$inspect"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$inspect",
                "$inspect(...).with"
              ],
              "content": "$inspect returns a property with, which you can invoke with a callback, which will then be invoked instead of console.log. The first argument to the callback is either &quot;init&quot; or &quot;update&quot;; subsequent arguments are the values passed to $inspect (demo):<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>A convenient way to find the origin of some change is to pass console.trace to with: \n$inspect(stuff).with(console.trace);",
              "href": "/docs/svelte/$inspect#$inspect().with"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$inspect",
                "$inspect.trace(...)"
              ],
              "content": "This rune, added in 5.14, causes the surrounding function to be traced in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t+++$inspect.trace();+++\n\t\tdoSomeWork();\n\t});\n</script>$inspect.trace takes an optional first argument which will be used as the label.",
              "href": "/docs/svelte/$inspect#$inspect.trace()"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runes",
                "$host"
              ],
              "content": "When compiling a component as a custom element, the $host rune provides access to the host element, allowing you to (for example) dispatch custom events (demo):\n \n<svelte:options customElement=\"my-stepper\" />\n\n<script>\n\tfunction dispatch(type) {\n\t\t+++$host()+++.dispatchEvent(new CustomEvent(type));\n\t}\n</script>\n\n<button onclick={() => dispatch('decrement')}>decrement</button>\n<button onclick={() => dispatch('increment')}>increment</button>\n \n<script>\n\timport './Stepper.svelte';\n\n\tlet count = $state(0);\n</script>\n\n<my-stepper\n\tondecrement={() => count -= 1}\n\tonincrement={() => count += 1}\n></my-stepper>\n\n<p>count: {count}</p>",
              "href": "/docs/svelte/$host"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "{#key ...}"
              ],
              "content": "<!--- copy: false  --->\n{#key expression}...{/key}Key blocks destroy and recreate their contents when the value of an expression changes. When used around components, this will cause them to be reinstantiated and reinitialised:{#key value}\n\t<Component />\n{/key}It's also useful if you want a transition to play whenever a value changes:{#key value}\n\t<div transition:fade>{value}</div>\n{/key}",
              "href": "/docs/svelte/key"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "{#await ...}"
              ],
              "content": "<!--- copy: false  --->\n{#await expression}...{:then name}...{:catch name}...{/await}<!--- copy: false  --->\n{#await expression}...{:then name}...{/await}<!--- copy: false  --->\n{#await expression then name}...{/await}<!--- copy: false  --->\n{#await expression catch name}...{/await}Await blocks allow you to branch on the three possible states of a `Promise` — pending, fulfilled or rejected.{#await promise}\n\t<!-- promise is pending -->\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t<!-- promise was fulfilled or not a Promise -->\n\t<p>The value is {value}</p>\n{:catch error}\n\t<!-- promise was rejected -->\n\t<p>Something went wrong: {error.message}</p>\n{/await}[!NOTE] During server-side rendering, only the pending branch will be rendered.\n\nIf the provided expression is not a `Promise`, only the `:then` branch will be rendered, including during server-side rendering.\nThe catch block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).{#await promise}\n\t<!-- promise is pending -->\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t<!-- promise was fulfilled -->\n\t<p>The value is {value}</p>\n{/await}If you don't care about the pending state, you can also omit the initial block.{#await promise then value}\n\t<p>The value is {value}</p>\n{/await}Similarly, if you only want to show the error state, you can omit the then block.{#await promise catch error}\n\t<p>The error is {error}</p>\n{/await}[!NOTE] You can use `#await` with [`import(...)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) to render components lazily:\n\n```svelte\n{#await import('./Component.svelte') then { default: Component }}\n\t<Component />\n{/await}\n```",
              "href": "/docs/svelte/await"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "{#snippet ...}"
              ],
              "content": "<!--- copy: false  --->\n{#snippet name()}...{/snippet}<!--- copy: false  --->\n{#snippet name(param1, param2, paramN)}...{/snippet}Snippets, and render tags, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like this...{#each images as image}\n\t{#if image.href}\n\t\t<a href={image.href}>\n\t\t\t<figure>\n\t\t\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t\t\t<figcaption>{image.caption}</figcaption>\n\t\t\t</figure>\n\t\t</a>\n\t{:else}\n\t\t<figure>\n\t\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t\t<figcaption>{image.caption}</figcaption>\n\t\t</figure>\n\t{/if}\n{/each}...you can write this:{#snippet figure(image)}\n\t<figure>\n\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t<figcaption>{image.caption}</figcaption>\n\t</figure>\n{/snippet}\n\n{#each images as image}\n\t{#if image.href}\n\t\t<a href={image.href}>\n\t\t\t{@render figure(image)}\n\t\t</a>\n\t{:else}\n\t\t{@render figure(image)}\n\t{/if}\n{/each}Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters, however.",
              "href": "/docs/svelte/snippet"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "{#snippet ...}",
                "Programmatic snippets"
              ],
              "content": "Snippets can be created programmatically with the `createRawSnippet` API. This is intended for advanced use cases.",
              "href": "/docs/svelte/snippet#Programmatic-snippets"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "{@debug ...}"
              ],
              "content": "The {@debug ...} tag offers an alternative to console.log(...). It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.<script>\n\tlet user = {\n\t\tfirstname: 'Ada',\n\t\tlastname: 'Lovelace'\n\t};\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>{@debug ...} accepts a comma-separated list of variable names (not arbitrary expressions).<!-- Compiles -->\n{@debug user}\n{@debug user1, user2, user3}\n\n<!-- WON'T compile -->\n{@debug user.firstname}\n{@debug myArray[0]}\n{@debug !isReady}\n{@debug typeof user === 'object'}The {@debug} tag without any arguments will insert a debugger statement that gets triggered when any state changes, as opposed to the specified variables.",
              "href": "/docs/svelte/@debug"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "bind:"
              ],
              "content": "Data ordinarily flows down, from parent to child. The bind: directive allows data to flow the other way, from child to parent.The general syntax is bind:property={expression}, where expression is an lvalue (i.e. a variable or an object property). When the expression is an identifier with the same name as the property, we can omit the expression — in other words these are equivalent:\n<input bind:value={value} />\n<input bind:value />Svelte creates an event listener that updates the bound value. If an element already has a listener for the same event, that listener will be fired before the bound value is updated.Most bindings are two-way, meaning that changes to the value will affect the element and vice versa. A few bindings are readonly, meaning that changing their value will have no effect on the element.",
              "href": "/docs/svelte/bind"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "bind:",
                "<input bind:value>"
              ],
              "content": "A bind:value directive on an <input> element binds the input's value property:\n<script>\n\tlet message = $state('hello');\n</script>\n\n<input bind:value={message} />\n<p>{message}</p>In the case of a numeric input (type=&quot;number&quot; or type=&quot;range&quot;), the value will be coerced to a number (demo):<script>\n\tlet a = $state(1);\n\tlet b = $state(2);\n</script>\n\n<label>\n\t<input type=\"number\" bind:value={a} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={a} min=\"0\" max=\"10\" />\n</label>\n\n<label>\n\t<input type=\"number\" bind:value={b} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={b} min=\"0\" max=\"10\" />\n</label>\n\n<p>{a} + {b} = {a + b}</p>If the input is empty or invalid (in the case of type=&quot;number&quot;), the value is undefined.Since 5.6.0, if an <input> has a defaultValue and is part of a form, it will revert to that value instead of the empty string when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is null or undefined.<script>\n\tlet value = $state('');\n</script>\n\n<form>\n\t<input bind:value defaultValue=\"not the empty string\">\n\t<input type=\"reset\" value=\"Reset\">\n</form>[!NOTE]\nUse reset buttons sparingly, and ensure that users won't accidentally click them while trying to submit the form.",
              "href": "/docs/svelte/bind#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "bind:",
                "<input bind:checked>"
              ],
              "content": "Checkbox and radio inputs can be bound with bind:checked:<label>\n\t<input type=\"checkbox\" bind:checked={accepted} />\n\tAccept terms and conditions\n</label>Since 5.6.0, if an <input> has a defaultChecked attribute and is part of a form, it will revert to that value instead of false when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is null or undefined.<script>\n\tlet checked = $state(true);\n</script>\n\n<form>\n\t<input type=\"checkbox\" bind:checked defaultChecked={true}>\n\t<input type=\"reset\" value=\"Reset\">\n</form>",
              "href": "/docs/svelte/bind#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "bind:",
                "<input bind:group>"
              ],
              "content": "Inputs that work together can use bind:group.<script>\n\tlet tortilla = $state('Plain');\n\n\t/** @type {Array<string>} */\n\tlet fillings = $state([]);\n</script>\n\n<!-- grouped radio inputs are mutually exclusive -->\n<input type=\"radio\" bind:group={tortilla} value=\"Plain\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Whole wheat\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Spinach\" />\n\n<!-- grouped checkbox inputs populate an array -->\n<input type=\"checkbox\" bind:group={fillings} value=\"Rice\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Beans\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Cheese\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Guac (extra)\" />[!NOTE] `bind:group` only works if the inputs are in the same Svelte component.",
              "href": "/docs/svelte/bind#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "bind:",
                "<input bind:files>"
              ],
              "content": "On <input> elements with type=&quot;file&quot;, you can use bind:files to get the `FileList` of selected files. When you want to update the files programmatically, you always need to use a FileList object. Currently FileList objects cannot be constructed directly, so you need to create a new `DataTransfer` object and get files from there.<script>\n\tlet files = $state();\n\n\tfunction clear() {\n\t\tfiles = new DataTransfer().files; // null or undefined does not work\n\t}\n</script>\n\n<label for=\"avatar\">Upload a picture:</label>\n<input accept=\"image/png, image/jpeg\" bind:files id=\"avatar\" name=\"avatar\" type=\"file\" />\n<button onclick={clear}>clear</button>FileList objects also cannot be modified, so if you want to e.g. delete a single file from the list, you need to create a new DataTransfer object and add the files you want to keep.[!NOTE] `DataTransfer` may not be available in server-side JS runtimes. Leaving the state that is bound to `files` uninitialized prevents potential errors if components are server-side rendered.",
              "href": "/docs/svelte/bind#"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "use:"
              ],
              "content": "Actions are functions that are called when an element is mounted. They are added with the use: directive, and will typically use an $effect so that they can reset any state when the element is unmounted:<!--- file: App.svelte --->\n<script>\n\t/** @type {import('svelte/action').Action} */\n\tfunction myaction(node) {\n\t\t// the node has been mounted in the DOM\n\n\t\t$effect(() => {\n\t\t\t// setup goes here\n\n\t\t\treturn () => {\n\t\t\t\t// teardown goes here\n\t\t\t};\n\t\t});\n\t}\n</script>\n\n<div use:myaction>...</div>An action can be called with an argument:<!--- file: App.svelte --->\n<script>\n\t/** @type {import('svelte/action').Action} */\n\tfunction myaction(node, +++data+++) {\n\t\t// ...\n\t}\n</script>\n\n<div use:myaction={+++data+++}>...</div>The action is only called once (but not during server-side rendering) — it will not run again if the argument changes.[!LEGACY]\nPrior to the `$effect` rune, actions could return an object with `update` and `destroy` methods, where `update` would be called with the latest value of the argument if it changed. Using effects is preferred.",
              "href": "/docs/svelte/use"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "use:",
                "Typing"
              ],
              "content": "The Action interface receives three optional type arguments — a node type (which can be Element, if the action applies to everything), a parameter, and any custom event handlers created by the action:<!--- file: App.svelte --->\n<script>\n\t/**\n\t * @type {import('svelte/action').Action<\n\t * \tHTMLDivElement,\n\t * \tundefined,\n\t * \t{\n\t * \t\tonswiperight: (e: CustomEvent) => void;\n\t * \t\tonswipeleft: (e: CustomEvent) => void;\n\t * \t\t// ...\n\t * \t}\n\t * >}\n\t */\n\tfunction gestures(node) {\n\t\t$effect(() => {\n\t\t\t// ...\n\t\t\tnode.dispatchEvent(new CustomEvent('swipeleft'));\n\n\t\t\t// ...\n\t\t\tnode.dispatchEvent(new CustomEvent('swiperight'));\n\t\t});\n\t}\n</script>\n\n<div\n\tuse:gestures\n\tonswipeleft={next}\n\tonswiperight={prev}\n>...</div>",
              "href": "/docs/svelte/use#Typing"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "transition:"
              ],
              "content": "A transition is triggered by an element entering or leaving the DOM as a result of a state change.When a block (such as an {#if ...} block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.The transition: directive indicates a bidirectional transition, which means it can be smoothly reversed while the transition is in progress.<script>\n\t+++import { fade } from 'svelte/transition';+++\n\n\tlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>toggle</button>\n\n{#if visible}\n\t<div +++transition:fade+++>fades in and out</div>\n{/if}",
              "href": "/docs/svelte/transition"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "transition:",
                "Local vs global"
              ],
              "content": "Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, not when parent blocks are created or destroyed.{#if x}\n\t{#if y}\n\t\t<p transition:fade>fades in and out only when y changes</p>\n\n\t\t<p transition:fade|global>fades in and out when x or y change</p>\n\t{/if}\n{/if}",
              "href": "/docs/svelte/transition#Local-vs-global"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "transition:",
                "Custom transition functions"
              ],
              "content": "/// copy: false\n \ntransition = (node: HTMLElement, params: any, options: { direction: 'in' | 'out' | 'both' }) => {\n\tdelay?: number,\n\tduration?: number,\n\teasing?: (t: number) => number,\n\tcss?: (t: number, u: number) => string,\n\ttick?: (t: number, u: number) => void\n}Transitions can use custom functions. If the returned object has a css function, Svelte will generate keyframes for a web animation.The t argument passed to css is a value between 0 and 1 after the easing function has been applied. In transitions run from 0 to 1, out transitions run from 1 to 0 — in other words, 1 is the element's natural state, as though no transition had been applied. The u argument is equal to 1 - t.The function is called repeatedly before the transition begins, with different t and u arguments.<!--- file: App.svelte --->\n<script>\n\timport { elasticOut } from 'svelte/easing';\n\n\t/** @type {boolean} */\n\texport let visible;\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n\t */\n\tfunction whoosh(node, params) {\n\t\tconst existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n\t\treturn {\n\t\t\tdelay: params.delay || 0,\n\t\t\tduration: params.duration || 400,\n\t\t\teasing: params.easing || elasticOut,\n\t\t\tcss: (t, u) => `transform: ${existingTransform} scale(${t})`\n\t\t};\n\t}\n</script>\n\n{#if visible}\n\t<div in:whoosh>whooshes in</div>\n{/if}A custom transition function can also return a tick function, which is called during the transition with the same t and u arguments.[!NOTE] If it's possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.\n<!--- file: App.svelte --->\n<script>\n\texport let visible = false;\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ speed?: number }} params\n\t */\n\tfunction typewriter(node, { speed = 1 }) {\n\t\tconst valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n\t\tif (!valid) {\n\t\t\tthrow new Error(`This transition only works on elements with a single text node child`);\n\t\t}\n\n\t\tconst text = node.textContent;\n\t\tconst duration = text.length / (speed * 0.01);\n\n\t\treturn {\n\t\t\tduration,\n\t\t\ttick: (t) => {\n\t\t\t\tconst i = ~~(text.length * t);\n\t\t\t\tnode.textContent = text.slice(0, i);\n\t\t\t}\n\t\t};\n\t}\n</script>\n\n{#if visible}\n\t<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making crossfade effects possible.Transition functions also receive a third argument, options, which contains information about the transition.Available values in the options object are:undefined",
              "href": "/docs/svelte/transition#Custom-transition-functions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "in: and out:"
              ],
              "content": "The in: and out: directives are identical to `transition:`, except that the resulting transitions are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  visible\n</label>\n\n{#if visible}\n\t<div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>\n{/if}",
              "href": "/docs/svelte/in-and-out"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "animate:",
                "Custom animation functions"
              ],
              "content": "/// copy: false\n \nanimation = (node: HTMLElement, { from: DOMRect, to: DOMRect } , params: any) => {\n\tdelay?: number,\n\tduration?: number,\n\teasing?: (t: number) => number,\n\tcss?: (t: number, u: number) => string,\n\ttick?: (t: number, u: number) => void\n}Animations can use custom functions that provide the node, an animation object and any parameters as arguments. The animation parameter is an object containing from and to properties each containing a DOMRect describing the geometry of the element in its start and end positions. The from property is the DOMRect of the element in its starting position, and the to property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.If the returned object has a css method, Svelte will create a web animation that plays on the element.The t argument passed to css is a value that goes from 0 and 1 after the easing function has been applied. The u argument is equal to 1 - t.The function is called repeatedly before the animation begins, with different t and u arguments.\n<!--- file: App.svelte --->\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect; to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\tcss: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}A custom animation function can also return a tick function, which is called during the animation with the same t and u arguments.[!NOTE] If it's possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.\n<!--- file: App.svelte --->\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect; to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\ttick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}",
              "href": "/docs/svelte/animate#Custom-animation-functions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Template syntax",
                "class",
                "Attributes",
                "Objects and arrays"
              ],
              "content": "Since Svelte 5.16, class can be an object or array, and is converted to a string using clsx.If the value is an object, the truthy keys are added:<script>\n\tlet { cool } = $props();\n</script>\n\n<!-- results in `class=\"cool\"` if `cool` is truthy,\n     `class=\"lame\"` otherwise -->\n<div class={{ cool, lame: !cool }}>...</div>If the value is an array, the truthy values are combined:<!-- if `faded` and `large` are both truthy, results in\n     `class=\"saturate-0 opacity-50 scale-200\"` -->\n<div class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...</div>Note that whether we're using the array or object form, we can set multiple classes simultaneously with a single condition, which is particularly useful if you're using things like Tailwind.Arrays can contain arrays and objects, and clsx will flatten them. This is useful for combining local classes with props, for example:<!--- file: Button.svelte --->\n<script>\n\tlet props = $props();\n</script>\n\n<button {...props} class={['cool-button', props.class]}>\n\t{@render props.children?.()}\n</button>The user of this component has the same flexibility to use a mixture of objects, arrays and strings:<!--- file: App.svelte --->\n<script>\n\timport Button from './Button.svelte';\n\tlet useTailwind = $state(false);\n</script>\n\n<Button\n\tonclick={() => useTailwind = true}\n\tclass={{ 'bg-blue-700 sm:w-1/2': useTailwind }}\n>\n\tAccept the inevitability of Tailwind\n</Button>Svelte also exposes the ClassValue type, which is the type of value that the class attribute on elements accept. This is useful if you want to use a type-safe class name in component props:<script lang=\"ts\">\n\timport type { ClassValue } from 'svelte/elements';\n\n\tconst props: { class: ClassValue } = $props();\n</script>\n\n<div class={['original', props.class]}>...</div>",
              "href": "/docs/svelte/class#Attributes-Objects-and-arrays"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Styling",
                "Global styles",
                ":global"
              ],
              "content": "To apply styles to a group of selectors globally, create a :global {...} block:<style>\n\t:global {\n\t\t/* applies to every <div> in your application */\n\t\tdiv { ... }\n\n\t\t/* applies to every <p> in your application */\n\t\tp { ... }\n\t}\n\n\t.a :global {\n\t\t/* applies to every `.b .c .d` element, in any component,\n\t\t   that is inside an `.a` element in this component */\n\t\t.b .c .d {...}\n\t}\n</style>[!NOTE] The second example above could also be written as an equivalent `.a :global .b .c .d` selector, where everything after the `:global` is unscoped, though the nested form is preferred.",
              "href": "/docs/svelte/global-styles#:global"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Special elements",
                "<svelte:boundary>",
                "Properties",
                "failed"
              ],
              "content": "If a failed snippet is provided, it will be rendered with the error that was thrown, and a reset function that recreates the contents (demo):<svelte:boundary>\n\t<FlakyComponent />\n\n\t{#snippet failed(error, reset)}\n\t\t<button onclick={reset}>oops! try again</button>\n\t{/snippet}\n</svelte:boundary>[!NOTE]\nAs with [snippets passed to components](snippet#Passing-snippets-to-components), the `failed` snippet can be passed explicitly as a property...\n\n```svelte\n<svelte:boundary {failed}>...</svelte:boundary>\n```\n\n...or implicitly by declaring it directly inside the boundary, as in the example above.",
              "href": "/docs/svelte/svelte-boundary#Properties-failed"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Special elements",
                "<svelte:boundary>",
                "Properties",
                "onerror"
              ],
              "content": "If an onerror function is provided, it will be called with the same two error and reset arguments. This is useful for tracking the error with an error reporting service...<svelte:boundary onerror={(e) => report(e)}>\n\t...\n</svelte:boundary>...or using error and reset outside the boundary itself:<script>\n\tlet error = $state(null);\n\tlet reset = $state(() => {});\n\n\tfunction onerror(e, r) {\n\t\terror = e;\n\t\treset = r;\n\t}\n</script>\n\n<svelte:boundary {onerror}>\n\t<FlakyComponent />\n</svelte:boundary>\n\n{#if error}\n\t<button onclick={() => {\n\t\terror = null;\n\t\treset();\n\t}}>\n\t\toops! try again\n\t</button>\n{/if}If an error occurs inside the onerror function (or if you rethrow the error), it will be handled by a parent boundary if such exists.",
              "href": "/docs/svelte/svelte-boundary#Properties-onerror"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Special elements",
                "<svelte:element>"
              ],
              "content": "<svelte:element this={expression} />The <svelte:element> element lets you render an element that is unknown at author time, for example because it comes from a CMS. Any properties and event listeners present will be applied to the element.The only supported binding is bind:this, since Svelte's built-in bindings do not work with generic elements.If this has a nullish value, the element and its children will not be rendered.If this is the name of a void element (e.g., br) and <svelte:element> has child elements, a runtime error will be thrown in development mode:<script>\n\tlet tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n\tThis text cannot appear inside an hr element\n</svelte:element>Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an xmlns attribute:<svelte:element this={tag} xmlns=\"http://www.w3.org/2000/svg\" />this needs to be a valid DOM element tag, things like #text or svelte:head will not work.",
              "href": "/docs/svelte/svelte-element"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Stores",
                "When to use stores"
              ],
              "content": "Prior to Svelte 5, stores were the go-to solution for creating cross-component reactive states or extracting logic. With runes, these use cases have greatly diminished.undefined\n \nexport const userState = $state({\n\tname: 'name',\n\t/* ... */\n});<!--- file: App.svelte --->\n<script>\n\timport { userState } from './state.svelte.js';\n</script>\n\n<p>User name: {userState.name}</p>\n<button onclick={() => {\n\tuserState.name = 'new name';\n}}>\n\tchange name\n</button>Stores are still a good solution when you have complex asynchronous data streams or it's important to have more manual control over updating values or listening to changes. If you're familiar with RxJs and want to reuse that knowledge, the $ also comes in handy for you.",
              "href": "/docs/svelte/stores#When-to-use-stores"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Stores",
                "svelte/store",
                "writable"
              ],
              "content": "Function that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional set and update methods.set is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.update is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store. \nimport { writable } from 'svelte/store';\n\nconst count = writable(0);\n\ncount.subscribe((value) => {\n\tconsole.log(value);\n}); // logs '0'\n\ncount.set(1); // logs '1'\n\ncount.update((n) => n + 1); // logs '2'If a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a set function which changes the value of the store, and an update function which works like the update method on the store, taking a callback to calculate the store's new value from its old value. It must return a stop function that is called when the subscriber count goes from one to zero. \nimport { writable } from 'svelte/store';\n\nconst count = writable(0, () => {\n\tconsole.log('got a subscriber');\n\treturn () => console.log('no more subscribers');\n});\n\ncount.set(1); // does nothing\n\nconst unsubscribe = count.subscribe((value) => {\n\tconsole.log(value);\n}); // logs 'got a subscriber', then '1'\n\nunsubscribe(); // logs 'no more subscribers'Note that the value of a writable is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the localStorage.",
              "href": "/docs/svelte/stores#svelte-store-writable"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Stores",
                "Store contract"
              ],
              "content": "store = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }You can create your own stores without relying on `svelte/store`, by implementing the store contract:undefined\nFor interoperability with RxJS Observables, the .subscribe method is also allowed to return an object with an .unsubscribe method, rather than return the unsubscription function directly. Note however that unless .subscribe synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as undefined until it does.",
              "href": "/docs/svelte/stores#Store-contract"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Context",
                "Using context with state"
              ],
              "content": "You can store reactive state in context (demo)...<script>\n\timport { setContext } from 'svelte';\n\timport Child from './Child.svelte';\n\n\tlet counter = $state({\n\t\tcount: 0\n\t});\n\n\tsetContext('counter', counter);\n</script>\n\n<button onclick={() => counter.count += 1}>\n\tincrement\n</button>\n\n<Child />\n<Child />\n<Child />...though note that if you reassign counter instead of updating it, you will 'break the link' — in other words instead of this...<button onclick={() => counter = { count: 0 }}>\n\treset\n</button>...you must do this:<button onclick={() => +++counter.count = 0+++}>\n\treset\n</button>Svelte will warn you if you get it wrong.",
              "href": "/docs/svelte/context#Using-context-with-state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Context",
                "Replacing global state"
              ],
              "content": "When you have state shared by many different components, you might be tempted to put it in its own module and just import it wherever it's needed: \nexport const myGlobalState = $state({\n\tuser: {\n\t\t// ...\n\t}\n\t// ...\n});In many cases this is perfectly fine, but there is a risk: if you mutate the state during server-side rendering (which is discouraged, but entirely possible!)...<!--- file: App.svelte ---->\n<script>\n\timport { myGlobalState } from 'svelte';\n\n\tlet { data } = $props();\n\n\tif (data.user) {\n\t\tmyGlobalState.user = data.user;\n\t}\n</script>...then the data may be accessible by the next user. Context solves this problem because it is not shared between requests.",
              "href": "/docs/svelte/context#Replacing-global-state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Lifecycle hooks"
              ],
              "content": "In Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between — when certain state is updated — is not related to the component as a whole; only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the (render) effects that the component sets up upon component initialization. Consequently, there's no such thing as a &quot;before update&quot;/&quot;after update&quot; hook.",
              "href": "/docs/svelte/lifecycle-hooks"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Lifecycle hooks",
                "tick"
              ],
              "content": "While there's no &quot;after update&quot; hook, you can use tick to ensure that the UI is updated before continuing. tick returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.<script>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('the component is about to update');\n\t\ttick().then(() => {\n\t\t\t\tconsole.log('the component just updated');\n\t\t});\n\t});\n</script>",
              "href": "/docs/svelte/lifecycle-hooks#tick"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Lifecycle hooks",
                "Deprecated: `beforeUpdate` / `afterUpdate`",
                "Chat window example"
              ],
              "content": "To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were already scrolled to the bottom), we need to measure the DOM before we update it.In Svelte 4, we do this with beforeUpdate, but this is a flawed approach — it fires before every update, whether it's relevant or not. In the example below, we need to introduce checks like updatingMessages to make sure we don't mess with the scroll position when someone toggles dark mode.With runes, we can use $effect.pre, which behaves the same as $effect but runs before the DOM is updated. As long as we explicitly reference messages inside the effect body, it will run whenever messages changes, but not when theme changes.beforeUpdate, and its equally troublesome counterpart afterUpdate, are therefore deprecated in Svelte 5.undefined\n\n<script>\n\timport { ---beforeUpdate, afterUpdate,--- tick } from 'svelte';\n\n\t---let updatingMessages = false;---\n\tlet theme = +++$state('dark')+++;\n\tlet messages = +++$state([])+++;\n\n\tlet viewport;\n\n\t---beforeUpdate(() => {---\n\t+++$effect.pre(() => {+++\n\t\t---if (!updatingMessages) return;---\n\t\t+++messages;+++\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => {\n\t\t\t\tviewport.scrollTo(0, viewport.scrollHeight);\n\t\t\t});\n\t\t}\n\n\t\t---updatingMessages = false;---\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tconst text = event.target.value;\n\t\t\tif (!text) return;\n\n\t\t\t---updatingMessages = true;---\n\t\t\tmessages = [...messages, text];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttheme = theme === 'dark' ? 'light' : 'dark';\n\t}\n</script>\n\n<div class:dark={theme === 'dark'}>\n\t<div bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t<p>{message}</p>\n\t\t{/each}\n\t</div>\n\n\t<input +++onkeydown+++={handleKeydown} />\n\n\t<button +++onclick+++={toggle}> Toggle dark mode </button>\n</div>",
              "href": "/docs/svelte/lifecycle-hooks#Deprecated:-beforeUpdate-afterUpdate-Chat-window-example"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Runtime",
                "Imperative component API",
                "unmount"
              ],
              "content": "Unmounts a component that was previously created with `mount` or `hydrate`.If options.outro is true, transitions will play before the component is removed from the DOM:import { mount, unmount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, { target: document.body });\n\n// later\nunmount(app, { outro: true });Returns a Promise that resolves after transitions have completed if options.outro is true, or immediately otherwise.",
              "href": "/docs/svelte/imperative-component-api#unmount"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Testing",
                "Unit and integration testing using Vitest"
              ],
              "content": "Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using Vitest.To get started, install Vitest:npm install -D vitestThen adjust your vite.config.js:\n \nimport { defineConfig } from +++'vitest/config'+++;\n\nexport default defineConfig({\n\t// ...\n\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n\tresolve: process.env.VITEST\n\t\t? {\n\t\t\t\tconditions: ['browser']\n\t\t\t}\n\t\t: undefined\n});[!NOTE] If loading the browser version of all your packages is undesirable, because (for example) you also test backend libraries, [you may need to resort to an alias configuration](https://github.com/testing-library/svelte-testing-library/issues/222#issuecomment-1909993331)\nYou can now write unit tests for code inside your .js/.ts files: \nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet double = multiplier(0, 2);\n\n\texpect(double.value).toEqual(0);\n\n\tdouble.set(5);\n\n\texpect(double.value).toEqual(10);\n}); \n/**\n * @param {number} initial\n * @param {number} k\n */\nexport function multiplier(initial, k) {\n\tlet count = $state(initial);\n\n\treturn {\n\t\tget value() {\n\t\t\treturn count * k;\n\t\t},\n\t\t/** @param {number} c */\n\t\tset: (c) => {\n\t\t\tcount = c;\n\t\t}\n\t};\n}",
              "href": "/docs/svelte/testing#Unit-and-integration-testing-using-Vitest"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Testing",
                "Unit and integration testing using Vitest",
                "Using runes inside your test files"
              ],
              "content": "Since Vitest processes your test files the same way as your source files, you can use runes inside your tests as long as the filename includes .svelte: \nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { multiplier } from './multiplier.svelte.js';\n\ntest('Multiplier', () => {\n\tlet count = $state(0);\n\tlet double = multiplier(() => count, 2);\n\n\texpect(double.value).toEqual(0);\n\n\tcount = 5;\n\n\texpect(double.value).toEqual(10);\n}); \n/**\n * @param {() => number} getCount\n * @param {number} k\n */\nexport function multiplier(getCount, k) {\n\treturn {\n\t\tget value() {\n\t\t\treturn getCount() * k;\n\t\t}\n\t};\n}If the code being tested uses effects, you need to wrap the test inside $effect.root: \nimport { flushSync } from 'svelte';\nimport { expect, test } from 'vitest';\nimport { logger } from './logger.svelte.js';\n\ntest('Effect', () => {\n\tconst cleanup = $effect.root(() => {\n\t\tlet count = $state(0);\n\n\t\t// logger uses an $effect to log updates of its input\n\t\tlet log = logger(() => count);\n\n\t\t// effects normally run after a microtask,\n\t\t// use flushSync to execute all pending effects synchronously\n\t\tflushSync();\n\t\texpect(log.value).toEqual([0]);\n\n\t\tcount = 1;\n\t\tflushSync();\n\n\t\texpect(log.value).toEqual([0, 1]);\n\t});\n\n\tcleanup();\n}); \n/**\n * @param {() => any} getValue\n */\nexport function logger(getValue) {\n\t/** @type {any[]} */\n\tlet log = $state([]);\n\n\t$effect(() => {\n\t\tlog.push(getValue());\n\t});\n\n\treturn {\n\t\tget value() {\n\t\t\treturn log;\n\t\t}\n\t};\n}",
              "href": "/docs/svelte/testing#Unit-and-integration-testing-using-Vitest-Using-runes-inside-your-test-files"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Testing",
                "Unit and integration testing using Vitest",
                "Component testing"
              ],
              "content": "It is possible to test your components in isolation using Vitest.[!NOTE] Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\nTo get started, install jsdom (a library that shims DOM APIs):npm install -D jsdomThen adjust your vite.config.js: \nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n\tplugins: [\n\t\t/* ... */\n\t],\n\ttest: {\n\t\t// If you are testing components client-side, you need to setup a DOM environment.\n\t\t// If not all your files should have this environment, you can use a\n\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n\t\tenvironment: 'jsdom'\n\t},\n\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n\tresolve: process.env.VITEST\n\t\t? {\n\t\t\t\tconditions: ['browser']\n\t\t\t}\n\t\t: undefined\n});After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results: \nimport { flushSync, mount, unmount } from 'svelte';\nimport { expect, test } from 'vitest';\nimport Component from './Component.svelte';\n\ntest('Component', () => {\n\t// Instantiate the component using Svelte's `mount` API\n\tconst component = mount(Component, {\n\t\ttarget: document.body, // `document` exists because of jsdom\n\t\tprops: { initial: 0 }\n\t});\n\n\texpect(document.body.innerHTML).toBe('<button>0</button>');\n\n\t// Click the button, then flush the changes so you can synchronously write expectations\n\tdocument.body.querySelector('button').click();\n\tflushSync();\n\n\texpect(document.body.innerHTML).toBe('<button>1</button>');\n\n\t// Remove the component from the DOM\n\tunmount(component);\n});While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like @testing-library/svelte can help streamline your tests. The above test could be rewritten like this: \nimport { render, screen } from '@testing-library/svelte';\nimport userEvent from '@testing-library/user-event';\nimport { expect, test } from 'vitest';\nimport Component from './Component.svelte';\n\ntest('Component', async () => {\n\tconst user = userEvent.setup();\n\trender(Component);\n\n\tconst button = screen.getByRole('button');\n\texpect(button).toHaveTextContent(0);\n\n\tawait user.click(button);\n\texpect(button).toHaveTextContent(1);\n});When writing component tests that involve two-way bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. @testing-library/svelte contains some examples.",
              "href": "/docs/svelte/testing#Unit-and-integration-testing-using-Vitest-Component-testing"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Testing",
                "E2E tests using Playwright"
              ],
              "content": "E2E (short for 'end to end') tests allow you to test your full application through the eyes of the user. This section uses Playwright as an example, but you can also use other solutions like Cypress or NightwatchJS.To get started with Playwright, either install it via the VS Code extension, or install it from the command line using npm init playwright. It is also part of the setup CLI when you run npx sv create.After you've done that, you should have a tests folder and a Playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port: \nconst config = {\n\twebServer: {\n\t\tcommand: 'npm run build && npm run preview',\n\t\tport: 4173\n\t},\n\ttestDir: 'tests',\n\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n};\n\nexport default config;You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions. \n \nimport { expect, test } from '@playwright/test';\n\ntest('home page has expected h1', async ({ page }) => {\n\tawait page.goto('/');\n\tawait expect(page.locator('h1')).toBeVisible();\n});",
              "href": "/docs/svelte/testing#E2E-tests-using-Playwright"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "TypeScript",
                "Preprocessor setup",
                "Using SvelteKit or Vite"
              ],
              "content": "The easiest way to get started is scaffolding a new SvelteKit project by typing npx sv create, following the prompts and choosing the TypeScript option. \n \nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\nconst config = {\n\tpreprocess: vitePreprocess()\n};\n\nexport default config;If you don't need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing npm create vite@latest and selecting the svelte-ts option.In both cases, a svelte.config.js with vitePreprocess will be added. Vite/SvelteKit will read from this config file.",
              "href": "/docs/svelte/typescript#Preprocessor-setup-Using-SvelteKit-or-Vite"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "TypeScript",
                "Typing `$state`"
              ],
              "content": "You can type $state like any other variable.let count: number = $state(0);If you don't give $state an initial value, part of its types will be undefined. \n// Error: Type 'number | undefined' is not assignable to type 'number'\nlet count: number = $state();If you know that the variable will be defined before you first use it, use an as casting. This is especially useful in the context of classes:class Counter {\n\tcount = $state() as number;\n\tconstructor(initial: number) {\n\t\tthis.count = initial;\n\t}\n}",
              "href": "/docs/svelte/typescript#Typing-$state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Custom elements",
                "Component lifecycle"
              ],
              "content": "Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.When a custom element is created, the Svelte component it wraps is not created right away. It is only created in the next tick after the connectedCallback is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the `extend` option.When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don't lead to unmounting the inner component.The inner Svelte component is destroyed in the next tick after the disconnectedCallback is invoked.",
              "href": "/docs/svelte/custom-elements#Component-lifecycle"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 4 migration guide",
                "Stricter types for Svelte functions"
              ],
              "content": "There are now stricter types for createEventDispatcher, Action, ActionReturn, and onMount:undefined\n \nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher<{\n\toptional: number | null;\n\trequired: string;\n\tnoArgument: null;\n}>();\n\n// Svelte version 3:\ndispatch('optional');\ndispatch('required'); // I can still omit the detail argument\ndispatch('noArgument', 'surprise'); // I can still add a detail argument\n\n// Svelte version 4 using TypeScript strict mode:\ndispatch('optional');\ndispatch('required'); // error, missing argument\ndispatch('noArgument', 'surprise'); // error, cannot pass an argumentundefined\n \n---const action: Action = (node, params) => { ... } // this is now an error if you use params in any way---\n+++const action: Action<HTMLElement, string> = (node, params) => { ... } // params is of type string+++undefined\n \n// Example where this change reveals an actual bug\nonMount(\n---\t// someCleanup() not called because function handed to onMount is async\n\tasync () => {\n\t\tconst something = await foo();---\n+++\t// someCleanup() is called because function handed to onMount is sync\n\t() => {\n\t\tfoo().then(something => {...});\n\t\t// ...\n\t\treturn () => someCleanup();\n\t}\n);",
              "href": "/docs/svelte/v4-migration-guide#Stricter-types-for-Svelte-functions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 4 migration guide",
                "Transitions are local by default"
              ],
              "content": "Transitions are now local by default to prevent confusion around page navigations. &quot;local&quot; means that a transition will not play if it's within a nested control flow block (each/if/await/key) and not the direct parent block but a block above it is created/destroyed. In the following example, the slide intro animation will only play when success goes from false to true, but it will not play when show goes from false to true:{#if show}\n\t...\n\t{#if success}\n\t\t<p in:slide>Success</p>\n\t{/each}\n{/if}To make transitions global, add the |global modifier - then they will play when any control flow block above is created/destroyed. The migration script will do this automatically for you. (#6686)",
              "href": "/docs/svelte/v4-migration-guide#Transitions-are-local-by-default"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 4 migration guide",
                "New eslint package"
              ],
              "content": "eslint-plugin-svelte3 is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package eslint-plugin-svelte. See this Github post for an instruction how to migrate. Alternatively, you can create a new project using npm create svelte@latest, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.",
              "href": "/docs/svelte/v4-migration-guide#New-eslint-package"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Reactivity syntax changes",
                "let → $state"
              ],
              "content": "In Svelte 4, a let declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the $state rune. Let's migrate the counter to runes mode by wrapping the counter in $state:<script>\n\tlet count = +++$state(0)+++;\n</script>Nothing else changes. count is still the number itself, and you read and write directly to it, without a wrapper like .value or getCount().[!DETAILS] Why we did this\n`let` being implicitly reactive at the top level worked great, but it meant that reactivity was constrained - a `let` declaration anywhere else was not reactive. This forced you to resort to using stores when refactoring code out of the top level of components for reuse. This meant you had to learn an entirely separate reactivity model, and the result often wasn't as nice to work with. Because reactivity is more explicit in Svelte 5, you can keep using the same API outside the top level of components. Head to [the tutorial](/tutorial) to learn more.",
              "href": "/docs/svelte/v5-migration-guide#Reactivity-syntax-changes-let-$state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Reactivity syntax changes",
                "$: → $derived/$effect"
              ],
              "content": "In Svelte 4, a $: statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the $derived rune:<script>\n\tlet count = $state(0);\n\t---$:--- +++const+++ double = +++$derived(count * 2)+++;\n</script>As with $state, nothing else changes. double is still the number itself, and you read it directly, without a wrapper like .value or getDouble().A $: statement could also be used to create side effects. In Svelte 5, this is achieved using the $effect rune:<script>\n\tlet count = $state(0);\n\n\t---$:---+++$effect(() =>+++ {\n\t\tif (count > 5) {\n\t\t\talert('Count is too high!');\n\t\t}\n\t}+++);+++\n</script>Note that when `$effect` runs is different than when $: runs.[!DETAILS] Why we did this\n`$:` was a great shorthand and easy to get started with: you could slap a `$:` in front of most code and it would somehow work. This intuitiveness was also its drawback the more complicated your code became, because it wasn't as easy to reason about. Was the intent of the code to create a derivation, or a side effect? With `$derived` and `$effect`, you have a bit more up-front decision making to do (spoiler alert: 90% of the time you want `$derived`), but future-you and other developers on your team will have an easier time.\n\nThere were also gotchas that were hard to spot:\n\n- `$:` only updated directly before rendering, which meant you could read stale values in-between rerenders\n- `$:` only ran once per tick, which meant that statements may run less often than you think\n- `$:` dependencies were determined through static analysis of the dependencies. This worked in most cases, but could break in subtle ways during a refactoring where dependencies would be for example moved into a function and no longer be visible as a result\n- `$:` statements were also ordered by using static analysis of the dependencies. In some cases there could be ties and the ordering would be wrong as a result, needing manual interventions. Ordering could also break while refactoring code and some dependencies no longer being visible as a result.\n\nLastly, it wasn't TypeScript-friendly (our editor tooling had to jump through some hoops to make it valid for TypeScript), which was a blocker for making Svelte's reactivity model truly universal.\n\n`$derived` and `$effect` fix all of these by\n\n- always returning the latest value\n- running as often as needed to be stable\n- determining the dependencies at runtime, and therefore being immune to refactorings\n- executing dependencies as needed and therefore being immune to ordering problems\n- being TypeScript-friendly",
              "href": "/docs/svelte/v5-migration-guide#Reactivity-syntax-changes-$:-$derived-$effect"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Event changes"
              ],
              "content": "Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the on: directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):<script>\n\tlet count = $state(0);\n</script>\n\n<button on---:---click={() => count++}>\n\tclicks: {count}\n</button>Since they're just properties, you can use the normal shorthand syntax...<script>\n\tlet count = $state(0);\n\n\tfunction onclick() {\n\t\tcount++;\n\t}\n</script>\n\n<button {onclick}>\n\tclicks: {count}\n</button>...though when using a named event handler function it's usually better to use a more descriptive name.",
              "href": "/docs/svelte/v5-migration-guide#Event-changes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Event changes",
                "Component events"
              ],
              "content": "In Svelte 4, components could emit events by creating a dispatcher with createEventDispatcher.This function is deprecated in Svelte 5. Instead, components should accept callback props - which means you then pass functions as properties to these components:<!--- file: App.svelte --->\n<script>\n\timport Pump from './Pump.svelte';\n\n\tlet size = $state(15);\n\tlet burst = $state(false);\n\n\tfunction reset() {\n\t\tsize = 15;\n\t\tburst = false;\n\t}\n</script>\n\n<Pump\n\t---on:---inflate={(power) => {\n\t\tsize += power---.detail---;\n\t\tif (size > 75) burst = true;\n\t}}\n\t---on:---deflate={(power) => {\n\t\tif (size > 0) size -= power---.detail---;\n\t}}\n/>\n\n{#if burst}\n\t<button onclick={reset}>new balloon</button>\n\t<span class=\"boom\">💥</span>\n{:else}\n\t<span class=\"balloon\" style=\"scale: {0.01 * size}\">\n\t\t🎈\n\t</span>\n{/if}<!--- file: Pump.svelte --->\n<script>\n\t---import { createEventDispatcher } from 'svelte';---\n\t---const dispatch = createEventDispatcher();---\n\n\t+++let { inflate, deflate } = $props();+++\n\tlet power = $state(5);\n</script>\n\n<button onclick={() => ---dispatch('inflate', power)---+++inflate(power)+++}>\n\tinflate\n</button>\n<button onclick={() => ---dispatch('deflate', power)---+++deflate(power)+++}>\n\tdeflate\n</button>\n<button onclick={() => power--}>-</button>\nPump power: {power}\n<button onclick={() => power++}>+</button>",
              "href": "/docs/svelte/v5-migration-guide#Event-changes-Component-events"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Event changes",
                "Event modifiers"
              ],
              "content": "In Svelte 4, you can add event modifiers to handlers:<button on:click|once|preventDefault={handler}>...</button>Modifiers are specific to on: and as such do not work with modern event handlers. Adding things like event.preventDefault() inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.Since event handlers are just functions, you can create your own wrappers as necessary:<script>\n\tfunction once(fn) {\n\t\treturn function (event) {\n\t\t\tif (fn) fn.call(this, event);\n\t\t\tfn = null;\n\t\t};\n\t}\n\n\tfunction preventDefault(fn) {\n\t\treturn function (event) {\n\t\t\tevent.preventDefault();\n\t\t\tfn.call(this, event);\n\t\t};\n\t}\n</script>\n\n<button onclick={once(preventDefault(handler))}>...</button>There are three modifiers — capture, passive and nonpassive — that can't be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.For capture, we add the modifier to the event name:<button onclickcapture={...}>...</button>Changing the `passive` option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it — and you probably don't! — then you will need to use an action to apply the event handler yourself.",
              "href": "/docs/svelte/v5-migration-guide#Event-changes-Event-modifiers"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Event changes",
                "Multiple event handlers"
              ],
              "content": "In Svelte 4, this is possible:<button on:click={one} on:click={two}>...</button>Duplicate attributes/properties on elements — which now includes event handlers — are not allowed. Instead, do this:<button\n\tonclick={(e) => {\n\t\tone(e);\n\t\ttwo(e);\n\t}}\n>\n\t...\n</button>When spreading props, local event handlers must go after the spread, or they risk being overwritten:<button\n\t{...props}\n\tonclick={(e) => {\n\t\tdoStuff(e);\n\t\tprops.onclick?.(e);\n\t}}\n>\n\t...\n</button>[!DETAILS] Why we did this\n`createEventDispatcher` was always a bit boilerplate-y:\n\n- import the function\n- call the function to get a dispatch function\n- call said dispatch function with a string and possibly a payload\n- retrieve said payload on the other end through a `.detail` property, because the event itself was always a `CustomEvent`\n\nIt was always possible to use component callback props, but because you had to listen to DOM events using `on:`, it made sense to use `createEventDispatcher` for component events due to syntactical consistency. Now that we have event attributes (`onclick`), it's the other way around: Callback props are now the more sensible thing to do.\n\nThe removal of event modifiers is arguably one of the changes that seems like a step back for those who've liked the shorthand syntax of event modifiers. Given that they are not used that frequently, we traded a smaller surface area for more explicitness. Modifiers also were inconsistent, because most of them were only useable on DOM elements.\n\nMultiple listeners for the same event are also no longer possible, but it was something of an anti-pattern anyway, since it impedes readability: if there are many attributes, it becomes harder to spot that there are two handlers unless they are right next to each other. It also implies that the two handlers are independent, when in fact something like `event.stopImmediatePropagation()` inside `one` would prevent `two` from being called.\n\nBy deprecating `createEventDispatcher` and the `on:` directive in favour of callback props and normal element properties, we:\n\n- reduce Svelte's learning curve\n- remove boilerplate, particularly around `createEventDispatcher`\n- remove the overhead of creating `CustomEvent` objects for events that may not even have listeners\n- add the ability to spread event handlers\n- add the ability to know which event handlers were provided to a component\n- add the ability to express whether a given event handler is required or optional\n- increase type safety (previously, it was effectively impossible for Svelte to guarantee that a component didn't emit a particular event)",
              "href": "/docs/svelte/v5-migration-guide#Event-changes-Multiple-event-handlers"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Snippets instead of slots",
                "Passing data back up"
              ],
              "content": "In Svelte 4, you would pass data to a <slot /> and then retrieve it with let: in the parent component. In Svelte 5, snippets take on that responsibility:<!--- file: App.svelte --->\n<script>\n\timport List from './List.svelte';\n</script>\n\n<List items={['one', 'two', 'three']} ---let:item--->\n\t+++{#snippet item(text)}+++\n\t\t<span>{text}</span>\n\t+++{/snippet}+++\n\t---<span slot=\"empty\">No items yet</span>---\n\t+++{#snippet empty()}\n\t\t<span>No items yet</span>\n\t{/snippet}+++\n</List><!--- file: List.svelte --->\n<script>\n\tlet { items, +++item, empty+++ } = $props();\n</script>\n\n{#if items.length}\n\t<ul>\n\t\t{#each items as entry}\n\t\t\t<li>\n\t\t\t\t---<slot item={entry} />---\n\t\t\t\t+++{@render item(entry)}+++\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n{:else}\n\t---<slot name=\"empty\" />---\n\t+++{@render empty?.()}+++\n{/if}[!DETAILS] Why we did this\nSlots were easy to get started with, but the more advanced the use case became, the more involved and confusing the syntax became:\n\n- the `let:` syntax was confusing to many people as it _creates_ a variable whereas all other `:` directives _receive_ a variable\n- the scope of a variable declared with `let:` wasn't clear. In the example above, it may look like you can use the `item` slot prop in the `empty` slot, but that's not true\n- named slots had to be applied to an element using the `slot` attribute. Sometimes you didn't want to create an element, so we had to add the `<svelte:fragment>` API\n- named slots could also be applied to a component, which changed the semantics of where `let:` directives are available (even today us maintainers often don't know which way around it works)\n\nSnippets solve all of these problems by being much more readable and clear. At the same time they're more powerful as they allow you to define sections of UI that you can render _anywhere_, not just passing them as props to a component.",
              "href": "/docs/svelte/v5-migration-guide#Snippets-instead-of-slots-Passing-data-back-up"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Migration script",
                "run"
              ],
              "content": "You may see that the migration script converts some of your $: statements to a run function which is imported from svelte/legacy. This happens if the migration script couldn't reliably migrate the statement to a $derived and concluded this is a side effect instead. In some cases this may be wrong and it's best to change this to use a $derived instead. In other cases it may be right, but since $: statements also ran on the server but $effect does not, it isn't safe to transform it as such. Instead, run is used as a stopgap solution. run mimics most of the characteristics of $:, in that it runs on the server once, and runs as $effect.pre on the client ($effect.pre runs before changes are applied to the DOM; most likely you want to use $effect instead).<script>\n\t---import { run } from 'svelte/legacy';---\n\t---run(() => {---\n\t+++$effect(() => {+++\n\t\t// some side effect code\n\t})\n</script>",
              "href": "/docs/svelte/v5-migration-guide#Migration-script-run"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Migration script",
                "Things that are not automigrated"
              ],
              "content": "The migration script does not convert createEventDispatcher. You need to adjust those parts manually. It doesn't do it because it's too risky because it could result in breakage for users of the component, which the migration script cannot find out.The migration script does not convert beforeUpdate/afterUpdate. It doesn't do it because it's impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of $effect.pre (runs at the same time as beforeUpdate did) and tick (imported from svelte, allows you to wait until changes are applied to the DOM and then do some work).",
              "href": "/docs/svelte/v5-migration-guide#Migration-script-Things-that-are-not-automigrated"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Components are no longer classes"
              ],
              "content": "In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use mount or hydrate (imported from svelte) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you're using Svelte without SvelteKit, you'll likely have a main.js file (or similar) which you need to adjust:+++import { mount } from 'svelte';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\") });---\n+++const app = mount(App, { target: document.getElementById(\"app\") });+++\n\nexport default app;mount and hydrate have the exact same API. The difference is that hydrate will pick up the Svelte's server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with accessors: true). They do not come with the $on, $set and $destroy methods you may know from the class component API. These are its replacements:For $on, instead of listening to events, pass them via the events property on the options argument.+++import { mount } from 'svelte';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\") });\napp.$on('event', callback);---\n+++const app = mount(App, { target: document.getElementById(\"app\"), events: { event: callback } });+++[!NOTE] Note that using `events` is discouraged — instead, [use callbacks](#Event-changes)\nFor $set, use $state instead to create a reactive property object and manipulate it. If you're doing this inside a .js or .ts file, adjust the ending to include .svelte, i.e. .svelte.js or .svelte.ts.+++import { mount } from 'svelte';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\"), props: { foo: 'bar' } });\napp.$set({ foo: 'baz' });---\n+++const props = $state({ foo: 'bar' });\nconst app = mount(App, { target: document.getElementById(\"app\"), props });\nprops.foo = 'baz';+++For $destroy, use unmount instead.+++import { mount, unmount } from 'svelte';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\"), props: { foo: 'bar' } });\napp.$destroy();---\n+++const app = mount(App, { target: document.getElementById(\"app\") });\nunmount(app);+++As a stop-gap-solution, you can also use createClassComponent or asClassComponent (imported from svelte/legacy) instead to keep the same API known from Svelte 4 after instantiating.+++import { createClassComponent } from 'svelte/legacy';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\") });---\n+++const app = createClassComponent({ component: App, target: document.getElementById(\"app\") });+++\n\nexport default app;If this component is not under your control, you can use the compatibility.componentApi compiler option for auto-applied backwards compatibility, which means code using new Component(...) keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add $set and $on methods for all component instances you get through bind:this./// svelte.config.js\nexport default {\n\tcompilerOptions: {\n\t\tcompatibility: {\n\t\t\tcomponentApi: 4\n\t\t}\n\t}\n};Note that mount and hydrate are not synchronous, so things like onMount won't have been called by the time the function returns and the pending block of promises will not have been rendered yet (because #await waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call flushSync (import from 'svelte') after calling mount/hydrate.",
              "href": "/docs/svelte/v5-migration-guide#Components-are-no-longer-classes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Components are no longer classes",
                "Component typing changes"
              ],
              "content": "The change from classes towards functions is also reflected in the typings: SvelteComponent, the base class from Svelte 4, is deprecated in favour of the new Component type which defines the function shape of a Svelte component. To manually define a component shape in a d.ts file:import type { Component } from 'svelte';\nexport declare const MyComponent: Component<{\n\tfoo: string;\n}>;To declare that a component of a certain type is required:import { ComponentA, ComponentB } from 'component-library';\n---import type { SvelteComponent } from 'svelte';---\n+++import type { Component } from 'svelte';+++\n\n---let C: typeof SvelteComponent<{ foo: string }> = $state(---\n+++let C: Component<{ foo: string }> = $state(+++\n\tMath.random() ? ComponentA : ComponentB\n);The two utility types ComponentEvents and ComponentType are also deprecated. ComponentEvents is obsolete because events are defined as callback props now, and ComponentType is obsolete because the new Component type is the component type already (i.e. ComponentType<SvelteComponent<{ prop: string }>> is equivalent to Component<{ prop: string }>).",
              "href": "/docs/svelte/v5-migration-guide#Components-are-no-longer-classes-Component-typing-changes"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "`<svelte:component>` is no longer necessary"
              ],
              "content": "In Svelte 4, components are static — if you render <Thing>, and the value of Thing changes, nothing happens. To make it dynamic you had to use <svelte:component>.This is no longer true in Svelte 5:<script>\n\timport A from './A.svelte';\n\timport B from './B.svelte';\n\n\tlet Thing = $state();\n</script>\n\n<select bind:value={Thing}>\n\t<option value={A}>A</option>\n\t<option value={B}>B</option>\n</select>\n\n<!-- these are equivalent -->\n<Thing />\n<svelte:component this={Thing} />While migrating, keep in mind that your component's name should be capitalized (Thing) to distinguish it from elements, unless using dot notation.",
              "href": "/docs/svelte/v5-migration-guide#is-no-longer-necessary"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "`<svelte:component>` is no longer necessary",
                "Dot notation indicates a component"
              ],
              "content": "In Svelte 4, <foo.bar> would create an element with a tag name of &quot;foo.bar&quot;. In Svelte 5, foo.bar is treated as a component instead. This is particularly useful inside each blocks:{#each items as item}\n\t<item.component {...item.props} />\n{/each}",
              "href": "/docs/svelte/v5-migration-guide#is-no-longer-necessary-Dot-notation-indicates-a-component"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Breaking changes in runes mode",
                "`accessors` option is ignored"
              ],
              "content": "Setting the accessors option to true makes properties of a component directly accessible on the component instance.<svelte:options accessors={true} />\n\n<script>\n\t// available via componentInstance.name\n\texport let name;\n</script>In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.<script>\n\tlet { name } = $props();\n\t// available via componentInstance.getName()\n\texport const getName = () => name;\n</script>Alternatively, if the place where they are instantiated is under your control, you can also make use of runes inside .js/.ts files by adjusting their ending to include .svelte, i.e. .svelte.js or .svelte.ts, and then use $state:+++import { mount } from 'svelte';+++\nimport App from './App.svelte'\n\n---const app = new App({ target: document.getElementById(\"app\"), props: { foo: 'bar' } });\napp.foo = 'baz'---\n+++const props = $state({ foo: 'bar' });\nconst app = mount(App, { target: document.getElementById(\"app\"), props });\nprops.foo = 'baz';+++",
              "href": "/docs/svelte/v5-migration-guide#Breaking-changes-in-runes-mode-accessors-option-is-ignored"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Breaking changes in runes mode",
                "`immutable` option is ignored"
              ],
              "content": "Setting the immutable option has no effect in runes mode. This concept is replaced by how $state and its variations work.",
              "href": "/docs/svelte/v5-migration-guide#Breaking-changes-in-runes-mode-immutable-option-is-ignored"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Svelte 5 migration guide",
                "Breaking changes in runes mode",
                "Classes are no longer \"auto-reactive\""
              ],
              "content": "In Svelte 4, doing the following triggered reactivity:<script>\n\tlet foo = new Foo();\n</script>\n\n<button on:click={() => (foo.value = 1)}>{foo.value}</button\n>This is because the Svelte compiler treated the assignment to foo.value as an instruction to update anything that referenced foo. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define value as a reactive $state field on the Foo class. Wrapping new Foo() with $state(...) will have no effect — only vanilla objects and arrays are made deeply reactive.",
              "href": "/docs/svelte/v5-migration-guide#Breaking-changes-in-runes-mode-Classes-are-no-longer-auto-reactive"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Frequently asked questions",
                "How do I test Svelte apps?"
              ],
              "content": "How your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.A Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).Unit Tests: Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup Vitest for unit testing. There are a number of other test runners that could be used as well.Component Tests: Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like Vitest to solutions that leverage an actual browser to provide a visual testing capability such as Playwright or Cypress.End-to-End Tests: To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup Playwright for end-to-end testing. There are many other E2E test libraries available for use as well.Some resources for getting started with testing:undefined",
              "href": "/docs/svelte/faq#How-do-I-test-Svelte-apps"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Misc",
                "Frequently asked questions",
                "Is there a router?"
              ],
              "content": "The official routing library is SvelteKit. SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.However, you can use any router library. A lot of people use page.js. There's also navaid, which is very similar. And universal-router, which is isomorphic with child routes, but without built-in history support.If you prefer a declarative HTML approach, there's the isomorphic svelte-routing library and a fork of it called svelte-navigator containing some additional functionality.If you need hash-based routing on the client side, check out the hash option in SvelteKit, svelte-spa-router, or abstract-state-router.Routify is another filesystem-based router, similar to SvelteKit's router. Version 3 supports Svelte's native SSR.You can see a community-maintained list of routers on sveltesociety.dev.",
              "href": "/docs/svelte/faq#Is-there-a-router"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte"
              ],
              "content": "import {\n\tSvelteComponent,\n\tSvelteComponentTyped,\n\tafterUpdate,\n\tbeforeUpdate,\n\tcreateEventDispatcher,\n\tcreateRawSnippet,\n\tflushSync,\n\tgetAllContexts,\n\tgetContext,\n\thasContext,\n\thydrate,\n\tmount,\n\tonDestroy,\n\tonMount,\n\tsetContext,\n\ttick,\n\tunmount,\n\tuntrack\n} from 'svelte';",
              "href": "/docs/svelte/svelte"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "beforeUpdate"
              ],
              "content": "Use `$effect.pre` instead\nSchedules a callback to run immediately before the component is updated after any state change.The first time the callback runs will be before the initial onMount.In runes mode use $effect.pre instead.\nfunction beforeUpdate(fn: () => void): void;",
              "href": "/docs/svelte/svelte#beforeUpdate"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "createEventDispatcher"
              ],
              "content": "Use callback props and/or the $host() rune instead — see migration guide\nCreates an event dispatcher that can be used to dispatch component events.\nEvent dispatchers are functions that can take two arguments: name and detail.Component events created with createEventDispatcher create a\nCustomEvent.\nThese events do not bubble.\nThe detail argument corresponds to the CustomEvent.detail\nproperty and can contain any type of data.The event dispatcher can be typed to narrow the allowed event names and the type of the detail argument:const dispatch = createEventDispatcher<{\n loaded: null; // does not take a detail argument\n change: string; // takes a detail argument of type string, which is required\n optional: number | null; // takes an optional detail argument of type number\n}>();\nfunction createEventDispatcher<\n\tEventMap extends Record<string, any> = any\n>(): EventDispatcher<EventMap>;",
              "href": "/docs/svelte/svelte#createEventDispatcher"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "createRawSnippet"
              ],
              "content": "Create a snippet programmatically\nfunction createRawSnippet<Params extends unknown[]>(\n\tfn: (...params: Getters<Params>) => {\n\t\trender: () => string;\n\t\tsetup?: (element: Element) => void | (() => void);\n\t}\n): Snippet<Params>;",
              "href": "/docs/svelte/svelte#createRawSnippet"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "getAllContexts"
              ],
              "content": "Retrieves the whole context map that belongs to the closest parent component.\nMust be called during component initialisation. Useful, for example, if you\nprogrammatically create a component and want to pass the existing context to it.\nfunction getAllContexts<\n\tT extends Map<any, any> = Map<any, any>\n>(): T;",
              "href": "/docs/svelte/svelte#getAllContexts"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "tick"
              ],
              "content": "Returns a promise that resolves once any pending state changes have been applied.\nfunction tick(): Promise<void>;",
              "href": "/docs/svelte/svelte#tick"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "untrack"
              ],
              "content": "When used inside a `$derived` or `$effect`,\nany state read inside fn will not be treated as a dependency.$effect(() => {\n\t// this will run when `data` changes, but not when `time` changes\n\tsave(data, {\n\t\ttimestamp: untrack(() => time)\n\t});\n});\nfunction untrack<T>(fn: () => T): T;",
              "href": "/docs/svelte/svelte#untrack"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "Component"
              ],
              "content": "Can be used to create strongly typed Svelte components.",
              "href": "/docs/svelte/svelte#Component"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte",
                "Component",
                "Example:"
              ],
              "content": "You have component library on npm called component-library, from which\nyou export a component called MyComponent. For Svelte+TypeScript users,\nyou want to provide typings. Therefore you create a index.d.ts:import type { Component } from 'svelte';\nexport declare const MyComponent: Component<{ foo: string }> {}Typing this makes it possible for IDEs like VS Code with the Svelte extension\nto provide intellisense and to use the component like this in a Svelte file\nwith TypeScript:<script lang=\"ts\">\n\timport { MyComponent } from \"component-library\";\n</script>\n<MyComponent foo={'bar'} />\ninterface Component<\n\tProps extends Record<string, any> = {},\n\tExports extends Record<string, any> = {},\n\tBindings extends keyof Props | '' = string\n> {/*…*/}\n(\n\tthis: void,\n\tinternals: ComponentInternals,\n\tprops: Props\n): {\n\t/**\n\t * @deprecated This method only exists when using one of the legacy compatibility helpers, which\n\t * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)\n\t * for more info.\n\t */\n\t$on?(type: string, callback: (e: any) => void): () => void;\n\t/**\n\t * @deprecated This method only exists when using one of the legacy compatibility helpers, which\n\t * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)\n\t * for more info.\n\t */\n\t$set?(props: Partial<Props>): void;\n} & Exports;\n\nundefined\n\n\n\nelement?: typeof HTMLElement;\nThe custom element version of the component. Only present if compiled with the customElement compiler option",
              "href": "/docs/svelte/svelte#Component-Example:"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/action",
                "Action"
              ],
              "content": "Actions are functions that are called when an element is created.\nYou can use this interface to type such actions.\nThe following example defines an action that only works on <div> elements\nand optionally accepts a parameter which it has a default value for:export const myAction: Action<HTMLDivElement, { someProperty: boolean } | undefined> = (node, param = { someProperty: true }) => {\n\t// ...\n}Action<HTMLDivElement> and Action<HTMLDivElement, undefined> both signal that the action accepts no parameters.You can return an object with methods update and destroy from the function and type which additional attributes and events it has.\nSee interface ActionReturn for more details.\ninterface Action<\n\tElement = HTMLElement,\n\tParameter = undefined,\n\tAttributes extends Record<string, any> = Record<\n\t\tnever,\n\t\tany\n\t>\n> {/*…*/}\n<Node extends Element>(\n\t...args: undefined extends Parameter\n\t\t? [node: Node, parameter?: Parameter]\n\t\t: [node: Node, parameter: Parameter]\n): void | ActionReturn<Parameter, Attributes>;",
              "href": "/docs/svelte/svelte-action#Action"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/compiler",
                "CompileOptions"
              ],
              "content": "interface CompileOptions extends ModuleCompileOptions {/*…*/}\nname?: string;\nSets the name of the resulting JavaScript class (though the compiler will rename it if it would otherwise conflict with other variables in scope).\nIf unspecified, will be inferred from filename\n\ncustomElement?: boolean;\n\nundefined\n\nIf true, tells the compiler to generate a custom element constructor instead of a regular Svelte component.\n\naccessors?: boolean;\n\nundefined\n\nIf true, getters and setters will be created for the component's props. If false, they will only be created for readonly exported values (i.e. those declared with const, class and function). If compiling with customElement: true this option defaults to true.\n\nnamespace?: Namespace;\n\nundefined\n\nThe namespace of the element; e.g., &quot;html&quot;, &quot;svg&quot;, &quot;mathml&quot;.\n\nimmutable?: boolean;\n\nundefined\n\nIf true, tells the compiler that you promise not to mutate any objects.\nThis allows it to be less conservative about checking whether values have changed.\n\ncss?: 'injected' | 'external';\nundefined\n\n\ncssHash?: CssHashGetter;\n\nundefined\n\nA function that takes a { hash, css, name, filename } argument and returns the string that is used as a classname for scoped CSS.\nIt defaults to returning svelte-${hash(css)}.\n\npreserveComments?: boolean;\n\nundefined\n\nIf true, your HTML comments will be preserved in the output. By default, they are stripped out.\n\npreserveWhitespace?: boolean;\n\nundefined\n\nIf true, whitespace inside and between elements is kept as you typed it, rather than removed or collapsed to a single space where possible.\n\nrunes?: boolean | undefined;\n\nundefined\n\nSet to true to force the compiler into runes mode, even if there are no indications of runes usage.\nSet to false to force the compiler into ignoring runes, even if there are indications of runes usage.\nSet to undefined (the default) to infer runes mode from the component code.\nIs always true for JS/TS modules compiled with Svelte.\nWill be true by default in Svelte 6.\nNote that setting this to true in your svelte.config.js will force runes mode for your entire project, including components in node_modules,\nwhich is likely not what you want. If you're using Vite, consider using dynamicCompileOptions instead.\n\ndiscloseVersion?: boolean;\n\nundefined\n\nIf true, exposes the Svelte major version in the browser by adding it to a Set stored in the global window.__svelte.v.\n\ncompatibility?: {/*…*/}\n\nundefined\n\n\ncomponentApi?: 4 | 5;\n\nundefined\n\nApplies a transformation so that the default export of Svelte files can still be instantiated the same way as in Svelte 4 —\nas a class when compiling for the browser (as though using createClassComponent(MyComponent, {...}) from svelte/legacy)\nor as an object with a .render(...) method when compiling for the server\n\n\nsourcemap?: object | string;\n\nundefined\n\nAn initial sourcemap that will be merged into the final output sourcemap.\nThis is usually the preprocessor sourcemap.\n\noutputFilename?: string;\n\nundefined\n\nUsed for your JavaScript sourcemap.\n\ncssOutputFilename?: string;\n\nundefined\n\nUsed for your CSS sourcemap.\n\nhmr?: boolean;\n\nundefined\n\nIf true, compiles components with hot reloading support.\n\nmodernAst?: boolean;\n\nundefined\n\nIf true, returns the modern version of the AST.\nWill become true by default in Svelte 6, and the option will be removed in Svelte 7.",
              "href": "/docs/svelte/svelte-compiler#CompileOptions"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/legacy"
              ],
              "content": "This module provides various functions for use during the migration, since some features can't be replaced one to one with new features. All imports are marked as deprecated and should be migrated away from over time. \nimport {\n\tasClassComponent,\n\tcreateBubbler,\n\tcreateClassComponent,\n\thandlers,\n\tnonpassive,\n\tonce,\n\tpassive,\n\tpreventDefault,\n\trun,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted\n} from 'svelte/legacy';",
              "href": "/docs/svelte/svelte-legacy"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/legacy",
                "createBubbler"
              ],
              "content": "Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\nFunction to create a bubble function that mimic the behavior of on:click without handler available in svelte 4.\nfunction createBubbler(): (\n\ttype: string\n) => (event: Event) => boolean;",
              "href": "/docs/svelte/svelte-legacy#createBubbler"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/legacy",
                "createClassComponent"
              ],
              "content": "Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\nTakes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\nfunction createClassComponent<\n\tProps extends Record<string, any>,\n\tExports extends Record<string, any>,\n\tEvents extends Record<string, any>,\n\tSlots extends Record<string, any>\n>(\n\toptions: ComponentConstructorOptions<Props> & {\n\t\tcomponent:\n\t\t\t| ComponentType<SvelteComponent<Props, Events, Slots>>\n\t\t\t| Component<Props>;\n\t}\n): SvelteComponent<Props, Events, Slots> & Exports;",
              "href": "/docs/svelte/svelte-legacy#createClassComponent"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/motion",
                "prefersReducedMotion"
              ],
              "content": "Available since 5.7.0\nA media query that matches if the user prefers reduced motion.<script>\n\timport { prefersReducedMotion } from 'svelte/motion';\n\timport { fly } from 'svelte/transition';\n\n\tlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>\n\ttoggle\n</button>\n\n{#if visible}\n\t<p transition:fly={{ y: prefersReducedMotion.current ? 0 : 200 }}>\n\t\tflies in, unless the user prefers reduced motion\n\t</p>\n{/if}\nconst prefersReducedMotion: MediaQuery;",
              "href": "/docs/svelte/svelte-motion#prefersReducedMotion"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/motion",
                "spring"
              ],
              "content": "Use `Spring` instead\nThe spring function in Svelte creates a store whose value is animated, with a motion that simulates the behavior of a spring. This means when the value changes, instead of transitioning at a steady rate, it &quot;bounces&quot; like a spring would, depending on the physics parameters provided. This adds a level of realism to the transitions and can enhance the user experience.\nfunction spring<T = any>(\n\tvalue?: T | undefined,\n\topts?: SpringOpts | undefined\n): Spring<T>;",
              "href": "/docs/svelte/svelte-motion#spring"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/motion",
                "tweened"
              ],
              "content": "Use `Tween` instead\nA tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.\nfunction tweened<T>(\n\tvalue?: T | undefined,\n\tdefaults?: TweenedOptions<T> | undefined\n): Tweened<T>;",
              "href": "/docs/svelte/svelte-motion#tweened"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/reactivity"
              ],
              "content": "Svelte provides reactive versions of various built-ins like `Map`, `Set` and `URL` that can be used just like their native counterparts, as well as a handful of additional utilities for handling reactivity. \nimport {\n\tMediaQuery,\n\tSvelteDate,\n\tSvelteMap,\n\tSvelteSet,\n\tSvelteURL,\n\tSvelteURLSearchParams,\n\tcreateSubscriber\n} from 'svelte/reactivity';",
              "href": "/docs/svelte/svelte-reactivity"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/reactivity",
                "SvelteMap"
              ],
              "content": "A reactive version of the built-in `Map` object.\nReading contents of the map (by iterating, or by reading map.size or calling map.get(...) or map.has(...) as in the tic-tac-toe example below) in an effect or derived\nwill cause it to be re-evaluated as necessary when the map is updated.Note that values in a reactive map are not made deeply reactive.<script>\n\timport { SvelteMap } from 'svelte/reactivity';\n\timport { result } from './game.js';\n\n\tlet board = new SvelteMap();\n\tlet player = $state('x');\n\tlet winner = $derived(result(board));\n\n\tfunction reset() {\n\t\tplayer = 'x';\n\t\tboard.clear();\n\t}\n</script>\n\n<div class=\"board\">\n\t{#each Array(9), i}\n\t\t<button\n\t\t\tdisabled={board.has(i) || winner}\n\t\t\tonclick={() => {\n\t\t\t\tboard.set(i, player);\n\t\t\t\tplayer = player === 'x' ? 'o' : 'x';\n\t\t\t}}\n\t\t>{board.get(i)}</button>\n\t{/each}\n</div>\n\n{#if winner}\n\t<p>{winner} wins!</p>\n\t<button onclick={reset}>reset</button>\n{:else}\n\t<p>{player} is next</p>\n{/if}\nclass SvelteMap<K, V> extends Map<K, V> {/*…*/}\nconstructor(value?: Iterable<readonly [K, V]> | null | undefined);\n\nset(key: K, value: V): this;",
              "href": "/docs/svelte/svelte-reactivity#SvelteMap"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/reactivity",
                "SvelteURLSearchParams"
              ],
              "content": "A reactive version of the built-in `URLSearchParams` object.\nReading its contents (by iterating, or by calling params.get(...) or params.getAll(...) as in the example below) in an effect or derived\nwill cause it to be re-evaluated as necessary when the params are updated.<script>\n\timport { SvelteURLSearchParams } from 'svelte/reactivity';\n\n\tconst params = new SvelteURLSearchParams('message=hello');\n\n\tlet key = $state('key');\n\tlet value = $state('value');\n</script>\n\n<input bind:value={key} />\n<input bind:value={value} />\n<button onclick={() => params.append(key, value)}>append</button>\n\n<p>?{params.toString()}</p>\n\n{#each params as [key, value]}\n\t<p>{key}: {value}</p>\n{/each}\nclass SvelteURLSearchParams extends URLSearchParams {/*…*/}\n[REPLACE](params: URLSearchParams): void;",
              "href": "/docs/svelte/svelte-reactivity#SvelteURLSearchParams"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/reactivity",
                "createSubscriber"
              ],
              "content": "Available since 5.7.0\nReturns a subscribe function that, if called in an effect (including expressions in the template),\ncalls its start callback with an update function. Whenever update is called, the effect re-runs.If start returns a function, it will be called when the effect is destroyed.If subscribe is called in multiple effects, start will only be called once as long as the effects\nare active, and the returned teardown function will only be called when all effects are destroyed.It's best understood with an example. Here's an implementation of `MediaQuery`: \nimport { createSubscriber } from 'svelte/reactivity';\nimport { on } from 'svelte/events';\n\nexport class MediaQuery {\n\t#query;\n\t#subscribe;\n\n\tconstructor(query) {\n\t\tthis.#query = window.matchMedia(`(${query})`);\n\n\t\tthis.#subscribe = createSubscriber((update) => {\n\t\t\t// when the `change` event occurs, re-run any effects that read `this.current`\n\t\t\tconst off = on(this.#query, 'change', update);\n\n\t\t\t// stop listening when all the effects are destroyed\n\t\t\treturn () => off();\n\t\t});\n\t}\n\n\tget current() {\n\t\tthis.#subscribe();\n\n\t\t// Return the current state of the query, whether or not we're in an effect\n\t\treturn this.#query.matches;\n\t}\n}\nfunction createSubscriber(\n\tstart: (update: () => void) => (() => void) | void\n): () => void;",
              "href": "/docs/svelte/svelte-reactivity#createSubscriber"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/transition",
                "crossfade"
              ],
              "content": "The crossfade function creates a pair of transitions called send and receive. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the fallback transition is used.\nfunction crossfade({\n\tfallback,\n\t...defaults\n}: CrossfadeParams & {\n\tfallback?: (\n\t\tnode: Element,\n\t\tparams: CrossfadeParams,\n\t\tintro: boolean\n\t) => TransitionConfig;\n}): [\n\t(\n\t\tnode: any,\n\t\tparams: CrossfadeParams & {\n\t\t\tkey: any;\n\t\t}\n\t) => () => TransitionConfig,\n\t(\n\t\tnode: any,\n\t\tparams: CrossfadeParams & {\n\t\t\tkey: any;\n\t\t}\n\t) => () => TransitionConfig\n];",
              "href": "/docs/svelte/svelte-transition#crossfade"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "svelte/transition",
                "draw"
              ],
              "content": "Animates the stroke of an SVG element, like a snake in a tube. in transitions begin with the path invisible and draw the path to the screen over time. out transitions start in a visible state and gradually erase the path. draw only works with elements that have a getTotalLength method, like <path> and <polyline>.\nfunction draw(\n\tnode: SVGElement & {\n\t\tgetTotalLength(): number;\n\t},\n\t{\n\t\tdelay,\n\t\tspeed,\n\t\tduration,\n\t\teasing\n\t}?: DrawParams | undefined\n): TransitionConfig;",
              "href": "/docs/svelte/svelte-transition#draw"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Compiler errors"
              ],
              "content": "animation_duplicate\nAn element can only have one 'animate' directiveanimation_invalid_placement\nAn element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` blockanimation_missing_key\nAn element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block. Did you forget to add a key to your each block?attribute_contenteditable_dynamic\n'contenteditable' attribute cannot be dynamic if element uses two-way bindingattribute_contenteditable_missing\n'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindingsattribute_duplicate\nAttributes need to be uniqueattribute_empty_shorthand\nAttribute shorthand cannot be emptyattribute_invalid_event_handler\nEvent attribute must be a JavaScript expression, not a stringattribute_invalid_multiple\n'multiple' attribute must be static if select uses two-way bindingattribute_invalid_name\n'%name%' is not a valid attribute nameattribute_invalid_sequence_expression\nSequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parenthesesattribute_invalid_type\n'type' attribute must be a static text value if input uses two-way bindingattribute_unquoted_sequence\nAttribute values containing `{...}` must be enclosed in quote marks, unless the value only contains the expressionbind_group_invalid_expression\n`bind:group` can only bind to an Identifier or MemberExpressionbind_group_invalid_snippet_parameter\nCannot `bind:group` to a snippet parameterbind_invalid_expression\nCan only bind to an Identifier or MemberExpression or a `{get, set}` pairbind_invalid_name\n`bind:%name%` is not a valid binding`bind:%name%` is not a valid binding. %explanation%bind_invalid_parens\n`bind:%name%={get, set}` must not have surrounding parenthesesbind_invalid_target\n`bind:%name%` can only be used with %elements%bind_invalid_value\nCan only bind to state or propsbindable_invalid_location\n`$bindable()` can only be used inside a `$props()` declarationblock_duplicate_clause\n%name% cannot appear more than once within a blockblock_invalid_continuation_placement\n{:...} block is invalid at this position (did you forget to close the preceding element or block?)block_invalid_elseif\n'elseif' should be 'else if'block_invalid_placement\n{#%name% ...} block cannot be %location%block_unclosed\nBlock was left openblock_unexpected_character\nExpected a `%character%` character immediately following the opening bracketblock_unexpected_close\nUnexpected block closing tagcomponent_invalid_directive\nThis type of directive is not valid on componentsconst_tag_cycle\nCyclical dependency detected: %cycle%const_tag_invalid_expression\n{@const ...} must consist of a single variable declarationconst_tag_invalid_placement\n`{@const}` must be the immediate child of `{#snippet}`, `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<svelte:fragment>`, `<svelte:boundary` or `<Component>`constant_assignment\nCannot assign to %thing%constant_binding\nCannot bind to %thing%css_empty_declaration\nDeclaration cannot be emptycss_expected_identifier\nExpected a valid CSS identifiercss_global_block_invalid_combinator\nA `:global` selector cannot follow a `%name%` combinatorcss_global_block_invalid_declaration\nA top-level `:global {...}` block can only contain rules, not declarationscss_global_block_invalid_list\nA `:global` selector cannot be part of a selector list with entries that don't contain `:global`The following CSS is invalid::global, x {\n    y {\n        color: red;\n    }\n}This is mixing a :global block, which means &quot;everything in here is unscoped&quot;, with a scoped selector (x in this case). As a result it's not possible to transform the inner selector (y in this case) into something that satisfies both requirements. You therefore have to split this up into two selectors::global {\n    y {\n        color: red;\n    }\n}\n\nx y {\n    color: red;\n}css_global_block_invalid_modifier\nA `:global` selector cannot modify an existing selectorcss_global_block_invalid_modifier_start\nA `:global` selector can only be modified if it is a descendant of other selectorscss_global_invalid_placement\n`:global(...)` can be at the start or end of a selector sequence, but not in the middlecss_global_invalid_selector\n`:global(...)` must contain exactly one selectorcss_global_invalid_selector_list\n`:global(...)` must not contain type or universal selectors when used in a compound selectorcss_nesting_selector_invalid_placement\nNesting selectors can only be used inside a rule or as the first selector inside a lone `:global(...)`css_selector_invalid\nInvalid selectorcss_type_selector_invalid_placement\n`:global(...)` must not be followed by a type selectordebug_tag_invalid_arguments\n{@debug ...} arguments must be identifiers, not arbitrary expressionsdeclaration_duplicate\n`%name%` has already been declareddeclaration_duplicate_module_import\nCannot declare a variable with the same name as an import inside `<script module>`derived_invalid_export\nCannot export derived state from a module. To expose the current derived value, export a function returning its valuedirective_invalid_value\nDirective value must be a JavaScript expression enclosed in curly bracesdirective_missing_name\n`%type%` name cannot be emptydollar_binding_invalid\nThe $ name is reserved, and cannot be used for variables and importsdollar_prefix_invalid\nThe $ prefix is reserved, and cannot be used for variables and importseach_item_invalid_assignment\nCannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. `array[i] = value` instead of `entry = value`, or `bind:value={array[i]}` instead of `bind:value={entry}`)In legacy mode, it was possible to reassign or bind to the each block argument itself:<script>\n\tlet array = [1, 2, 3];\n</script>\n\n{#each array as entry}\n\t<!-- reassignment -->\n\t<button on:click={() => entry = 4}>change</button>\n\n\t<!-- binding -->\n\t<input bind:value={entry}>\n{/each}This turned out to be buggy and unpredictable, particularly when working with derived values (such as array.map(...)), and as such is forbidden in runes mode. You can achieve the same outcome by using the index instead:<script>\n\tlet array = $state([1, 2, 3]);\n</script>\n\n{#each array as entry, i}\n\t<!-- reassignment -->\n\t<button onclick={() => array[i] = 4}>change</button>\n\n\t<!-- binding -->\n\t<input bind:value={array[i]}>\n{/each}effect_invalid_placement\n`$effect()` can only be used as an expression statementelement_invalid_closing_tag\n`</%name%>` attempted to close an element that was not openelement_invalid_closing_tag_autoclosed\n`</%name%>` attempted to close element that was already automatically closed by `<%reason%>` (cannot nest `<%reason%>` inside `<%name%>`)element_unclosed\n`<%name%>` was left openevent_handler_invalid_component_modifier\nEvent modifiers other than 'once' can only be used on DOM elementsevent_handler_invalid_modifier\nValid event modifiers are %list%event_handler_invalid_modifier_combination\nThe '%modifier1%' and '%modifier2%' modifiers cannot be used togetherexpected_attribute_value\nExpected attribute valueexpected_block_type\nExpected 'if', 'each', 'await', 'key' or 'snippet'expected_identifier\nExpected an identifierexpected_pattern\nExpected identifier or destructure patternexpected_token\nExpected token %token%expected_whitespace\nExpected whitespaceexport_undefined\n`%name%` is not definedglobal_reference_invalid\n`%name%` is an illegal variable name. To reference a global variable called `%name%`, use `globalThis.%name%`host_invalid_placement\n`$host()` can only be used inside custom element component instancesillegal_element_attribute\n`<%name%>` does not support non-event attributes or spread attributesimport_svelte_internal_forbidden\nImports of `svelte/internal/*` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from `svelte/internal/*` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use caseinspect_trace_generator\n`$inspect.trace(...)` cannot be used inside a generator functioninspect_trace_invalid_placement\n`$inspect.trace(...)` must be the first statement of a function bodyinvalid_arguments_usage\nThe arguments keyword cannot be used within the template or at the top level of a componentjs_parse_error\n%message%legacy_export_invalid\nCannot use `export let` in runes mode — use `$props()` insteadlegacy_props_invalid\nCannot use `$$props` in runes modelegacy_reactive_statement_invalid\n`$:` is not allowed in runes mode, use `$derived` or `$effect` insteadlegacy_rest_props_invalid\nCannot use `$$restProps` in runes modelet_directive_invalid_placement\n`let:` directive at invalid positionmixed_event_handler_syntaxes\nMixing old (on:%name%) and new syntaxes for event handling is not allowed. Use only the on%name% syntaxmodule_illegal_default_export\nA component cannot have a default exportnode_invalid_placement\n%message%. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.HTML restricts where certain elements can appear. In case of a violation the browser will 'repair' the HTML in a way that breaks Svelte's assumptions about the structure of your components. Some examples:undefined\noptions_invalid_value\nInvalid compiler option: %details%options_removed\nInvalid compiler option: %details%options_unrecognised\nUnrecognised compiler option %keypath%props_duplicate\nCannot use `%rune%()` more than onceprops_id_invalid_placement\n`$props.id()` can only be used at the top level of components as a variable declaration initializerprops_illegal_name\nDeclaring or accessing a prop starting with `$$` is illegal (they are reserved for Svelte internals)props_invalid_identifier\n`$props()` can only be used with an object destructuring patternprops_invalid_pattern\n`$props()` assignment must not contain nested properties or computed keysprops_invalid_placement\n`$props()` can only be used at the top level of components as a variable declaration initializerreactive_declaration_cycle\nCyclical dependency detected: %cycle%render_tag_invalid_call_expression\nCalling a snippet function using apply, bind or call is not allowedrender_tag_invalid_expression\n`{@render ...}` tags can only contain call expressionsrender_tag_invalid_spread_argument\ncannot use spread arguments in `{@render ...}` tagsrune_invalid_arguments\n`%rune%` cannot be called with argumentsrune_invalid_arguments_length\n`%rune%` must be called with %args%rune_invalid_computed_property\nCannot access a computed property of a runerune_invalid_name\n`%name%` is not a valid runerune_invalid_spread\n`%rune%` cannot be called with a spread argumentrune_invalid_usage\nCannot use `%rune%` rune in non-runes moderune_missing_parentheses\nCannot use rune without parenthesesrune_removed\nThe `%name%` rune has been removedrune_renamed\n`%name%` is now `%replacement%`runes_mode_invalid_import\n%name% cannot be used in runes modescript_duplicate\nA component can have a single top-level `<script>` element and/or a single top-level `<script module>` elementscript_invalid_attribute_value\nIf the `%name%` attribute is supplied, it must be a boolean attributescript_invalid_context\nIf the context attribute is supplied, its value must be \"module\"script_reserved_attribute\nThe `%name%` attribute is reserved and cannot be usedslot_attribute_duplicate\nDuplicate slot name '%name%' in <%component%>slot_attribute_invalid\nslot attribute must be a static valueslot_attribute_invalid_placement\nElement with a slot='...' attribute must be a child of a component or a descendant of a custom elementslot_default_duplicate\nFound default slot content alongside an explicit slot=\"default\"slot_element_invalid_attribute\n`<slot>` can only receive attributes and (optionally) let directivesslot_element_invalid_name\nslot attribute must be a static valueslot_element_invalid_name_default\n`default` is a reserved word — it cannot be used as a slot nameslot_snippet_conflict\nCannot use `<slot>` syntax and `{@render ...}` tags in the same component. Migrate towards `{@render ...}` tags completelysnippet_conflict\nCannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet blocksnippet_invalid_export\nAn exported snippet can only reference things declared in a `<script module>`, or other exportable snippetsIt's possible to export a snippet from a <script module> block, but only if it doesn't reference anything defined inside a non-module-level <script>. For example you can't do this...<script module>\n\texport { greeting };\n</script>\n\n<script>\n\tlet message = 'hello';\n</script>\n\n{#snippet greeting(name)}\n\t<p>{message} {name}!</p>\n{/snippet}...because greeting references message, which is defined in the second <script>.snippet_invalid_rest_parameter\nSnippets do not support rest parameters; use an array insteadsnippet_parameter_assignment\nCannot reassign or bind to snippet parametersnippet_shadowing_prop\nThis snippet is shadowing the prop `%prop%` with the same namestate_invalid_export\nCannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's propertiesstate_invalid_placement\n`%rune%(...)` can only be used as a variable declaration initializer or a class fieldstore_invalid_scoped_subscription\nCannot subscribe to stores that are not declared at the top level of the componentstore_invalid_subscription\nCannot reference store value inside `<script module>`store_invalid_subscription_module\nCannot reference store value outside a `.svelte` fileUsing a $ prefix to refer to the value of a store is only possible inside .svelte files, where Svelte can automatically create subscriptions when a component is mounted and unsubscribe when the component is unmounted. Consider migrating to runes instead.style_directive_invalid_modifier\n`style:` directive can only use the `important` modifierstyle_duplicate\nA component can have a single top-level `<style>` elementsvelte_body_illegal_attribute\n`<svelte:body>` does not support non-event attributes or spread attributessvelte_boundary_invalid_attribute\nValid attributes on `<svelte:boundary>` are `onerror` and `failed`svelte_boundary_invalid_attribute_value\nAttribute value must be a non-string expressionsvelte_component_invalid_this\nInvalid component definition — must be an `{expression}`svelte_component_missing_this\n`<svelte:component>` must have a 'this' attributesvelte_element_missing_this\n`<svelte:element>` must have a 'this' attribute with a valuesvelte_fragment_invalid_attribute\n`<svelte:fragment>` can only have a slot attribute and (optionally) a let: directivesvelte_fragment_invalid_placement\n`<svelte:fragment>` must be the direct child of a componentsvelte_head_illegal_attribute\n`<svelte:head>` cannot have attributes nor directivessvelte_meta_duplicate\nA component can only have one `<%name%>` elementsvelte_meta_invalid_content\n<%name%> cannot have childrensvelte_meta_invalid_placement\n`<%name%>` tags cannot be inside elements or blockssvelte_meta_invalid_tag\nValid `<svelte:...>` tag names are %list%svelte_options_deprecated_tag\n\"tag\" option is deprecated — use \"customElement\" insteadsvelte_options_invalid_attribute\n`<svelte:options>` can only receive static attributessvelte_options_invalid_attribute_value\nValue must be %list%, if specifiedsvelte_options_invalid_customelement\n\"customElement\" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: \"open\" | \"none\"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }svelte_options_invalid_customelement_props\n\"props\" must be a statically analyzable object literal of the form \"{ [key: string]: { attribute?: string; reflect?: boolean; type?: \"String\" | \"Boolean\" | \"Number\" | \"Array\" | \"Object\" }\"svelte_options_invalid_customelement_shadow\n\"shadow\" must be either \"open\" or \"none\"svelte_options_invalid_tagname\nTag name must be lowercase and hyphenatedSee https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name for more information on valid tag namessvelte_options_reserved_tagname\nTag name is reservedSee https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name for more information on valid tag namessvelte_options_unknown_attribute\n`<svelte:options>` unknown attribute '%name%'svelte_self_invalid_placement\n`<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to componentstag_invalid_name\nExpected a valid element or component name. Components must have a valid variable name or dot notation expressiontag_invalid_placement\n{@%name% ...} tag cannot be %location%textarea_invalid_content\nA `<textarea>` can have either a value attribute or (equivalently) child content, but not bothtitle_illegal_attribute\n`<title>` cannot have attributes nor directivestitle_invalid_content\n`<title>` can only contain text and {tags}transition_conflict\nCannot use `%type%:` alongside existing `%existing%:` directivetransition_duplicate\nCannot use multiple `%type%:` directives on a single elementtypescript_invalid_feature\nTypeScript language features like %feature% are not natively supported, and their use is generally discouraged. Outside of `<script>` tags, these features are not supported. For use within `<script>` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using `vitePreprocess`, make sure to specifically enable preprocessing script tags (`vitePreprocess({ script: true })`)unexpected_eof\nUnexpected end of inputunexpected_reserved_word\n'%word%' is a reserved word in JavaScript and cannot be used hereunterminated_string_constant\nUnterminated string constantvoid_element_invalid_content\nVoid elements cannot have children or closing tags",
              "href": "/docs/svelte/compiler-errors"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Compiler warnings"
              ],
              "content": "Svelte warns you at compile time if it catches potential mistakes, such as writing inaccessible markup.Some warnings may be incorrect in your concrete use case. You can disable such false positives by placing a <!-- svelte-ignore <code> --> comment above the line that causes the warning. Example:<!-- svelte-ignore a11y_autofocus -->\n<input autofocus />You can list multiple rules in a single comment (separated by commas), and add an explanatory note (in parentheses) alongside them:<!-- svelte-ignore a11y_click_events_have_key_events, a11y_no_static_element_interactions (because of reasons) -->\n<div onclick>...</div>\na11y_accesskey\nAvoid using accesskeyEnforce no accesskey on element. Access keys are HTML attributes that allow web developers to assign keyboard shortcuts to elements. Inconsistencies between keyboard shortcuts and keyboard commands used by screen reader and keyboard-only users create accessibility complications. To avoid complications, access keys should not be used.\n<!-- A11y: Avoid using accesskey -->\n<div accesskey=\"z\"></div>a11y_aria_activedescendant_has_tabindex\nAn element with an aria-activedescendant attribute should have a tabindex valueAn element with aria-activedescendant must be tabbable, so it must either have an inherent tabindex or declare tabindex as an attribute.<!-- A11y: Elements with attribute aria-activedescendant should have tabindex value -->\n<div aria-activedescendant=\"some-id\"></div>a11y_aria_attributes\n`<%name%>` should not have aria-* attributesCertain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example meta, html, script, style. This rule enforces that these DOM elements do not contain the aria-* props.<!-- A11y: <meta> should not have aria-* attributes -->\n<meta aria-hidden=\"false\" />a11y_autocomplete_valid\n'%value%' is an invalid value for 'autocomplete' on `<input type=\"%type%\">`a11y_autofocus\nAvoid using autofocusEnforce that autofocus is not used on elements. Autofocusing elements can cause usability issues for sighted and non-sighted users alike.<!-- A11y: Avoid using autofocus -->\n<input autofocus />a11y_click_events_have_key_events\nVisible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as `<button type=\"button\">` or `<a>` might be more appropriateEnforce that visible, non-interactive elements with an onclick event are accompanied by a keyboard event handler.Users should first consider whether an interactive element might be more appropriate such as a <button type=&quot;button&quot;> element for actions or <a> element for navigations. These elements are more semantically meaningful and will have built-in key handling. E.g. Space and Enter will trigger a <button> and Enter will trigger an <a> element.If a non-interactive element is required then onclick should be accompanied by an onkeyup or onkeydown handler that enables the user to perform equivalent actions via the keyboard. In order for the user to be able to trigger a key press, the element will also need to be focusable by adding a `tabindex`. While an onkeypress handler will also silence this warning, it should be noted that the keypress event is deprecated.<!-- A11y: visible, non-interactive elements with an onclick event must be accompanied by a keyboard event handler. -->\n<div onclick={() => {}}></div>Coding for the keyboard is important for users with physical disabilities who cannot use a mouse, AT compatibility, and screenreader users.a11y_consider_explicit_label\nButtons and links should either contain text or have an `aria-label` or `aria-labelledby` attributea11y_distracting_elements\nAvoid `<%name%>` elementsEnforces that no distracting elements are used. Elements that can be visually distracting can cause accessibility issues with visually impaired users. Such elements are most likely deprecated, and should be avoided.The following elements are visually distracting: <marquee> and <blink>.<!-- A11y: Avoid <marquee> elements -->\n<marquee></marquee>a11y_figcaption_index\n`<figcaption>` must be first or last child of `<figure>`a11y_figcaption_parent\n`<figcaption>` must be an immediate child of `<figure>`Enforce that certain DOM elements have the correct structure.<!-- A11y: <figcaption> must be an immediate child of <figure> -->\n<div>\n\t<figcaption>Image caption</figcaption>\n</div>a11y_hidden\n`<%name%>` element should not be hiddenCertain DOM elements are useful for screen reader navigation and should not be hidden.\n<!-- A11y: <h2> element should not be hidden -->\n<h2 aria-hidden=\"true\">invisible header</h2>a11y_img_redundant_alt\nScreenreaders already announce `<img>` elements as an imageEnforce img alt attribute does not contain the word image, picture, or photo. Screen readers already announce img elements as an image. There is no need to use words such as image, photo, and/or picture.<img src=\"foo\" alt=\"Foo eating a sandwich.\" />\n\n<!-- aria-hidden, won't be announced by screen reader -->\n<img src=\"bar\" aria-hidden=\"true\" alt=\"Picture of me taking a photo of an image\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"foo\" alt=\"Photo of foo being weird.\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"bar\" alt=\"Image of me at a bar!\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"foo\" alt=\"Picture of baz fixing a bug.\" />a11y_incorrect_aria_attribute_type\nThe value of '%attribute%' must be a %type%Enforce that only the correct type of value is used for aria attributes. For example, aria-hidden\nshould only receive a boolean.<!-- A11y: The value of 'aria-hidden' must be exactly one of true or false -->\n<div aria-hidden=\"yes\"></div>a11y_incorrect_aria_attribute_type_boolean\nThe value of '%attribute%' must be either 'true' or 'false'. It cannot be emptya11y_incorrect_aria_attribute_type_id\nThe value of '%attribute%' must be a string that represents a DOM element IDa11y_incorrect_aria_attribute_type_idlist\nThe value of '%attribute%' must be a space-separated list of strings that represent DOM element IDsa11y_incorrect_aria_attribute_type_integer\nThe value of '%attribute%' must be an integera11y_incorrect_aria_attribute_type_token\nThe value of '%attribute%' must be exactly one of %values%a11y_incorrect_aria_attribute_type_tokenlist\nThe value of '%attribute%' must be a space-separated list of one or more of %values%a11y_incorrect_aria_attribute_type_tristate\nThe value of '%attribute%' must be exactly one of true, false, or mixeda11y_interactive_supports_focus\nElements with the '%role%' interactive role must have a tabindex valueEnforce that elements with an interactive role and interactive handlers (mouse or key press) must be focusable or tabbable.<!-- A11y: Elements with the 'button' interactive role must have a tabindex value. -->\n<div role=\"button\" onkeypress={() => {}} />a11y_invalid_attribute\n'%href_value%' is not a valid %href_attribute% attributeEnforce that attributes important for accessibility have a valid value. For example, href should not be empty, '#', or javascript:.<!-- A11y: '' is not a valid href attribute -->\n<a href=\"\">invalid</a>a11y_label_has_associated_control\nA form label must be associated with a controlEnforce that a label tag has a text label and an associated control.There are two supported ways to associate a label with a control:undefined\n<label for=\"id\">B</label>\n\n<label>C <input type=\"text\" /></label>\n\n<!-- A11y: A form label must be associated with a control. -->\n<label>A</label>a11y_media_has_caption\n`<video>` elements must have a `<track kind=\"captions\">`Providing captions for media is essential for deaf users to follow along. Captions should be a transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information. Not only is this important for accessibility, but can also be useful for all users in the case that the media is unavailable (similar to alt text on an image when an image is unable to load).The captions should contain all important and relevant information to understand the corresponding media. This may mean that the captions are not a 1:1 mapping of the dialogue in the media content. However, captions are not necessary for video components with the muted attribute.<video><track kind=\"captions\" /></video>\n\n<audio muted></audio>\n\n<!-- A11y: Media elements must have a <track kind=\\\"captions\\\"> -->\n<video></video>\n\n<!-- A11y: Media elements must have a <track kind=\\\"captions\\\"> -->\n<video><track /></video>a11y_misplaced_role\n`<%name%>` should not have role attributeCertain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example meta, html, script, style. This rule enforces that these DOM elements do not contain the role props.<!-- A11y: <meta> should not have role attribute -->\n<meta role=\"tooltip\" />a11y_misplaced_scope\nThe scope attribute should only be used with `<th>` elementsThe scope attribute should only be used on <th> elements.\n<!-- A11y: The scope attribute should only be used with <th> elements -->\n<div scope=\"row\" />a11y_missing_attribute\n`<%name%>` element should have %article% %sequence% attributeEnforce that attributes required for accessibility are present on an element. This includes the following checks:undefined\n<!-- A11y: <input type=\\\"image\\\"> element should have an alt, aria-label or aria-labelledby attribute -->\n<input type=\"image\" />\n\n<!-- A11y: <html> element should have a lang attribute -->\n<html></html>\n\n<!-- A11y: <a> element should have an href attribute -->\n<a>text</a>a11y_missing_content\n`<%name%>` element should contain textEnforce that heading elements (h1, h2, etc.) and anchors have content and that the content is accessible to screen readers<!-- A11y: <a> element should have child content -->\n<a href=\"/foo\"></a>\n\n<!-- A11y: <h1> element should have child content -->\n<h1></h1>a11y_mouse_events_have_key_events\n'%event%' event must be accompanied by '%accompanied_by%' eventEnforce that onmouseover and onmouseout are accompanied by onfocus and onblur, respectively. This helps to ensure that any functionality triggered by these mouse events is also accessible to keyboard users.<!-- A11y: onmouseover must be accompanied by onfocus -->\n<div onmouseover={handleMouseover} />\n\n<!-- A11y: onmouseout must be accompanied by onblur -->\n<div onmouseout={handleMouseout} />a11y_no_abstract_role\nAbstract role '%role%' is forbiddena11y_no_interactive_element_to_noninteractive_role\n`<%element%>` cannot have role '%role%'WAI-ARIA roles should not be used to convert an interactive element to a non-interactive element. Non-interactive ARIA roles include article, banner, complementary, img, listitem, main, region and tooltip.<!-- A11y: <textarea> cannot have role 'listitem' -->\n<textarea role=\"listitem\"></textarea>a11y_no_noninteractive_element_interactions\nNon-interactive element `<%element%>` should not be assigned mouse or keyboard event listenersA non-interactive element does not support event handlers (mouse and key handlers). Non-interactive elements include <main>, <area>, <h1> (,<h2>, etc), <p>, <img>, <li>, <ul> and <ol>. Non-interactive WAI-ARIA roles include article, banner, complementary, img, listitem, main, region and tooltip.<!-- `A11y: Non-interactive element <li> should not be assigned mouse or keyboard event listeners.` -->\n<li onclick={() => {}}></li>\n\n<!-- `A11y: Non-interactive element <div> should not be assigned mouse or keyboard event listeners.` -->\n<div role=\"listitem\" onclick={() => {}}></div>a11y_no_noninteractive_element_to_interactive_role\nNon-interactive element `<%element%>` cannot have interactive role '%role%'WAI-ARIA roles should not be used to convert a non-interactive element to an interactive element. Interactive ARIA roles include button, link, checkbox, menuitem, menuitemcheckbox, menuitemradio, option, radio, searchbox, switch and textbox.<!-- A11y: Non-interactive element <h3> cannot have interactive role 'searchbox' -->\n<h3 role=\"searchbox\">Button</h3>a11y_no_noninteractive_tabindex\nnoninteractive element cannot have nonnegative tabIndex valueTab key navigation should be limited to elements on the page that can be interacted with.\n<!-- A11y: noninteractive element cannot have nonnegative tabIndex value -->\n<div tabindex=\"0\"></div>a11y_no_redundant_roles\nRedundant role '%role%'Some HTML elements have default ARIA roles. Giving these elements an ARIA role that is already set by the browser has no effect and is redundant.<!-- A11y: Redundant role 'button' -->\n<button role=\"button\">...</button>\n\n<!-- A11y: Redundant role 'img' -->\n<img role=\"img\" src=\"foo.jpg\" />a11y_no_static_element_interactions\n`<%element%>` with a %handler% handler must have an ARIA roleElements like <div> with interactive handlers like click must have an ARIA role.\n<!-- A11y: <div> with click handler must have an ARIA role -->\n<div onclick={() => ''}></div>a11y_positive_tabindex\nAvoid tabindex values above zeroAvoid positive tabindex property values. This will move elements out of the expected tab order, creating a confusing experience for keyboard users.\n<!-- A11y: avoid tabindex values above zero -->\n<div tabindex=\"1\"></div>a11y_role_has_required_aria_props\nElements with the ARIA role \"%role%\" must have the following attributes defined: %props%Elements with ARIA roles must have all required attributes for that role.<!-- A11y: A11y: Elements with the ARIA role \"checkbox\" must have the following attributes defined: \"aria-checked\" -->\n<span role=\"checkbox\" aria-labelledby=\"foo\" tabindex=\"0\"></span>a11y_role_supports_aria_props\nThe attribute '%attribute%' is not supported by the role '%role%'Elements with explicit or implicit roles defined contain only aria-* properties supported by that role.<!-- A11y: The attribute 'aria-multiline' is not supported by the role 'link'. -->\n<div role=\"link\" aria-multiline></div>\n\n<!-- A11y: The attribute 'aria-required' is not supported by the role 'listitem'. This role is implicit on the element <li>. -->\n<li aria-required></li>a11y_role_supports_aria_props_implicit\nThe attribute '%attribute%' is not supported by the role '%role%'. This role is implicit on the element `<%name%>`Elements with explicit or implicit roles defined contain only aria-* properties supported by that role.<!-- A11y: The attribute 'aria-multiline' is not supported by the role 'link'. -->\n<div role=\"link\" aria-multiline></div>\n\n<!-- A11y: The attribute 'aria-required' is not supported by the role 'listitem'. This role is implicit on the element <li>. -->\n<li aria-required></li>a11y_unknown_aria_attribute\nUnknown aria attribute 'aria-%attribute%'Unknown aria attribute 'aria-%attribute%'. Did you mean '%suggestion%'?Enforce that only known ARIA attributes are used. This is based on the WAI-ARIA States and Properties spec.<!-- A11y: Unknown aria attribute 'aria-labeledby' (did you mean 'labelledby'?) -->\n<input type=\"image\" aria-labeledby=\"foo\" />a11y_unknown_role\nUnknown role '%role%'Unknown role '%role%'. Did you mean '%suggestion%'?Elements with ARIA roles must use a valid, non-abstract ARIA role. A reference to role definitions can be found at WAI-ARIA site.\n<!-- A11y: Unknown role 'toooltip' (did you mean 'tooltip'?) -->\n<div role=\"toooltip\"></div>attribute_avoid_is\nThe \"is\" attribute is not supported cross-browser and should be avoidedattribute_global_event_reference\nYou are referencing `globalThis.%name%`. Did you forget to declare a variable with that name?attribute_illegal_colon\nAttributes should not contain ':' characters to prevent ambiguity with Svelte directivesattribute_invalid_property_name\n'%wrong%' is not a valid HTML attribute. Did you mean '%right%'?attribute_quoted\nQuoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotesbind_invalid_each_rest\nThe rest operator (...) will create a new object and binding '%name%' with the original object will not workblock_empty\nEmpty blockcomponent_name_lowercase\n`<%name%>` will be treated as an HTML element unless it begins with a capital lettercss_unused_selector\nUnused CSS selector \"%name%\"Svelte traverses both the template and the <style> tag to find out which of the CSS selectors are not used within the template, so it can remove them.In some situations a selector may target an element that is not 'visible' to the compiler, for example because it is part of an {@html ...} tag or you're overriding styles in a child component. In these cases, use `:global` to preserve the selector as-is:<div class=\"post\">{@html content}</div>\n\n<style>\n  .post :global {\n    p {...}\n  }\n</style>element_invalid_self_closing_tag\nSelf-closing HTML tags for non-void elements are ambiguous — use `<%name% ...></%name%>` rather than `<%name% ... />`In HTML, there's no such thing as a self-closing tag. While this looks like a self-contained element with some text next to it...<div>\n\t<span class=\"icon\" /> some text!\n</div>...a spec-compliant HTML parser (such as a browser) will in fact parse it like this, with the text inside the icon:<div>\n\t<span class=\"icon\"> some text! </span>\n</div>Some templating languages (including Svelte) will 'fix' HTML by turning <span /> into <span></span>. Others adhere to the spec. Both result in ambiguity and confusion when copy-pasting code between different contexts, and as such Svelte prompts you to resolve the ambiguity directly by having an explicit closing tag.To automate this, run the dedicated migration:npx sv migrate self-closing-tagsIn a future version of Svelte, self-closing tags may be upgraded from a warning to an error.event_directive_deprecated\nUsing `on:%name%` to listen to the %name% event is deprecated. Use the event attribute `on%name%` insteadSee the migration guide for more info.export_let_unused\nComponent has unused export property '%name%'. If it is for external reference only, please consider using `export const %name%`legacy_code\n`%code%` is no longer valid — please use `%suggestion%` insteadlegacy_component_creation\nSvelte 5 components are no longer classes. Instantiate them using `mount` or `hydrate` (imported from 'svelte') instead.See the migration guide for more info.node_invalid_placement_ssr\n%message%. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a `hydration_mismatch` warningHTML restricts where certain elements can appear. In case of a violation the browser will 'repair' the HTML in a way that breaks Svelte's assumptions about the structure of your components. Some examples:undefined\nThis code will work when the component is rendered on the client (which is why this is a warning rather than an error), but if you use server rendering it will cause hydration to fail.non_reactive_update\n`%name%` is updated, but is not declared with `$state(...)`. Changing its value will not correctly trigger updatesThis warning is thrown when the compiler detects the following:undefined\nIn this case, changing the value will not correctly trigger updates. Example:<script>\n\tlet reactive = $state('reactive');\n\tlet stale = 'stale';\n</script>\n\n<p>This value updates: {reactive}</p>\n<p>This value does not update: {stale}</p>\n\n<button onclick={() => {\n\tstale = 'updated';\n\treactive = 'updated';\n}}>update</button>To fix this, wrap your variable declaration with $state.options_deprecated_accessors\nThe `accessors` option has been deprecated. It will have no effect in runes modeoptions_deprecated_immutable\nThe `immutable` option has been deprecated. It will have no effect in runes modeoptions_missing_custom_element\nThe `customElement` option is used when generating a custom element. Did you forget the `customElement: true` compile option?options_removed_enable_sourcemap\nThe `enableSourcemap` option has been removed. Source maps are always generated now, and tooling can choose to ignore themoptions_removed_hydratable\nThe `hydratable` option has been removed. Svelte components are always hydratable nowoptions_removed_loop_guard_timeout\nThe `loopGuardTimeout` option has been removedoptions_renamed_ssr_dom\n`generate: \"dom\"` and `generate: \"ssr\"` options have been renamed to \"client\" and \"server\" respectivelyperf_avoid_inline_class\nAvoid 'new class' — instead, declare the class at the top level scopeperf_avoid_nested_class\nAvoid declaring classes below the top level scopereactive_declaration_invalid_placement\nReactive declarations only exist at the top level of the instance scriptreactive_declaration_module_script_dependency\nReassignments of module-level declarations will not cause reactive statements to updatescript_context_deprecated\n`context=\"module\"` is deprecated, use the `module` attribute instead<script ---context=\"module\"--- +++module+++>\n\tlet foo = 'bar';\n</script>script_unknown_attribute\nUnrecognized attribute — should be one of `generics`, `lang` or `module`. If this exists for a preprocessor, ensure that the preprocessor removes itslot_element_deprecated\nUsing `<slot>` to render parent content is deprecated. Use `{@render ...}` tags insteadSee the migration guide for more info.state_referenced_locally\nThis reference only captures the initial value of `%name%`. Did you mean to reference it inside a %type% instead?This warning is thrown when the compiler detects the following:undefined\nThis 'breaks the link' to the original state declaration. For example, if you pass the state to a function, the function loses access to the state once it is reassigned:<!--- file: Parent.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\n\tlet count = $state(0);\n\n\t// warning: state_referenced_locally\n\tsetContext('count', count);\n</script>\n\n<button onclick={() => count++}>\n\tincrement\n</button><!--- file: Child.svelte --->\n<script>\n\timport { getContext } from 'svelte';\n\n\tconst count = getContext('count');\n</script>\n\n<!-- This will never update -->\n<p>The count is {count}</p>To fix this, reference the variable such that it is lazily evaluated. For the above example, this can be achieved by wrapping count in a function:<!--- file: Parent.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\n\tlet count = $state(0);\n\tsetContext('count', +++() => count+++);\n</script>\n\n<button onclick={() => count++}>\n\tincrement\n</button><!--- file: Child.svelte --->\n<script>\n\timport { getContext } from 'svelte';\n\n\tconst count = getContext('count');\n</script>\n\n<!-- This will update -->\n<p>The count is {+++count()+++}</p>For more info, see Passing state into functions.store_rune_conflict\nIt looks like you're using the `$%name%` rune, but there is a local binding called `%name%`. Referencing a local variable with a `$` prefix will create a store subscription. Please rename `%name%` to avoid the ambiguitysvelte_component_deprecated\n`<svelte:component>` is deprecated in runes mode — components are dynamic by defaultIn previous versions of Svelte, the component constructor was fixed when the component was rendered. In other words, if you wanted <X> to re-render when X changed, you would either have to use <svelte:component this={X}> or put the component inside a {#key X}...{/key} block.In Svelte 5 this is no longer true — if X changes, <X> re-renders.In some cases <object.property> syntax can be used as a replacement; a lowercased variable with property access is recognized as a component in Svelte 5.For complex component resolution logic, an intermediary, capitalized variable may be necessary. E.g. in places where @const can be used:\n{#each items as item}\n\t---<svelte:component this={item.condition ? Y : Z} />---\n\t+++{@const Component = item.condition ? Y : Z}+++\n\t+++<Component />+++\n{/each}A derived value may be used in other contexts:\n<script>\n\t// ...\n\tlet condition = $state(false);\n\t+++const Component = $derived(condition ? Y : Z);+++\n</script>\n\n---<svelte:component this={condition ? Y : Z} />---\n+++<Component />+++svelte_element_invalid_this\n`this` should be an `{expression}`. Using a string attribute value will cause an error in future versions of Sveltesvelte_self_deprecated\n`<svelte:self>` is deprecated — use self-imports (e.g. `import %name% from './%basename%'`) insteadSee the note in the docs for more info.unknown_code\n`%code%` is not a recognised code`%code%` is not a recognised code (did you mean `%suggestion%`?)",
              "href": "/docs/svelte/compiler-warnings"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime errors",
                "Client errors",
                "effect_in_unowned_derived"
              ],
              "content": "Effect cannot be created inside a `$derived` value that was not itself created inside an effect",
              "href": "/docs/svelte/runtime-errors#Client-errors-effect_in_unowned_derived"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime errors",
                "Client errors",
                "state_descriptors_fixed"
              ],
              "content": "Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.",
              "href": "/docs/svelte/runtime-errors#Client-errors-state_descriptors_fixed"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime errors",
                "Client errors",
                "state_prototype_fixed"
              ],
              "content": "Cannot set prototype of `$state` object",
              "href": "/docs/svelte/runtime-errors#Client-errors-state_prototype_fixed"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime errors",
                "Client errors",
                "state_unsafe_mutation"
              ],
              "content": "Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`This error occurs when state is updated while evaluating a $derived. You might encounter it while trying to 'derive' two pieces of state in one go:<script>\n\tlet count = $state(0);\n\n\tlet even = $state(true);\n\n\tlet odd = $derived.by(() => {\n\t\teven = count % 2 === 0;\n\t\treturn !even;\n\t});\n</script>\n\n<button onclick={() => count++}>{count}</button>\n\n<p>{count} is even: {even}</p>\n<p>{count} is odd: {odd}</p>This is forbidden because it introduces instability: if <p>{count} is even: {even}</p> is updated before odd is recalculated, even will be stale. In most cases the solution is to make everything derived:let even = $derived(count % 2 === 0);\nlet odd = $derived(!even);If side-effects are unavoidable, use `$effect` instead.",
              "href": "/docs/svelte/runtime-errors#Client-errors-state_unsafe_mutation"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Client warnings",
                "assignment_value_stale"
              ],
              "content": "Assignment to `%property%` property (%location%) will evaluate to the right-hand side, not the value of `%property%` following the assignment. This may result in unexpected behaviour.Given a case like this...<script>\n\tlet object = $state({ array: null });\n\n\tfunction add() {\n\t\t(object.array ??= []).push(object.array.length);\n\t}\n</script>\n\n<button onclick={add}>add</button>\n<p>items: {JSON.stringify(object.items)}</p>...the array being pushed to when the button is first clicked is the [] on the right-hand side of the assignment, but the resulting value of object.array is an empty state proxy. As a result, the pushed value will be discarded.You can fix this by separating it into two statements:function add() {\n\tobject.array ??= [];\n\tobject.array.push(object.array.length);\n}",
              "href": "/docs/svelte/runtime-warnings#Client-warnings-assignment_value_stale"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Client warnings",
                "console_log_state"
              ],
              "content": "Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` insteadWhen logging a proxy, browser devtools will log the proxy itself rather than the value it represents. In the case of Svelte, the 'target' of a $state proxy might not resemble its current value, which can be confusing.The easiest way to log a value as it changes over time is to use the `$inspect` rune. Alternatively, to log things on a one-off basis (for example, inside an event handler) you can use `$state.snapshot` to take a snapshot of the current value.",
              "href": "/docs/svelte/runtime-warnings#Client-warnings-console_log_state"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Client warnings",
                "invalid_raw_snippet_render"
              ],
              "content": "The `render` function passed to `createRawSnippet` should return HTML for a single element",
              "href": "/docs/svelte/runtime-warnings#Client-warnings-invalid_raw_snippet_render"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Client warnings",
                "ownership_invalid_mutation"
              ],
              "content": "Mutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) insteadConsider the following code:<!--- file: App.svelte --->\n<script>\n\timport Child from './Child.svelte';\n\tlet person = $state({ name: 'Florida', surname: 'Man' });\n</script>\n\n<Child {person} /><!--- file: Child.svelte --->\n<script>\n\tlet { person } = $props();\n</script>\n\n<input bind:value={person.name}>\n<input bind:value={person.surname}>Child is mutating person which is owned by App without being explicitly &quot;allowed&quot; to do so. This is strongly discouraged since it can create code that is hard to reason about at scale (&quot;who mutated this value?&quot;), hence the warning.To fix it, either create callback props to communicate changes, or mark person as `$bindable`.",
              "href": "/docs/svelte/runtime-warnings#Client-warnings-ownership_invalid_mutation"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Client warnings",
                "state_proxy_equality_mismatch"
              ],
              "content": "Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results$state(...) creates a proxy of the value it is passed. The proxy and the value have different identities, meaning equality checks will always return false:<script>\n\tlet value = { foo: 'bar' };\n\tlet proxy = $state(value);\n\n\tvalue === proxy; // always false\n</script>To resolve this, ensure you're comparing values where both values were created with $state(...), or neither were. Note that $state.raw(...) will not create a state proxy.",
              "href": "/docs/svelte/runtime-warnings#Client-warnings-state_proxy_equality_mismatch"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Reference",
                "Runtime warnings",
                "Shared warnings",
                "state_snapshot_uncloneable"
              ],
              "content": "Value cannot be cloned with `$state.snapshot` — the original value was returnedThe following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:\n\n%properties%$state.snapshot tries to clone the given value in order to return a reference that no longer changes. Certain objects may not be cloneable, in which case the original value is returned. In the following example, property is cloned, but window is not, because DOM elements are uncloneable:const object = $state({ property: 'this is cloneable', window })\nconst snapshot = $state.snapshot(object);",
              "href": "/docs/svelte/runtime-warnings#Shared-warnings-state_snapshot_uncloneable"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Reactive let/var declarations"
              ],
              "content": "In runes mode, reactive state is explicitly declared with the `$state` rune.In legacy mode, variables declared at the top level of a component are automatically considered reactive. Reassigning or mutating these variables (count += 1 or object.x = y) will cause the UI to update.<script>\n\tlet count = 0;\n</script>\n\n<button on:click={() => count += 1}>\n\tclicks: {count}\n</button>Because Svelte's legacy mode reactivity is based on assignments, using array methods like .push() and .splice() won't automatically trigger updates. A subsequent assignment is required to 'tell' the compiler to update the UI:<script>\n\tlet numbers = [1, 2, 3, 4];\n\n\tfunction addNumber() {\n\t\t// this method call does not trigger an update\n\t\tnumbers.push(numbers.length + 1);\n\n\t\t// this assignment will update anything\n\t\t// that depends on `numbers`\n\t\tnumbers = numbers;\n\t}\n</script>",
              "href": "/docs/svelte/legacy-let"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Reactive $: statements"
              ],
              "content": "In runes mode, reactions to state updates are handled with the `$derived` and `$effect` runes.In legacy mode, any top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with a $: label. These statements run after other code in the <script> and before the component markup is rendered, then whenever the values that they depend on change.<script>\n\tlet a = 1;\n\tlet b = 2;\n\n\t// this is a 'reactive statement', and it will re-run\n\t// when `a`, `b` or `sum` change\n\t$: console.log(`${a} + ${b} = ${sum}`);\n\n\t// this is a 'reactive assignment' — `sum` will be\n\t// recalculated when `a` or `b` change. It is\n\t// not necessary to declare `sum` separately\n\t$: sum = a + b;\n</script>Statements are ordered topologically by their dependencies and their assignments: since the console.log statement depends on sum, sum is calculated first even though it appears later in the source.Multiple statements can be combined by putting them in a block: \n$: {\n\t// recalculate `total` when `items` changes\n\ttotal = 0;\n\n\tfor (const item of items) {\n\t\ttotal += item.value;\n\t}\n}The left-hand side of a reactive assignments can be an identifier, or it can be a destructuring assignment: \n$: ({ larry, moe, curly } = stooges);",
              "href": "/docs/svelte/legacy-reactive-assignments"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Reactive $: statements",
                "Understanding dependencies"
              ],
              "content": "The dependencies of a $: statement are determined at compile time — they are whichever variables are referenced (but not assigned to) inside the statement.In other words, a statement like this will not re-run when count changes, because the compiler cannot 'see' the dependency: \nlet count = 0;\nlet double = () => count * 2;\n\n$: doubled = double();Similarly, topological ordering will fail if dependencies are referenced indirectly: z will never update, because y is not considered 'dirty' when the update occurs. Moving $: z = y below $: setY(x) will fix it:<script>\n\tlet x = 0;\n\tlet y = 0;\n\n\t$: z = y;\n\t$: setY(x);\n\n\tfunction setY(value) {\n\t\ty = value;\n\t}\n</script>",
              "href": "/docs/svelte/legacy-reactive-assignments#Understanding-dependencies"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Reactive $: statements",
                "Browser-only code"
              ],
              "content": "Reactive statements run during server-side rendering as well as in the browser. This means that any code that should only run in the browser must be wrapped in an if block: \n$: if (browser) {\n\tdocument.title = title;\n}",
              "href": "/docs/svelte/legacy-reactive-assignments#Browser-only-code"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "export let"
              ],
              "content": "In runes mode, component props are declared with the `$props` rune, allowing parent components to pass in data.In legacy mode, props are marked with the export keyword, and can have a default value:<script>\n\texport let foo;\n\texport let bar = 'default value';\n\n\t// Values that are passed in as props\n\t// are immediately available\n\tconsole.log({ foo });\n</script>The default value is used if it would otherwise be undefined when the component is created.[!NOTE] Unlike in runes mode, if the parent component changes a prop from a defined value to `undefined`, it does not revert to the initial value.\nProps without default values are considered required, and Svelte will print a warning during development if no value is provided, which you can squelch by specifying undefined as the default value:export let foo +++= undefined;+++",
              "href": "/docs/svelte/legacy-export-let"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "export let",
                "Renaming props"
              ],
              "content": "The export keyword can appear separately from the declaration. This is useful for renaming props, for example in the case of a reserved word:<!--- file: App.svelte --->\n<script>\n\t/** @type {string} */\n\tlet className;\n\n\t// creates a `class` property, even\n\t// though it is a reserved word\n\texport { className as class };\n</script>",
              "href": "/docs/svelte/legacy-export-let#Renaming-props"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "$$props and $$restProps"
              ],
              "content": "In runes mode, getting an object containing all the props that were passed in is easy, using the `$props` rune.In legacy mode, we use $$props and $$restProps:undefined\nFor example, a <Button> component might need to pass along all its props to its own <button> element, except the variant prop:<script>\n\texport let variant;\n</script>\n\n<button {...$$restProps} class=\"variant-{variant} {$$props.class ?? ''}\">\n\tclick me\n</button>\n\n<style>\n\t.variant-danger {\n\t\tbackground: red;\n\t}\n</style>In Svelte 3/4 using $$props and $$restProps creates a modest performance penalty, so they should only be used when needed.",
              "href": "/docs/svelte/legacy-$$props-and-$$restProps"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "on:",
                "Component events"
              ],
              "content": "Components can dispatch events by creating a dispatcher when they are initialised:<!--- file: Stepper.svelte -->\n<script>\n\timport { createEventDispatcher } from 'svelte';\n\tconst dispatch = createEventDispatcher();\n</script>\n\n<button on:click={() => dispatch('decrement')}>decrement</button>\n<button on:click={() => dispatch('increment')}>increment</button>dispatch creates a `CustomEvent`. If a second argument is provided, it becomes the detail property of the event object.A consumer of this component can listen for the dispatched events:<script>\n\timport Stepper from './Stepper.svelte';\n\n\tlet n = 0;\n</script>\n\n<Stepper\n\ton:decrement={() => n -= 1}\n\ton:increment={() => n += 1}\n/>\n\n<p>n: {n}</p>Component events do not bubble — a parent component can only listen for events on its immediate children.Other than once, modifiers are not valid on component event handlers.[!NOTE]\nIf you're planning an eventual migration to Svelte 5, use callback props instead. This will make upgrading easier as `createEventDispatcher` is deprecated:\n\n```svelte\n<!--- file: Stepper.svelte --->\n<script>\n\texport let decrement;\n\texport let increment;\n</script>\n\n<button on:click={decrement}>decrement</button>\n<button on:click={increment}>increment</button>\n```",
              "href": "/docs/svelte/legacy-on#Component-events"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "<svelte:fragment>"
              ],
              "content": "The <svelte:fragment> element allows you to place content in a named slot without wrapping it in a container DOM element. This keeps the flow layout of your document intact.<!--- file: Widget.svelte --->\n<div>\n\t<slot name=\"header\">No header was provided</slot>\n\t<p>Some content between header and footer</p>\n\t<slot name=\"footer\" />\n</div><!--- file: App.svelte --->\n<script>\n\timport Widget from './Widget.svelte';\n</script>\n\n<Widget>\n\t<h1 slot=\"header\">Hello</h1>\n\t<svelte:fragment slot=\"footer\">\n\t\t<p>All rights reserved.</p>\n\t\t<p>Copyright (c) 2019 Svelte Industries</p>\n\t</svelte:fragment>\n</Widget>[!NOTE]\nIn Svelte 5+, this concept is obsolete, as snippets don't create a wrapping element",
              "href": "/docs/svelte/legacy-svelte-fragment"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "<svelte:component>"
              ],
              "content": "In runes mode, <MyComponent> will re-render if the value of MyComponent changes. See the Svelte 5 migration guide for an example.In legacy mode, it won't — we must use <svelte:component>, which destroys and recreates the component instance when the value of its this expression changes:<svelte:component this={MyComponent} />If this is falsy, no component is rendered.",
              "href": "/docs/svelte/legacy-svelte-component"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Imperative component API",
                "$set"
              ],
              "content": "component.$set(props);Programmatically sets props on an instance. component.$set({ x: 1 }) is equivalent to x = 1 inside the component's <script> block.Calling this method schedules an update for the next microtask — the DOM is not updated synchronously. \ncomponent.$set({ answer: 42 });[!NOTE]\nIn Svelte 5+, use `$state` instead to create a component props and update that\n\n```js\n// @noErrors\nlet props = $state({ answer: 42 });\nconst component = mount(Component, { props });\n// ...\nprops.answer = 24;\n```",
              "href": "/docs/svelte/legacy-component-api#$set"
            },
            {
              "breadcrumbs": [
                "Docs",
                "Svelte",
                "Legacy APIs",
                "Imperative component API",
                "Server-side component API"
              ],
              "content": "const result = Component.render(...)Unlike client-side components, server-side components don't have a lifespan after you render them — their whole job is to create some HTML and CSS. For that reason, the API is somewhat different.A server-side component exposes a render method that can be called with optional props. It returns an object with head, html, and css properties, where head contains the contents of any <svelte:head> elements encountered.You can import a Svelte component directly into Node using svelte/register. \nrequire('svelte/register');\n\nconst App = require('./App.svelte').default;\n\nconst { head, html, css } = App.render({\n\tanswer: 42\n});The .render() method accepts the following parameters:undefined\nThe options object takes in the following options:undefined\n \nconst { head, html, css } = App.render(\n\t// props\n\t{ answer: 42 },\n\t// options\n\t{\n\t\tcontext: new Map([['context-key', 'context-value']])\n\t}\n);[!NOTE]\nIn Svelte 5+, use [`render`](svelte-server#render) instead",
              "href": "/docs/svelte/legacy-component-api#Server-side-component-API"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Introduction",
                "Welcome to Svelte"
              ],
              "content": "Welcome to the Svelte tutorial! This will teach you everything you need to know to easily build web applications of all sizes, with high performance and a small footprint.You can also consult the API docs and visit the playground, or — if you're impatient to start hacking on your machine locally — create a project with npx sv create.",
              "href": "/tutorial/svelte/welcome-to-svelte"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "State"
              ],
              "content": "At the heart of Svelte is a powerful system of reactivity for keeping the DOM in sync with your application state — for example, in response to an event.Make the count declaration reactive by wrapping the value with $state(...): \nlet count = +++$state(0)+++;This is called a rune, and it's how you tell Svelte that count isn't an ordinary variable. Runes look like functions, but they're not — when you use Svelte, they're part of the language itself.All that's left is to implement increment: \nfunction increment() {\n\t+++count += 1;+++\n}",
              "href": "/tutorial/svelte/state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "Deep state"
              ],
              "content": "As we saw in the previous exercise, state reacts to reassignments. But it also reacts to mutations — we call this deep reactivity.Make numbers a reactive array: \nlet numbers = +++$state([1, 2, 3, 4])+++;Now, when we change the array... \nfunction addNumber() {\n\t+++numbers[numbers.length] = numbers.length + 1;+++\n}...the component updates. Or better still, we can push to the array instead: \nfunction addNumber() {\n\t+++numbers.push(numbers.length + 1);+++\n}[!NOTE] Deep reactivity is implemented using [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), and mutations to the proxy do not affect the original object.",
              "href": "/tutorial/svelte/deep-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "Derived state"
              ],
              "content": "Often, you will need to derive state from other state. For this, we have the $derived rune: \nlet numbers = $state([1, 2, 3, 4]);\n+++let total = $derived(numbers.reduce((t, n) => t + n, 0));+++We can now use this in our markup: \n<p>{numbers.join(' + ')} = +++{total}+++</p>The expression inside the $derived declaration will be re-evaluated whenever its dependencies (in this case, just numbers) are updated. Unlike normal state, derived state is read-only.",
              "href": "/tutorial/svelte/derived-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "Inspecting state"
              ],
              "content": "It's often useful to be able to track the value of a piece of state as it changes over time.Inside the addNumber function, we've added a console.log statement. But if you click the button and open the console drawer (using the button to the right of the URL bar), you'll see a warning, and a message saying the message could not be cloned.That's because numbers is a reactive proxy. There are a couple of things we can do. Firstly, we can create a non-reactive snapshot of the state with $state.snapshot(...): \nfunction addNumber() {\n\tnumbers.push(numbers.length + 1);\n\tconsole.log(+++$state.snapshot(numbers)+++);\n}Alternatively, we can use the $inspect rune to automatically log a snapshot of the state whenever it changes. This code will automatically be stripped out of your production build: \nfunction addNumber() {\n\tnumbers.push(numbers.length + 1);\n\t---console.log($state.snapshot(numbers));---\n}\n\n+++$inspect(numbers);+++You can customise how the information is displayed by using $inspect(...).with(fn) — for example, you can use console.trace to see where the state change originated from: \n$inspect(numbers)+++.with(console.trace)+++;",
              "href": "/tutorial/svelte/inspecting-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "Effects"
              ],
              "content": "So far we've talked about reactivity in terms of state. But that's only half of the equation — state is only reactive if something is reacting to it, otherwise it's just a sparkling variable.The thing that reacts is called an effect. You've already encountered effects — the ones that Svelte creates on your behalf to update the DOM in response to state changes — but you can also create your own with the $effect rune.[!NOTE] Most of the time, you shouldn't. `$effect` is best thought of as an escape hatch, rather than something to use frequently. If you can put your side effects in an [event handler](dom-events), for example, that's almost always preferable.\nLet's say we want to use setInterval to keep track of how long the component has been mounted. Create the effect: \n<script>\n\tlet elapsed = $state(0);\n\tlet interval = $state(1000);\n\n+++\t$effect(() => {\n\t\tsetInterval(() => {\n\t\t\telapsed += 1;\n\t\t}, interval);\n\t});+++\n</script>Click the 'speed up' button a few times and notice that elapsed ticks up faster, because we're calling setInterval each time interval gets smaller.If we then click the 'slow down' button... well, it doesn't work. That's because we're not clearing out the old intervals when the effect updates. We can fix that by returning a cleanup function: \n$effect(() => {\n\t+++const id =+++ setInterval(() => {\n\t\telapsed += 1;\n\t}, interval);\n\n+++\treturn () => {\n\t\tclearInterval(id);\n\t};+++\n});The cleanup function is called immediately before the effect function re-runs when interval changes, and also when the component is destroyed.If the effect function doesn't read any state when it runs, it will only run once, when the component mounts.[!NOTE] Effects do not run during server-side rendering.",
              "href": "/tutorial/svelte/effects"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Reactivity",
                "Universal reactivity"
              ],
              "content": "In the preceding exercises, we used runes to add reactivity inside components. But we can also use runes outside components, for example to share some global state.The <Counter> components in this exercise are all importing the counter object from shared.js. But it's a normal object, and as such nothing happens when you click the buttons. Wrap the object in $state(...): \nexport const counter = +++$state({+++\n\tcount: 0\n+++})+++;This causes an error, because you can't use runes in normal .js files, only .svelte.js files. Let's fix that — rename the file to shared.svelte.js.Then, update the import declaration in Counter.svelte: \n<script>\n\timport { counter } from './shared+++.svelte+++.js';\n</script>Now, when you click any button, all three update simultaneously.[!NOTE] You cannot export a `$state` declaration from a module if the declaration is reassigned (rather than just mutated), because the importers would have no way to know about it.",
              "href": "/tutorial/svelte/universal-reactivity"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Props",
                "Declaring props"
              ],
              "content": "So far, we've dealt exclusively with internal state — that is to say, the values are only accessible within a given component.In any real application, you'll need to pass data from one component down to its children. To do that, we need to declare properties, generally shortened to 'props'. In Svelte, we do that with the $props rune. Edit the Nested.svelte component: \n<script>\n\tlet { answer } = +++$props()+++;\n</script>",
              "href": "/tutorial/svelte/declaring-props"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Logic",
                "Keyed each blocks"
              ],
              "content": "By default, updating the value of an each block will add or remove DOM nodes at the end of the block if the size changes, and update the remaining DOM. That might not be what you want.It's easier to show why than to explain. Inside Thing.svelte, name is a dynamic prop but emoji is a constant.Click the 'Remove first thing' button a few times, and notice what happens:undefined\n[!NOTE] If you're coming from React, this might seem strange, because you're used to the entire component re-rendering when state changes. Svelte works differently: the component 'runs' once, and subsequent updates are 'fine-grained'. This makes things faster and gives you more control.\nOne way to fix it would be to make emoji a `$derived` value. But it makes more sense to remove the first <Thing> component altogether rather than remove the last one and update all the others.To do that, we specify a unique key for each iteration of the each block: \n{#each things as thing (+++thing.id+++)}\n\t<Thing name={thing.name}/>\n{/each}[!NOTE] You can use any object as the key, as Svelte uses a `Map` internally — in other words you could do `(thing)` instead of `(thing.id)`. Using a string or number is generally safer, however, since it means identity persists without referential equality, for example when updating with fresh data from an API server.",
              "href": "/tutorial/svelte/keyed-each-blocks"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Events",
                "Inline handlers"
              ],
              "content": "You can also declare event handlers inline: \n<script>\n\tlet m = $state({ x: 0, y: 0 });\n\n\t---function onpointermove(event) {\n\t\tm.x = event.clientX;\n\t\tm.y = event.clientY;\n\t}---\n</script>\n\n<div\n\tonpointermove={+++(event) => {\n\t\tm.x = event.clientX;\n\t\tm.y = event.clientY;\n\t}+++}\n>\n\tThe pointer is at {m.x} x {m.y}\n</div>",
              "href": "/tutorial/svelte/inline-handlers"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Bindings",
                "Checkbox inputs"
              ],
              "content": "Checkboxes are used for toggling between states. Instead of binding to input.value, we bind to input.checked: \n<input type=\"checkbox\" +++bind:+++checked={yes}>",
              "href": "/tutorial/svelte/checkbox-inputs"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Actions",
                "The use directive"
              ],
              "content": "Actions are essentially element-level lifecycle functions. They're useful for things like:undefined\nIn this app, you can scribble on the <canvas>, and change colours and brush size via the menu. But if you open the menu and cycle through the options with the Tab key, you'll soon find that the focus isn't trapped inside the modal.We can fix that with an action. Import trapFocus from actions.svelte.js... \n<script>\n\timport Canvas from './Canvas.svelte';\n\t+++import { trapFocus } from './actions.svelte.js';+++\n\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black'];\n\n\tlet selected = $state(colors[0]);\n\tlet size = $state(10);\n\tlet showMenu = $state(true);\n</script>...then add it to the menu with the use: directive: \n<div class=\"menu\" +++use:trapFocus+++>Let's take a look at the trapFocus function in actions.svelte.js. An action function is called with a node — the <div class=&quot;menu&quot;> in our case — when the node is mounted to the DOM. Inside the action, we have an effect.First, we need to add an event listener that intercepts Tab key presses: \n$effect(() => {\n\tfocusable()[0]?.focus();\n\t+++node.addEventListener('keydown', handleKeydown);+++\n});Second, we need to do some cleanup when the node is unmounted — removing the event listener, and restoring focus to where it was before the element mounted: \n$effect(() => {\n\tfocusable()[0]?.focus();\n\tnode.addEventListener('keydown', handleKeydown);\n\n+++\treturn () => {\n\t\tnode.removeEventListener('keydown', handleKeydown);\n\t\tprevious?.focus();\n\t};+++\n});Now, when you open the menu, you can cycle through the options with the Tab key.",
              "href": "/tutorial/svelte/actions"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Transitions",
                "The transition directive"
              ],
              "content": "We can make more appealing user interfaces by gracefully transitioning elements into and out of the DOM. Svelte makes this very easy with the transition directive.First, import the fade function from svelte/transition... \n<script>\n\t+++import { fade } from 'svelte/transition';+++\n\n\tlet visible = $state(true);\n</script>...then add it to the <p> element: \n<p +++transition:fade+++>\n\tFades in and out\n</p>",
              "href": "/tutorial/svelte/transition"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Transitions",
                "Adding parameters"
              ],
              "content": "Transition functions can accept parameters. Replace the fade transition with fly... \n<script>\n\timport { +++fly+++ } from 'svelte/transition';\n\n\tlet visible = $state(true);\n</script>...and apply it to the <p> along with some options: \n<p transition:+++fly={{ y: 200, duration: 2000 }}+++>\n\t+++Flies+++ in and out\n</p>Note that the transition is reversible — if you toggle the checkbox while the transition is ongoing, it transitions from the current point, rather than the beginning or the end.",
              "href": "/tutorial/svelte/adding-parameters-to-transitions"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Transitions",
                "Custom CSS transitions"
              ],
              "content": "The svelte/transition module has a handful of built-in transitions, but it's very easy to create your own. By way of example, this is the source of the fade transition:function fade(node, { delay = 0, duration = 400 }) {\n\tconst o = +getComputedStyle(node).opacity;\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\tcss: (t) => `opacity: ${t * o}`\n\t};\n}The function takes two arguments — the node to which the transition is applied, and any parameters that were passed in — and returns a transition object which can have the following properties:undefined\nThe t value is 0 at the beginning of an intro or the end of an outro, and 1 at the end of an intro or beginning of an outro.Most of the time you should return the css property and not the tick property, as CSS animations run off the main thread to prevent jank where possible. Svelte 'simulates' the transition and constructs a CSS animation, then lets it run.For example, the fade transition generates a CSS animation somewhat like this:\n0% { opacity: 0 }\n10% { opacity: 0.1 }\n20% { opacity: 0.2 }\n/* ... */\n100% { opacity: 1 }\nWe can get a lot more creative though. Let's make something truly gratuitous: \n<script>\n\timport { fade } from 'svelte/transition';\n\t+++import { elasticOut } from 'svelte/easing';+++\n\n\tlet visible = $state(true);\n\n\tfunction spin(node, { duration }) {\n\t\treturn {\n\t\t\tduration,\n\t\t\tcss: (t, u) => +++{\n\t\t\t\tconst eased = elasticOut(t);\n\n\t\t\t\treturn `\n\t\t\t\t\ttransform: scale(${eased}) rotate(${eased * 1080}deg);\n\t\t\t\t\tcolor: hsl(\n\t\t\t\t\t\t${Math.trunc(t * 360)},\n\t\t\t\t\t\t${Math.min(100, 1000 * u)}%,\n\t\t\t\t\t\t${Math.min(50, 500 * u)}%\n\t\t\t\t\t);`\n\t\t\t}+++\n\t\t};\n\t}\n</script>Remember: with great power comes great responsibility.",
              "href": "/tutorial/svelte/custom-css-transitions"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic Svelte",
                "Transitions",
                "Key blocks"
              ],
              "content": "Key blocks destroy and recreate their contents when the value of an expression changes. This is useful if you want an element to play its transition whenever a value changes instead of only when the element enters or leaves the DOM.Here, for example, we'd like to play the typewriter transition from transition.js whenever the loading message, i.e. i changes. Wrap the <p> element in a key block: \n+++{#key i}+++\n\t<p in:typewriter={{ speed: 10 }}>\n\t\t{messages[i] || ''}\n\t</p>\n+++{/key}+++",
              "href": "/tutorial/svelte/key-blocks"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced reactivity",
                "Raw state"
              ],
              "content": "In previous exercises, we learned that state is deeply reactive — if you (for example) change a property of an object, or push to an array, it will cause the UI to update. This works by creating a proxy that intercepts reads and writes.Occasionally, that's not what you want. If you're not changing individual properties, or if it's important to maintain referential equality, then you can use raw state instead.In this example, we have a chart of Svelte's steadily increasing stock price. We want the chart to update when new data comes in, which we could achieve by turning data into state... \nlet data = +++$state(poll())+++;...but there's no need to make it deeply reactive when it will be discarded a few milliseconds later. Instead, use $state.raw: \nlet data = +++$state.raw(poll())+++;[!NOTE] Mutating raw state will have no direct effect. In general, mutating non-reactive state is strongly discouraged.",
              "href": "/tutorial/svelte/raw-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced reactivity",
                "Reactive classes"
              ],
              "content": "It's not just variables that can be made reactive — in Svelte, we can also make properties of classes reactive.Let's make the width and height properties of our Box class reactive: \nclass Box {\n\twidth = +++$state(0);+++\n\theight = +++$state(0);+++\n\tarea = 0;\n\n\t// ...\n}Now, when we interact with the range inputs or click the 'embiggen' button, the box reacts.We can also use $derived, so that box.area updates reactively: \nclass Box {\n\twidth = $state(0);\n\theight = $state(0);\n\tarea = +++$derived(this.width * this.height);+++\n\n\t// ...\n}[!NOTE] In addition to `$state` and `$derived`, you can use `$state.raw` and `$derived.by` to define reactive fields.",
              "href": "/tutorial/svelte/reactive-classes"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced reactivity",
                "Getters and setters"
              ],
              "content": "Classes are particularly useful when you need to validate data. In the case of this Box class, it shouldn't be possible to keep embiggening past the maximum allowed by the sliders, but that's exactly what happens.We can fix that by replacing width and height with getters and setters, otherwise known as accessors. First, convert them to private properties: \nclass Box {\n\t+++#width+++ = $state(0);\n\t+++#height+++ = $state(0);\n\tarea = $derived(this.+++#width+++ * this.+++#height+++);\n\n\tconstructor(width, height) {\n\t\tthis.+++#width+++ = width;\n\t\tthis.+++#height+++ = height;\n\t}\n\n\t// ...\n}Then, create some getters and setters: \nclass Box {\n\t// ...\n\n+++\tget width() {\n\t\treturn this.#width;\n\t}\n\n\tget height() {\n\t\treturn this.#height;\n\t}\n\n\tset width(value) {\n\t\tthis.#width = value;\n\t}\n\n\tset height(value) {\n\t\tthis.#height = value;\n\t}+++\n\n\tembiggen(amount) {\n\t\tthis.width += amount;\n\t\tthis.height += amount;\n\t}\n}Finally, add the validation to the setters: \nset width(value) {\n\tthis.#width = +++Math.max(0, Math.min(MAX_SIZE, value));+++\n}\n\nset height(value) {\n\tthis.#height = +++Math.max(0, Math.min(MAX_SIZE, value));+++\n}It's now impossible to increase the box size past safe limits, whether through the bind:value on the range inputs, or the embiggen method, no matter how hard you press the button.",
              "href": "/tutorial/svelte/getters-and-setters"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced reactivity",
                "Reactive built-ins"
              ],
              "content": "Svelte ships with several reactive classes that you can use in place of JavaScript built-in objects — namely Map, Set, Date, URL and URLSearchParams.In this exercise, we could declare date using $state(new Date()) and reassign it inside the setInterval. But a nicer alternative is to use SvelteDate from `svelte/reactivity`: \n<script>\n\t+++import { SvelteDate } from 'svelte/reactivity';+++\n\n\tlet date = new +++SvelteDate();+++\n\n\t// ...\n</script>",
              "href": "/tutorial/svelte/reactive-builtins"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced reactivity",
                "Stores"
              ],
              "content": "Prior to the introduction of runes in Svelte 5, stores were the idiomatic way to handle reactive state outside components. That's no longer the case, but you'll still encounter stores when using Svelte (including in SvelteKit, for now), so it's worth knowing how to use them.[!NOTE] We won't cover how to create your own custom stores — for that, [consult the documentation](/docs/svelte/stores).\nLet's revisit the example from the universal reactivity exercise, but this time implement the shared state using a store.In shared.js we're currently exporting count, which is a number. Turn it into a writable store: \n+++import { writable } from 'svelte/store';+++\n\nexport const count = +++writable(0)+++;To reference the value of the store, we prefix it with a $ symbol. In Counter.svelte, update the text inside the <button> so that it no longer says [object Object]: \n<button onclick={() => {}}>\n\tclicks: {+++$count+++}\n</button>Finally, add the event handler. Because this is a writable store, we can update the value programmatically using its set or update method...count.update((n) => n + 1);...but since we're in a component we can continue using the $ prefix: \n<button onclick={() => +++$count += 1+++}>\n\tclicks: {$count}\n</button>",
              "href": "/tutorial/svelte/stores"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Reusing content",
                "Snippets and render tags"
              ],
              "content": "Snippets allow you to reuse content within a component, without extracting it out into a separate file.In this exercise, we're creating a table of the three wise monkeys, along with their unicode escape sequences and HTML entities. So far, we have but a single monkey.We could duplicate the markup, of course. Or we could create an array of { emoji, description } objects and pass it into an {#each ...} block. But a neater solution is to encapsulate the markup in a reusable block.Begin by declaring a snippet: \n+++{#snippet monkey()}+++\n\t<tr>\n\t\t<td>{emoji}</td>\n\t\t<td>{description}</td>\n\t\t<td>\\u{emoji.charCodeAt(0).toString(16)}\\u{emoji.charCodeAt(1).toString(16)}</td>\n\t\t<td>&amp#{emoji.codePointAt(0)}</td>\n\t</tr>\n+++{/snippet}+++The monkey is no longer visible until we render it. Let's do that: \n<tbody>\n\t{#snippet monkey()}...{/snippet}\n\n\t+++{@render monkey()}+++\n</tbody>Before we can use the snippet for the rest of our monkeys, we need to pass data into the snippet. Snippets can have zero or more parameters: \n<tbody>\n\t+++{#snippet monkey(emoji, description)}...{/snippet}+++\n\n\t+++{@render monkey('🙈', 'see no evil')}+++\n</tbody>[!NOTE] You can also use destructured parameters, if you like.\nAdd the rest of the monkeys:undefined\nFinally, delete the <script> block we no longer need it: \n---<script>\n\tlet emoji = '🙈';\n\tlet description = 'see no evil';\n</script>---[!NOTE] Snippets can be declared anywhere in your component, but, like functions, are only visible to render tags in the same 'scope' or a child scope.",
              "href": "/tutorial/svelte/snippets-and-render-tags"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Motion",
                "Tweened values"
              ],
              "content": "Often, a good way to communicate that a value is changing is to use motion. Svelte ships classes for adding motion to your user interfaces.Import the Tween class from svelte/motion: \n<script>\n\t+++import { Tween } from 'svelte/motion';+++\n\n\tlet progress = $state(0);\n</script>Turn progress into an instance of Tween: \n<script>\n\timport { Tween } from 'svelte/motion';\n\n\tlet progress = +++new Tween+++(0);\n</script>The Tween class has a writable target property and a readonly current property — update the <progress> element...<progress value={progress.+++current+++}></progress>...and each of the event handlers:<button onclick={() => (progress.+++target+++ = 0)}>\n\t0%\n</button>Clicking the buttons causes the progress bar to animate to its new value. It's a bit robotic and unsatisfying though. We need to add an easing function: \n<script>\n\timport { Tween } from 'svelte/motion';\n\t+++import { cubicOut } from 'svelte/easing';+++\n\n\tlet progress = new Tween(0, +++{\n\t\tduration: 400,\n\t\teasing: cubicOut\n\t}+++);\n</script>[!NOTE] The `svelte/easing` module contains the [Penner easing equations](https://web.archive.org/web/20190805215728/http://robertpenner.com/easing/), or you can supply your own `p => t` function where `p` and `t` are both values between 0 and 1.\nThe full set of options available to Tween:undefined\nYou can also call progress.set(value, options) instead of assigning directly to progress.target, in which case options will override the defaults. The set method returns a promise that resolves when the tween completes.",
              "href": "/tutorial/svelte/tweens"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced bindings",
                "This"
              ],
              "content": "You can use the special bind:this directive to get a readonly binding to an element in your component.The $effect in this exercise attempts to create a canvas context, but canvas is undefined. Begin by declaring it at the top level of the component... \n<script>\n\timport { paint } from './gradient.js';\n\n\t+++let canvas;+++\n\n\t$effect(() => {\n\t\t// ...\n\t});\n</script>...then add the directive to the <canvas> element: \n<canvas +++bind:this={canvas}+++ width={32} height={32}></canvas>Note that the value of canvas will remain undefined until the component has mounted — in other words you can't access it until the $effect runs.",
              "href": "/tutorial/svelte/bind-this"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced bindings",
                "Binding to component instances"
              ],
              "content": "Just as you can bind to DOM elements, you can bind to component instances themselves with bind:this.This is useful in the rare cases that you need to interact with a component programmatically (rather than by providing it with updated props). Revisiting our canvas app from a few exercises ago, it would be nice to add a button to clear the screen.First, let's export a function from Canvas.svelte: \nlet canvas = $state();\nlet context = $state();\nlet coords = $state();\n\n+++export function clear() {\n\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n}+++Then, create a reference to the component instance: \nlet selected = $state(colors[0]);\nlet size = $state(10);\nlet showMenu = $state(true);\n\n+++let canvas;+++ \n<Canvas +++bind:this={canvas}+++ color={selected} size={size} />Finally, add a button that calls the clear function: \n<div class=\"controls\">\n\t<button class=\"show-menu\" onclick={() => showMenu = !showMenu}>\n\t\t{showMenu ? 'close' : 'menu'}\n\t</button>\n\n+++\t<button onclick={() => canvas.clear()}>\n\t\tclear\n\t</button>+++\n</div>",
              "href": "/tutorial/svelte/component-this"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced transitions",
                "Deferred transitions"
              ],
              "content": "A particularly powerful feature of Svelte's transition engine is the ability to defer transitions, so that they can be coordinated between multiple elements.Take this pair of todo lists, in which toggling a todo sends it to the opposite list. In the real world, objects don't behave like that — instead of disappearing and reappearing in another place, they move through a series of intermediate positions. Using motion can go a long way towards helping users understand what's happening in your app.We can achieve this effect using the crossfade function, as seen in transition.js, which creates a pair of transitions called send and receive. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the fallback transition is used.Open TodoList.svelte. First, import the send and receive transitions from transition.js: \n<script>\n\t+++import { send, receive } from './transition.js';+++\n\n\tlet { todos, remove } = $props();\n</script>Then, add them to the <li> element, using the todo.id property as a key to match the elements: \n<li\n\tclass={{ done: todo.done }}\n\t+++in:receive={{ key: todo.id }}+++\n\t+++out:send={{ key: todo.id }}+++\n>Now, when you toggle items, they move smoothly to their new location. The non-transitioning items still jump around awkwardly — we can fix that in the next exercise.",
              "href": "/tutorial/svelte/deferred-transitions"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Advanced transitions",
                "Animations"
              ],
              "content": "In the previous chapter, we used deferred transitions to create the illusion of motion as elements move from one todo list to the other.To complete the illusion, we also need to apply motion to the elements that aren't transitioning. For this, we use the animate directive.First, import the flip function — flip stands for 'First, Last, Invert, Play' — from svelte/animate into TodoList.svelte: \n<script>\n\t+++import { flip } from 'svelte/animate';+++\n\timport { send, receive } from './transition.js';\n\n\tlet { todos, remove } = $props();\n</script>Then add it to the <li> elements: \n<li\n\tclass={{ done: todo.done }}\n\tin:receive={{ key: todo.id }}\n\tout:send={{ key: todo.id }}\n\t+++animate:flip+++\n>The movement is a little slow in this case, so we can add a duration parameter: \n<li\n\tclass={{ done: todo.done }}\n\tin:receive={{ key: todo.id }}\n\tout:send={{ key: todo.id }}\n\tanimate:flip+++={{ duration: 200 }}+++\n>[!NOTE] `duration` can also be a `d => milliseconds` function, where `d` is the number of pixels the element has to travel\nNote that all the transitions and animations are being applied with CSS, rather than JavaScript, meaning they won't block (or be blocked by) the main thread.",
              "href": "/tutorial/svelte/animations"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Context API",
                "setContext and getContext"
              ],
              "content": "The context API provides a mechanism for components to 'talk' to each other without passing around data and functions as props, or dispatching lots of events. It's an advanced feature, but a useful one. In this exercise, we're going to recreate Schotter by George Nees — one of the pioneers of generative art — using the context API.Inside Canvas.svelte, there's an addItem function that adds an item to the canvas. We can make it available to components inside <Canvas>, like <Square>, with setContext: \n+++import { setContext } from 'svelte';+++\nimport { SvelteSet } from 'svelte/reactivity';\n\nlet { width = 100, height = 100, children } = $props();\n\nlet canvas;\nlet items = new SvelteSet();\n\n+++setContext('canvas', { addItem });+++\n\nfunction addItem(fn) {\n\t$effect(() => {\n\t\titems.add(fn);\n\t\treturn () => items.delete(fn);\n\t});\n}Inside child components, we can now get the context with, well, getContext: \n+++import { getContext } from 'svelte';+++\n\nlet { x, y, size, rotate } = $props();\n\n+++getContext('canvas').addItem(draw);+++So far, so... boring. Let's add some randomness to the grid: \n<div class=\"container\">\n\t<Canvas width={800} height={1200}>\n\t\t{#each Array(12) as _, c}\n\t\t\t{#each Array(22) as _, r}\n\t\t\t\t<Square\n\t\t\t\t\tx={180 + c * 40+++ + jitter(r * 2)+++}\n\t\t\t\t\ty={180 + r * 40+++ + jitter(r * 2)+++}\n\t\t\t\t\tsize={40}\n\t\t\t\t\t+++rotate={jitter(r * 0.05)}+++\n\t\t\t\t/>\n\t\t\t{/each}\n\t\t{/each}\n\t</Canvas>\n</div>setContext and getContext must be called during component initialisation, so that the context can be correctly bound. The key — 'canvas' in this case — can be anything you like, including non-strings, which is useful for controlling who can access the context.[!NOTE] Your context object can include anything, including reactive state. This allows you to pass values that change over time to child components:\n\n```js\n// in a parent component\nimport { setContext } from 'svelte';\n\nlet context = $state({...});\nsetContext('my-context', context);\n```\n\n```js\n// in a child component\nimport { getContext } from 'svelte';\n\nconst context = getContext('my-context');\n```",
              "href": "/tutorial/svelte/context-api"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Special elements",
                "<svelte:head>"
              ],
              "content": "The <svelte:head> element allows you to insert elements inside the <head> of your document. This is useful for things like <title> and <meta> tags, which are critical for good SEO.Since those are quite hard to show in the context of this tutorial, we'll use it for a different purpose — loading stylesheets. \n<script>\n\tconst themes = ['margaritaville', 'retrowave', 'spaaaaace', 'halloween'];\n\tlet selected = $state(themes[0]);\n</script>\n\n+++<svelte:head>\n\t<link rel=\"stylesheet\" href=\"/tutorial/stylesheets/{selected}.css\" />\n</svelte:head>+++\n\n<h1>Welcome to my site!</h1>[!NOTE] In server-side rendering (SSR) mode, contents of `<svelte:head>` are returned separately from the rest of your HTML.",
              "href": "/tutorial/svelte/svelte-head"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Special elements",
                "<svelte:boundary>"
              ],
              "content": "To prevent errors from leaving your app in a broken state, you can contain them inside an error boundary using the <svelte:boundary> element.In this example, <FlakyComponent> contains a bug — clicking the button will set mouse to null, meaning that the {mouse.x} and {mouse.y} expressions in the template will fail to render.In an ideal world we'd simply fix the bug. But that's not always an option — sometimes the component belongs to someone else, and sometimes you just need to guard against the unexpected. Begin by wrapping <FlakyComponent /> with <svelte:boundary>:<!--- file: App.svelte --->\n+++<svelte:boundary>+++\n\t<FlakyComponent />\n+++</svelte:boundary>+++So far, nothing has changed, because the boundary doesn't specify a handler. Add a failed snippet to provide some UI to show when an error occurs:<!--- file: App.svelte --->\n<svelte:boundary>\n\t<FlakyComponent />\n\n+++\t{#snippet failed(error)}\n\t\t<p>Oops! {error.message}</p>\n\t{/snippet}+++\n</svelte:boundary>Now, when we click the button, the contents of the boundary are replaced with the snippet. We can attempt to reset things by making use of the second argument passed to failed:<!--- file: App.svelte --->\n<svelte:boundary>\n\t<FlakyComponent />\n\n\t{#snippet failed(error+++, reset+++)}\n\t\t<p>Oops! {error.message}</p>\n\t\t+++<button onclick={reset}>Reset</button>+++\n\t{/snippet}\n</svelte:boundary>We can also specify an onerror handler, which is called with the same arguments passed to the failed snippet:<!--- file: App.svelte --->\n<svelte:boundary +++onerror={(e) => console.error(e)}+++>\n\t<FlakyComponent />\n\n\t{#snippet failed(error, reset)}\n\t\t<p>Oops! {error.message}</p>\n\t\t<button onclick={reset}>Reset</button>\n\t{/snippet}\n</svelte:boundary>This is useful for sending information about the error to a reporting service, or adding UI outside the error boundary itself.",
              "href": "/tutorial/svelte/svelte-boundary"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "<script module>",
                "Sharing code"
              ],
              "content": "In all the examples we've seen so far, the <script> block contains code that runs when each component instance is initialised. For the vast majority of components, that's all you'll ever need.Very occasionally, you'll need to run some code outside of an individual component instance. For example: returning to our custom audio player from a previous exercise, you can play all four tracks simultaneously. It would be better if playing one stopped all the others.We can do that by declaring a <script module> block. Code contained inside it will run once, when the module first evaluates, rather than when a component is instantiated. Place this at the top of AudioPlayer.svelte (note that this is a separate script tag): \n+++<script module>\n\tlet current;\n</script>+++It's now possible for the components to 'talk' to each other without any state management: \n<audio\n\tsrc={src}\n\tbind:currentTime={time}\n\tbind:duration\n\tbind:paused\n+++\tonplay={(e) => {\n\t\tconst audio = e.currentTarget;\n\n\t\tif (audio !== current) {\n\t\t\tcurrent?.pause();\n\t\t\tcurrent = audio;\n\t\t}\n\t}}+++\n\tonended={() => {\n\t\ttime = 0;\n\t}}\n/>",
              "href": "/tutorial/svelte/sharing-code"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced Svelte",
                "Next steps",
                "Congratulations!"
              ],
              "content": "You've now finished the Svelte tutorial and are ready to start building.The next two parts of the tutorial will focus on SvelteKit, a full-fledged framework for creating apps of all shapes and sizes.If you're suffering from information overload and aren't ready to go through the SvelteKit tutorial yet, don't worry! You can use your existing Svelte knowledge without learning all of SvelteKit. Just run this in your terminal and follow the prompts...npx sv create...and start editing src/routes/+page.svelte. When you're ready, click the link below to continue your journey.",
              "href": "/tutorial/svelte/congratulations"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Routing",
                "Pages"
              ],
              "content": "SvelteKit uses filesystem-based routing, which means that the routes of your app — in other words, what the app should do when a user navigates to a particular URL — are defined by the directories in your codebase.Every +page.svelte file inside src/routes creates a page in your app. In this app we currently have one page — src/routes/+page.svelte, which maps to /. If we navigate to /about, we'll see a 404 Not Found error.Let's fix that. Add a second page, src/routes/about/+page.svelte, copy the contents of src/routes/+page.svelte, and update it: \n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\n<h1>+++about+++</h1>\n<p>this is the +++about+++ page.</p>We can now navigate between / and /about.[!NOTE] Unlike traditional multi-page apps, navigating to `/about` and back updates the contents of the current page, like a single-page app. This gives us the best of both worlds — fast server-rendered startup, then instant navigation. (This behaviour can be [configured](/docs/kit/page-options).)",
              "href": "/tutorial/kit/pages"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Routing",
                "Layouts"
              ],
              "content": "Different routes of your app will often share common UI. Instead of repeating it in each +page.svelte component, we can use a +layout.svelte component that applies to all routes in the same directory.In this app we have two routes, src/routes/+page.svelte and src/routes/about/+page.svelte, that contain the same navigation UI. Let's create a new file, src/routes/+layout.svelte...src/routes/\n├ about/\n│ └ +page.svelte\n+++├ +layout.svelte+++\n└ +page.svelte...and move the duplicated content from the +page.svelte files into the new +layout.svelte file. The {@render children()} tag is where the page content will be rendered: \n<script>\n\tlet { children } = $props();\n</script>\n\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\n{@render children()}A +layout.svelte file applies to every child route, including the sibling +page.svelte (if it exists). You can nest layouts to arbitrary depth.",
              "href": "/tutorial/kit/layouts"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Routing",
                "Route parameters"
              ],
              "content": "To create routes with dynamic parameters, use square brackets around a valid variable name. For example, a file like src/routes/blog/[slug]/+page.svelte will create a route that matches /blog/one, /blog/two, /blog/three and so on.Let's create that file: \n<h1>blog post</h1>We can now navigate from the /blog page to individual blog posts. In the next chapter, we'll see how to load their content.[!NOTE] Multiple route parameters can appear _within_ one URL segment, as long as they are separated by at least one static character: `foo/[bar]x[baz]` is a valid route where `[bar]` and `[baz]` are dynamic parameters.",
              "href": "/tutorial/kit/params"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Loading data",
                "Layout data"
              ],
              "content": "Just as +layout.svelte files create UI for every child route, +layout.server.js files load data for every child route.Suppose we'd like to add a 'more posts' sidebar to our blog post page. We could return summaries from the load function in src/routes/blog/[slug]/+page.server.js, like we do in src/routes/blog/+page.server.js, but that would be repetitive.Instead, let's rename src/routes/blog/+page.server.js to src/routes/blog/+layout.server.js. Notice that the /blog route continues to work — data.summaries is still available to the page.Now, add a sidebar in the layout for the post page: \n<script>\n\tlet { data, children } = $props();\n</script>\n\n<div class=\"layout\">\n\t<main>\n\t\t{@render children()}\n\t</main>\n\n+++\t<aside>\n\t\t<h2>More posts</h2>\n\t\t<ul>\n\t\t\t{#each data.summaries as { slug, title }}\n\t\t\t\t<li>\n\t\t\t\t\t<a href=\"/blog/{slug}\">{title}</a>\n\t\t\t\t</li>\n\t\t\t{/each}\n\t\t</ul>\n\t</aside>+++\n</div>\n\n<style>\n\t@media (min-width: 640px) {\n\t\t.layout {\n\t\t\tdisplay: grid;\n\t\t\tgap: 2em;\n\t\t\tgrid-template-columns: 1fr 16em;\n\t\t}\n\t}\n</style>The layout (and any page below it) inherits data.summaries from the parent +layout.server.js.When we navigate from one post to another, we only need to load the data for the post itself — the layout data is still valid. See the documentation on invalidation to learn more.",
              "href": "/tutorial/kit/layout-data"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Forms",
                "The <form> element"
              ],
              "content": "In the chapter on loading data, we saw how to get data from the server to the browser. Sometimes you need to send data in the opposite direction, and that's where <form> — the web platform's way of submitting data — comes in.Let's build a todo app. We've already got an in-memory database set up in src/lib/server/database.js, and our load function in src/routes/+page.server.js uses the `cookies` API so that we can have a per-user todo list, but we need to add a <form> to create new todos: \n<h1>todos</h1>\n\n+++<form method=\"POST\">\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t/>\n\t</label>\n</form>+++\n\n<ul class=\"todos\">If we type something into the <input> and hit Enter, the browser makes a POST request (because of the method=&quot;POST&quot; attribute) to the current page. But that results in an error, because we haven't created a server-side action to handle the POST request. Let's do that now: \nimport * as db from '$lib/server/database.js';\n\nexport function load({ cookies }) {\n\t// ...\n}\n\n+++export const actions = {\n\tdefault: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n\t}\n};+++The request is a standard Request object; await request.formData() returns a `FormData` instance.When we hit Enter, the database is updated and the page reloads with the new data.Notice that we haven't had to write any fetch code or anything like that — data updates automatically. And because we're using a <form> element, this app would work even if JavaScript was disabled or unavailable.",
              "href": "/tutorial/kit/the-form-element"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Forms",
                "Named form actions"
              ],
              "content": "A page that only has a single action is, in practice, quite rare. Most of the time you'll need to have multiple actions on a page. In this app, creating a todo isn't enough — we'd like to delete them once they're complete.Begin by replacing our default action with named create and delete actions: \nexport const actions = {\n\t+++create+++: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n\t}+++,+++\n\n+++\tdelete: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.deleteTodo(cookies.get('userid'), data.get('id'));\n\t}+++\n};[!NOTE] Default actions cannot coexist with named actions.\nThe <form> element has an optional action attribute, which is similar to an <a> element's href attribute. Update the existing form so that it points to the new create action: \n<form method=\"POST\" +++action=\"?/create\"+++>\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t/>\n\t</label>\n</form>[!NOTE] The `action` attribute can be any URL — if the action was defined on another page, you might have something like `/todos?/create`. Since the action is on _this_ page, we can omit the pathname altogether, hence the leading `?` character.\nNext, we want to create a form for each todo, complete with a hidden <input> that uniquely identifies it: \n<ul class=\"todos\">\n\t{#each data.todos as todo (todo.id)}\n\t\t<li>\n+++\t\t\t<form method=\"POST\" action=\"?/delete\">\n\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t<span>{todo.description}</span>\n\t\t\t\t<button aria-label=\"Mark as complete\"></button>\n\t\t\t</form>+++\n\t\t</li>\n\t{/each}\n</ul>",
              "href": "/tutorial/kit/named-form-actions"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Forms",
                "Validation"
              ],
              "content": "Users are a mischievous bunch, who will submit all kinds of nonsensical data if given the chance. To prevent them from causing chaos, it's important to validate form data.The first line of defense is the browser's built-in form validation, which makes it easy to, for example, mark an <input> as required: \n<form method=\"POST\" action=\"?/create\">\n\t<label>\n\t\tadd a todo\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t\t+++required+++\n\t\t/>\n\t</label>\n</form>Try hitting Enter while the <input> is empty.This kind of validation is helpful, but insufficient. Some validation rules (e.g. uniqueness) can't be expressed using <input> attributes, and in any case, if the user is an elite hacker they might simply delete the attributes using the browser's devtools. To guard against these sorts of shenanigans, you should always use server-side validation.In src/lib/server/database.js, validate that the description exists and is unique: \nexport function createTodo(userid, description) {\n+++\tif (description === '') {\n\t\tthrow new Error('todo must have a description');\n\t}+++\n\n\tconst todos = db.get(userid);\n\n+++\tif (todos.find((todo) => todo.description === description)) {\n\t\tthrow new Error('todos must be unique');\n\t}+++\n\n\ttodos.push({\n\t\tid: crypto.randomUUID(),\n\t\tdescription,\n\t\tdone: false\n\t});\n}Try submitting a duplicate todo. Yikes! SvelteKit takes us to an unfriendly-looking error page. On the server, we see a 'todos must be unique' error, but SvelteKit hides unexpected error messages from users because they often contain sensitive data.It would be much better to stay on the same page and provide an indication of what went wrong so that the user can fix it. To do this, we can use the fail function to return data from the action along with an appropriate HTTP status code: \n+++import { fail } from '@sveltejs/kit';+++\nimport * as db from '$lib/server/database.js';\n\nexport function load({ cookies }) {...}\n\nexport const actions = {\n\tcreate: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\n+++\t\ttry {+++\n\t\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n+++\t\t} catch (error) {\n\t\t\treturn fail(422, {\n\t\t\t\tdescription: data.get('description'),\n\t\t\t\terror: error.message\n\t\t\t});\n\t\t}+++\n\t}In src/routes/+page.svelte, we can access the returned value via the form prop, which is only ever populated after a form submission: \n<script>\n\tlet { data, +++form+++ } = $props();\n</script>\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\t+++{#if form?.error}\n\t\t<p class=\"error\">{form.error}</p>\n\t{/if}+++\n\n\t<form method=\"POST\" action=\"?/create\">\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\t+++value={form?.description ?? ''}+++\n\t\t\t\tautocomplete=\"off\"\n\t\t\t\trequired\n\t\t\t/>\n\t\t</label>\n\t</form>[!NOTE] You can also return data from an action _without_ wrapping it in `fail` — for example to show a 'success!' message when data was saved — and it will be available via the `form` prop.",
              "href": "/tutorial/kit/form-validation"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Forms",
                "Progressive enhancement"
              ],
              "content": "Because we're using <form>, our app works even if the user doesn't have JavaScript (which happens more often than you probably think). That's great, because it means our app is resilient.Most of the time, users do have JavaScript. In those cases, we can progressively enhance the experience, the same way SvelteKit progressively enhances <a> elements by using client-side routing.Import the enhance function from $app/forms... \n<script>\n\t+++import { enhance } from '$app/forms';+++\n\n\tlet { data, form } = $props();\n</script>...and add the use:enhance directive to the <form> elements: \n<form method=\"POST\" action=\"?/create\" +++use:enhance+++> \n<form method=\"POST\" action=\"?/delete\" +++use:enhance+++>And that's all it takes! Now, when JavaScript is enabled, use:enhance will emulate the browser-native behaviour except for the full-page reloads. It will:undefined\nNow that we're updating the page rather than reloading it, we can get fancy with things like transitions: \n<script>\n\t+++import { fly, slide } from 'svelte/transition';+++\n\timport { enhance } from '$app/forms';\n\n\tlet { data, form } = $props();\n</script> \n<li +++in:fly={{ y: 20 }} out:slide+++>...</li>",
              "href": "/tutorial/kit/progressive-enhancement"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Forms",
                "Customizing use:enhance"
              ],
              "content": "With use:enhance, we can go further than just emulating the browser's native behaviour. By providing a callback, we can add things like pending states and optimistic UI. Let's simulate a slow network by adding an artificial delay to our two actions: \nexport const actions = {\n\tcreate: async ({ cookies, request }) => {\n\t\t+++await new Promise((fulfil) => setTimeout(fulfil, 1000));+++\n\t\t...\n\t},\n\n\tdelete: async ({ cookies, request }) => {\n\t\t+++await new Promise((fulfil) => setTimeout(fulfil, 1000));+++\n\t\t...\n\t}\n};When we create or delete items, it now takes a full second before the UI updates, leaving the user wondering if they messed up somehow. To solve that, add some local state... \n<script>\n\timport { fly, slide } from 'svelte/transition';\n\timport { enhance } from '$app/forms';\n\n\tlet { data, form } = $props();\n\n+++\tlet creating = $state(false);\n\tlet deleting = $state([]);+++\n</script>...and toggle creating inside the first use:enhance: \n<form\n\tmethod=\"POST\"\n\taction=\"?/create\"\n+++\tuse:enhance={() => {\n\t\tcreating = true;\n\n\t\treturn async ({ update }) => {\n\t\t\tawait update();\n\t\t\tcreating = false;\n\t\t};\n\t}}+++\n>\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\t+++disabled={creating}+++\n\t\t\tname=\"description\"\n\t\t\tvalue={form?.description ?? ''}\n\t\t\tautocomplete=\"off\"\n\t\t\trequired\n\t\t/>\n\t</label>\n</form>We can then show a message while we're saving data: \n<ul class=\"todos\">\n\t<!-- ... -->\n</ul>\n\n+++{#if creating}\n\t<span class=\"saving\">saving...</span>\n{/if}+++In the case of deletions, we don't really need to wait for the server to validate anything — we can just update the UI immediately: \n<ul class=\"todos\">\n\t{#each +++data.todos.filter((todo) => !deleting.includes(todo.id))+++ as todo (todo.id)}\n\t\t<li in:fly={{ y: 20 }} out:slide>\n\t\t\t<form\n\t\t\t\tmethod=\"POST\"\n\t\t\t\taction=\"?/delete\"\n\t\t\t\t+++use:enhance={() => {\n\t\t\t\t\tdeleting = [...deleting, todo.id];\n\t\t\t\t\treturn async ({ update }) => {\n\t\t\t\t\t\tawait update();\n\t\t\t\t\t\tdeleting = deleting.filter((id) => id !== todo.id);\n\t\t\t\t\t};\n\t\t\t\t}}+++\n\t\t\t>\n\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t<button aria-label=\"Mark as complete\">✔</button>\n\n\t\t\t\t{todo.description}\n\t\t\t</form>\n\t\t</li>\n\t{/each}\n</ul>[!NOTE] `use:enhance` is very customizable — you can `cancel()` submissions, handle redirects, control whether the form is reset, and so on. [See the docs](/docs/kit/$app-forms#enhance) for full details.",
              "href": "/tutorial/kit/customizing-use-enhance"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "API routes",
                "GET handlers"
              ],
              "content": "SvelteKit allows you to create more than just pages. We can also create API routes by adding a +server.js file that exports functions corresponding to HTTP methods: GET, PUT, POST, PATCH and DELETE.This app fetches data from a /roll API route when you click the button. Create that route by adding a src/routes/roll/+server.js file: \nexport function GET() {\n\tconst number = Math.floor(Math.random() * 6) + 1;\n\n\treturn new Response(number, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t});\n}Clicking the button now works.Request handlers must return a Response object. Since it's common to return JSON from an API route, SvelteKit provides a convenience function for generating these responses: \n+++import { json } from '@sveltejs/kit';+++\n\nexport function GET() {\n\tconst number = Math.floor(Math.random() * 6) + 1;\n\n---\treturn new Response(number, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t});---\n+++\treturn json(number);+++\n}",
              "href": "/tutorial/kit/get-handlers"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "API routes",
                "POST handlers"
              ],
              "content": "You can also add handlers that mutate data, such as POST. In most cases, you should use form actions instead — you'll end up writing less code, and it'll work without JavaScript, making it more resilient.Inside the keydown event handler of the 'add a todo' <input>, let's post some data to the server: \n<input\n\ttype=\"text\"\n\tautocomplete=\"off\"\n\tonkeydown={async (e) => {\n\t\tif (e.key !== 'Enter') return;\n\n\t\tconst input = e.currentTarget;\n\t\tconst description = input.value;\n\n+++\t\tconst response = await fetch('/todo', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ description }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t});+++\n\n\t\tinput.value = '';\n\t}}\n/>Here, we're posting some JSON to the /todo API route — using a userid from the user's cookies — and receiving the id of the newly created todo in response.Create the /todo route by adding a src/routes/todo/+server.js file with a POST handler that calls createTodo in src/lib/server/database.js: \nimport { json } from '@sveltejs/kit';\nimport * as database from '$lib/server/database.js';\n\nexport async function POST({ request, cookies }) {\n\tconst { description } = await request.json();\n\n\tconst userid = cookies.get('userid');\n\tconst { id } = await database.createTodo({ userid, description });\n\n\treturn json({ id }, { status: 201 });\n}As with load functions and form actions, the request is a standard Request object; await request.json() returns the data that we posted from the event handler.We're returning a response with a 201 Created status and the id of the newly generated todo in our database. Back in the event handler, we can use this to update the page: \n<input\n\ttype=\"text\"\n\tautocomplete=\"off\"\n\tonkeydown={async (e) => {\n\t\tif (e.key !== 'Enter') return;\n\n\t\tconst input = e.currentTarget;\n\t\tconst description = input.value;\n\n\t\tconst response = await fetch('/todo', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ description }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t});\n\n+++\t\tconst { id } = await response.json();\n\n\t\tconst todos = [...data.todos, {\n\t\t\tid,\n\t\t\tdescription\n\t\t}];\n\n\t\tdata = { ...data, todos };+++\n\n\t\tinput.value = '';\n\t}}\n/>[!NOTE] You should only update `data` in such a way that you'd get the same result by reloading the page. The `data` prop is not _deeply_ reactive, so you need to replace it — mutations like `data.todos = todos` will not cause a re-render.",
              "href": "/tutorial/kit/post-handlers"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "$app/state",
                "page"
              ],
              "content": "SvelteKit makes three readonly state objects available via the $app/state module — page, navigating and updated. The one you'll use most often is `page`, which provides information about the current page:undefined\nEach of these properties is reactive, using $state.raw under the hood. Here's an example using page.url.pathname: \n<script>\n\t+++import { page } from '$app/state';+++\n\n\tlet { children } = $props();\n</script>\n\n<nav>\n\t<a href=\"/\" +++aria-current={page.url.pathname === '/'}+++>\n\t\thome\n\t</a>\n\n\t<a href=\"/about\" +++aria-current={page.url.pathname === '/about'}+++>\n\t\tabout\n\t</a>\n</nav>\n\n{@render children()}[!NOTE] Prior to SvelteKit 2.12, you had to use `$app/stores` for this, which provides a `$page` store with the same information. If you're currently using `$app/stores`, we advise you to migrate towards `$app/state` (requires Svelte 5).",
              "href": "/tutorial/kit/page-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "$app/state",
                "navigating"
              ],
              "content": "The navigating object represents the current navigation. When a navigation starts — because of a link click, or a back/forward navigation, or a programmatic goto — the value of navigating will become an object with the following properties:undefined\n[!NOTE] For complete type information visit the [`Navigation`](/docs/kit/@sveltejs-kit#Navigation) documentation.\nIt can be used to show a loading indicator for long-running navigations. In this exercise, src/routes/+page.server.js and src/routes/about/+page.server.js both have an artificial delay. Inside src/routes/+layout.svelte, import the navigating object and add a message to the nav bar: \n<script>\n\timport { page, +++navigating+++ } from '$app/state';\n\n\tlet { children } = $props();\n</script>\n\n<nav>\n\t<a href=\"/\" aria-current={page.url.pathname === '/'}>\n\t\thome\n\t</a>\n\n\t<a href=\"/about\" aria-current={page.url.pathname === '/about'}>\n\t\tabout\n\t</a>\n\n+++\t{#if navigating.to}\n\t\tnavigating to {navigating.to.url.pathname}\n\t{/if}+++\n</nav>\n\n{@render children()}[!NOTE] Prior to SvelteKit 2.12, you had to use `$app/stores` for this, which provides a `$navigating` store with the same information. If you're currently using `$app/stores`, we advise you to migrate towards `$app/state` (requires Svelte 5).",
              "href": "/tutorial/kit/navigating-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "$app/state",
                "updated"
              ],
              "content": "The updated state contains true or false depending on whether a new version of the app has been deployed since the page was first opened. For this to work, your svelte.config.js must specify kit.version.pollInterval. \n<script>\n\timport { page, navigating, +++updated+++ } from '$app/state';\n</script>Version changes only happen in production, not during development. For that reason, updated.current will always be false in this tutorial.You can manually check for new versions, regardless of pollInterval, by calling updated.check(). \n\n+++{#if updated.current}+++\n\t<div class=\"toast\">\n\t\t<p>\n\t\t\tA new version of the app is available\n\n\t\t\t<button onclick={() => location.reload()}>\n\t\t\t\treload the page\n\t\t\t</button>\n\t\t</p>\n\t</div>\n+++{/if}+++[!NOTE] Prior to SvelteKit 2.12, you had to use `$app/stores` for this, which provides an `$updated` store with the same information. If you're currently using `$app/stores`, we advise you to migrate towards `$app/state` (requires Svelte 5).",
              "href": "/tutorial/kit/updated-state"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Basic SvelteKit",
                "Errors and redirects",
                "Error pages"
              ],
              "content": "When something goes wrong inside a load function, SvelteKit renders an error page.The default error page is somewhat bland. We can customize it by creating a src/routes/+error.svelte component: \n<script>\n\timport { page } from '$app/state';\n\timport { emojis } from './emojis.js';\n</script>\n\n<h1>{page.status} {page.error.message}</h1>\n<span style=\"font-size: 10em\">\n\t{emojis[page.status] ?? emojis[500]}\n</span>Notice that the +error.svelte component is rendered inside the root +layout.svelte. We can create more granular +error.svelte boundaries: \n<h1>this error was expected</h1>This component will be rendered for /expected, while the root src/routes/+error.svelte page will be rendered for any other errors that occur.",
              "href": "/tutorial/kit/error-pages"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Hooks",
                "handle"
              ],
              "content": "SvelteKit provides several hooks — ways to intercept and override the framework's default behaviour.The most elementary hook is handle, which lives in src/hooks.server.js. It receives an event object along with a resolve function, and returns a `Response`.resolve is where the magic happens: SvelteKit matches the incoming request URL to a route of your app, imports the relevant code (+page.server.js and +page.svelte files and so on), loads the data needed by the route, and generates the response.The default handle hook looks like this: \nexport async function handle({ event, resolve }) {\n\treturn await resolve(event);\n}For pages (as opposed to API routes), you can modify the generated HTML with transformPageChunk: \nexport async function handle({ event, resolve }) {\n\treturn await resolve(event, {\n+++\t\ttransformPageChunk: ({ html }) => html.replace(\n\t\t\t'<body',\n\t\t\t'<body style=\"color: hotpink\"'\n\t\t)+++\n\t});\n}You can also create entirely new routes: \nexport async function handle({ event, resolve }) {\n+++\tif (event.url.pathname === '/ping') {\n\t\treturn new Response('pong');\n\t}+++\n\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace(\n\t\t\t'<body',\n\t\t\t'<body style=\"color: hotpink\"'\n\t\t)\n\t});\n}",
              "href": "/tutorial/kit/handle"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Hooks",
                "handleError"
              ],
              "content": "The handleError hook lets you intercept unexpected errors and trigger some behaviour, like pinging a Slack channel or sending data to an error logging service.As you'll recall from an earlier exercise, an error is unexpected if it wasn't created with the error helper from @sveltejs/kit. It generally means something in your app needs fixing. The default behaviour is to log the error: \nexport function handleError({ event, error }) {\n\tconsole.error(error.stack);\n}If you navigate to /the-bad-place, you'll see this in action — the error page is shown, and if you open the terminal (using the button to the right of the URL bar), you'll see the message from src/routes/the-bad-place/+page.server.js.Notice that we're not showing the error message to the user. That's because error messages can include sensitive information that at best will confuse your users, and at worst could benefit evildoers. Instead, the error object available to your application — represented as page.error in your +error.svelte pages, or %sveltekit.error% in your src/error.html fallback — is just this:\n{\n\tmessage: 'Internal Error' // or 'Not Found' for a 404\n}\nIn some situations you may want to customise this object. To do so, you can return an object from handleError: \nexport function handleError({ event, error }) {\n\tconsole.error(error.stack);\n\n\treturn {\n\t\tmessage: 'everything is fine',\n\t\tcode: 'JEREMYBEARIMY'\n\t};\n}You can now reference properties other than message in a custom error page. Create src/routes/+error.svelte: \n<script>\n\timport { page } from '$app/state';\n</script>\n\n<h1>{page.status}</h1>\n<p>{page.error.message}</p>\n<p>error code: {page.error.code}</p>",
              "href": "/tutorial/kit/handleerror"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Advanced routing",
                "Optional parameters"
              ],
              "content": "In the first chapter on routing, we learned how to create routes with dynamic parameters.Sometimes it's helpful to make a parameter optional. A classic example is when you use the pathname to determine the locale — /fr/..., /de/... and so on — but you also want to have a default locale.To do that, we use double brackets. Rename the [lang] directory to [[lang]].The app now fails to build, because src/routes/+page.svelte and src/routes/[[lang]]/+page.svelte would both match /. Delete src/routes/+page.svelte. (You may need to reload the app to recover from the error page).Lastly, edit src/routes/[[lang]]/+page.server.js to specify the default locale: \nconst greetings = {\n\ten: 'hello!',\n\tde: 'hallo!',\n\tfr: 'bonjour!'\n};\n\nexport function load({ params }) {\n\treturn {\n\t\tgreeting: greetings[params.lang +++?? 'en'+++]\n\t};\n}",
              "href": "/tutorial/kit/optional-params"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Advanced routing",
                "Param matchers"
              ],
              "content": "To prevent the router from matching on invalid input, you can specify a matcher. For example, you might want a route like /colors/[value] to match hex values like /colors/ff3e00 but not named colors like /colors/octarine or any other arbitrary input.First, create a new file called src/params/hex.js and export a match function from it: \nexport function match(value) {\n\treturn /^[0-9a-f]{6}$/.test(value);\n}Then, to use the new matcher, rename src/routes/colors/[color] to src/routes/colors/[color=hex].Now, whenever someone navigates to that route, SvelteKit will verify that color is a valid hex value. If not, SvelteKit will try to match other routes, before eventually returning a 404.[!NOTE] Matchers run both on the server and in the browser.",
              "href": "/tutorial/kit/param-matchers"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Advanced loading",
                "Custom dependencies"
              ],
              "content": "Calling fetch(url) inside a load function registers url as a dependency. Sometimes it's not appropriate to use fetch, in which case you can specify a dependency manually with the `depends(url)` function.Since any string that begins with an [a-z]+: pattern is a valid URL, we can create custom invalidation keys like data:now.Update src/routes/+layout.js to return a value directly rather than making a fetch call, and add the depends: \nexport async function load({ +++depends+++ }) {\n\t+++depends('data:now');+++\n\n\treturn {\n\t\tnow: +++Date.now()+++\n\t};\n}Now, update the invalidate call in src/routes/[...timezone]/+page.svelte: \n<script>\n\timport { onMount } from 'svelte';\n\timport { invalidate } from '$app/navigation';\n\n\tlet { data } = $props();\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tinvalidate(+++'data:now'+++);\n\t\t}, 1000);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>",
              "href": "/tutorial/kit/custom-dependencies"
            },
            {
              "breadcrumbs": [
                "Tutorial",
                "Advanced SvelteKit",
                "Conclusion",
                "Next steps"
              ],
              "content": "Congratulations! If you've made it the entire way through this tutorial, you can now consider yourself a Svelte and SvelteKit expert.You can start building apps on your own machine with Svelte CLI:npx sv createSvelte and SvelteKit will continue to evolve, and so will this tutorial. Check back periodically for updates.To keep up with developments in the Svelte world, join our Discord server at svelte.dev/chat and follow Svelte Society on BlueSky. We're so happy to welcome you to the Svelte community!",
              "href": "/tutorial/kit/next-steps"
            }
          ]
        },
        "expected": [
          {
            "callsTool": {
              "arguments": {
                "query": "create state"
              },
              "name": "search-svelte-docs"
            }
          }
        ]
      }
    ]
  }
}
