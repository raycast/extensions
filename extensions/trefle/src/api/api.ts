/* tslint:disable */
/* eslint-disable */
/**
 * Trefle API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ClaimClientSideToken200Response
 */
export interface ClaimClientSideToken200Response {
    /**
     * The expiration time of the token. After this time, you\'ll have to request a token again
     * @type {string}
     * @memberof ClaimClientSideToken200Response
     */
    'expiration'?: string;
    /**
     * The client-side access token, that you\'ll use instead of your access token in the `token` parameter
     * @type {string}
     * @memberof ClaimClientSideToken200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ClaimClientSideTokenRequest
 */
export interface ClaimClientSideTokenRequest {
    /**
     * The website url the API requests will come from
     * @type {string}
     * @memberof ClaimClientSideTokenRequest
     */
    'origin': string;
    /**
     * The client IP
     * @type {string}
     * @memberof ClaimClientSideTokenRequest
     */
    'ip'?: string | null;
}
/**
 * 
 * @export
 * @interface Correction
 */
export interface Correction {
    /**
     * 
     * @type {number}
     * @memberof Correction
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'accepted_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'change_notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'change_status': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'change_type': string;
    /**
     * 
     * @type {object}
     * @memberof Correction
     */
    'correction'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'notes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Correction
     */
    'record_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'record_type': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Correction
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'warning_type'?: string | null;
}
/**
 * 
 * @export
 * @interface Division
 */
export interface Division {
    /**
     * 
     * @type {number}
     * @memberof Division
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Division
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Division
     */
    'slug': string;
    /**
     * 
     * @type {Subkingdom}
     * @memberof Division
     */
    'subkingdom': Subkingdom;
    /**
     * 
     * @type {DivisionLinks}
     * @memberof Division
     */
    'links': DivisionLinks;
}
/**
 * 
 * @export
 * @interface DivisionClass
 */
export interface DivisionClass {
    /**
     * 
     * @type {number}
     * @memberof DivisionClass
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DivisionClass
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DivisionClass
     */
    'slug': string;
    /**
     * 
     * @type {Division}
     * @memberof DivisionClass
     */
    'division'?: Division;
    /**
     * 
     * @type {DivisionClassLinks}
     * @memberof DivisionClass
     */
    'links': DivisionClassLinks;
}
/**
 * 
 * @export
 * @interface DivisionClassLinks
 */
export interface DivisionClassLinks {
    /**
     * 
     * @type {string}
     * @memberof DivisionClassLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof DivisionClassLinks
     */
    'division'?: string;
}
/**
 * 
 * @export
 * @interface DivisionLinks
 */
export interface DivisionLinks {
    /**
     * 
     * @type {string}
     * @memberof DivisionLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof DivisionLinks
     */
    'subkingdom': string;
}
/**
 * 
 * @export
 * @interface DivisionOrder
 */
export interface DivisionOrder {
    /**
     * 
     * @type {number}
     * @memberof DivisionOrder
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DivisionOrder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DivisionOrder
     */
    'slug': string;
    /**
     * 
     * @type {DivisionClass}
     * @memberof DivisionOrder
     */
    'division_class'?: DivisionClass;
    /**
     * 
     * @type {DivisionOrderLinks}
     * @memberof DivisionOrder
     */
    'links': DivisionOrderLinks;
}
/**
 * 
 * @export
 * @interface DivisionOrderLinks
 */
export interface DivisionOrderLinks {
    /**
     * 
     * @type {string}
     * @memberof DivisionOrderLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof DivisionOrderLinks
     */
    'division_class'?: string;
}
/**
 * 
 * @export
 * @interface Family
 */
export interface Family {
    /**
     * 
     * @type {number}
     * @memberof Family
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Family
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Family
     */
    'common_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Family
     */
    'slug': string;
    /**
     * 
     * @type {DivisionOrder}
     * @memberof Family
     */
    'division_order'?: DivisionOrder;
    /**
     * 
     * @type {FamilyLinks}
     * @memberof Family
     */
    'links': FamilyLinks;
}
/**
 * 
 * @export
 * @interface FamilyLinks
 */
export interface FamilyLinks {
    /**
     * 
     * @type {string}
     * @memberof FamilyLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof FamilyLinks
     */
    'division_order'?: string;
}
/**
 * 
 * @export
 * @interface FiltersFamilies
 */
export interface FiltersFamilies {
    /**
     * 
     * @type {string}
     * @memberof FiltersFamilies
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersFamilies
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface FiltersGenus
 */
export interface FiltersGenus {
    /**
     * 
     * @type {string}
     * @memberof FiltersGenus
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersGenus
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersGenus
     */
    'family_id'?: string;
}
/**
 * 
 * @export
 * @interface FiltersNotSpecies
 */
export interface FiltersNotSpecies {
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'average_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'bibliography'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'edible_part'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'family_common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'flower_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'flower_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'foliage_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'foliage_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'frost_free_days_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'fruit_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'fruit_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'fruit_seed_persistence'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'genus_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'ground_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'growth_form'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'growth_habit'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'growth_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'images_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'leaf_retention'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'light'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'ligneous_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'maximum_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'maximum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'maximum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'maximum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'minimum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'minimum_root_depth_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'minimum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'minimum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'ph_maximum'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'ph_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'planting_days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'planting_row_spacing_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'planting_spread_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'rank'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'scientific_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'soil_nutriments'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'soil_salinity'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'soil_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'sources_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'synonyms_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'toxicity'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'vegetable'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersNotSpecies
     */
    'year'?: string;
}
/**
 * 
 * @export
 * @interface FiltersPlants
 */
export interface FiltersPlants {
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'bloom_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'establishment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'edible'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'edible_part'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'family_common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'flower_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'flower_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'foliage_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'foliage_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'fruit_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'fruit_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'fruit_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'fruit_seed_persistence'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'genus_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'growth_form'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'growth_habit'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'growth_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'growth_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'leaf_retention'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'ligneous_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'rank'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'scientific_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersPlants
     */
    'vegetable'?: string;
}
/**
 * 
 * @export
 * @interface FiltersSpecies
 */
export interface FiltersSpecies {
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'bloom_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'establishment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'edible'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'edible_part'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'family_common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'flower_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'flower_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'foliage_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'foliage_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'fruit_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'fruit_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'fruit_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'fruit_seed_persistence'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'genus_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'growth_form'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'growth_habit'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'growth_months'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'growth_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'leaf_retention'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'ligneous_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'rank'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'scientific_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiltersSpecies
     */
    'vegetable'?: string;
}
/**
 * 
 * @export
 * @interface Genus
 */
export interface Genus {
    /**
     * 
     * @type {number}
     * @memberof Genus
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Genus
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Genus
     */
    'slug': string;
    /**
     * 
     * @type {Family}
     * @memberof Genus
     */
    'family'?: Family;
    /**
     * 
     * @type {GenusLinks}
     * @memberof Genus
     */
    'links': GenusLinks;
}
/**
 * 
 * @export
 * @interface GenusLinks
 */
export interface GenusLinks {
    /**
     * 
     * @type {string}
     * @memberof GenusLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof GenusLinks
     */
    'family'?: string;
}
/**
 * 
 * @export
 * @interface GetDivision200Response
 */
export interface GetDivision200Response {
    /**
     * 
     * @type {Division}
     * @memberof GetDivision200Response
     */
    'data'?: Division;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetDivision200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetDivisionClass200Response
 */
export interface GetDivisionClass200Response {
    /**
     * 
     * @type {DivisionClass}
     * @memberof GetDivisionClass200Response
     */
    'data'?: DivisionClass;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetDivisionClass200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetDivisionOrder200Response
 */
export interface GetDivisionOrder200Response {
    /**
     * 
     * @type {DivisionOrder}
     * @memberof GetDivisionOrder200Response
     */
    'data'?: DivisionOrder;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetDivisionOrder200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetFamily200Response
 */
export interface GetFamily200Response {
    /**
     * 
     * @type {Family}
     * @memberof GetFamily200Response
     */
    'data'?: Family;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetFamily200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetGenus200Response
 */
export interface GetGenus200Response {
    /**
     * 
     * @type {Genus}
     * @memberof GetGenus200Response
     */
    'data'?: Genus;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetGenus200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetKingdom200Response
 */
export interface GetKingdom200Response {
    /**
     * 
     * @type {Kingdom}
     * @memberof GetKingdom200Response
     */
    'data'?: Kingdom;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetKingdom200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetKingdom200ResponseMeta
 */
export interface GetKingdom200ResponseMeta {
    /**
     * 
     * @type {string}
     * @memberof GetKingdom200ResponseMeta
     */
    'last_modified'?: string;
}
/**
 * 
 * @export
 * @interface GetPlant200Response
 */
export interface GetPlant200Response {
    /**
     * 
     * @type {Plant}
     * @memberof GetPlant200Response
     */
    'data'?: Plant;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetPlant200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetSpecies200Response
 */
export interface GetSpecies200Response {
    /**
     * 
     * @type {Species}
     * @memberof GetSpecies200Response
     */
    'data'?: Species;
    /**
     * 
     * @type {GetSpecies200ResponseMeta}
     * @memberof GetSpecies200Response
     */
    'meta'?: GetSpecies200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetSpecies200ResponseMeta
 */
export interface GetSpecies200ResponseMeta {
    /**
     * 
     * @type {string}
     * @memberof GetSpecies200ResponseMeta
     */
    'last_modified'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetSpecies200ResponseMeta
     */
    'images_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSpecies200ResponseMeta
     */
    'sources_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSpecies200ResponseMeta
     */
    'synonyms_count'?: number;
}
/**
 * 
 * @export
 * @interface GetSubkingdom200Response
 */
export interface GetSubkingdom200Response {
    /**
     * 
     * @type {Subkingdom}
     * @memberof GetSubkingdom200Response
     */
    'data'?: Subkingdom;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetSubkingdom200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface GetZone200Response
 */
export interface GetZone200Response {
    /**
     * 
     * @type {Zone}
     * @memberof GetZone200Response
     */
    'data'?: Zone;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof GetZone200Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface Kingdom
 */
export interface Kingdom {
    /**
     * 
     * @type {number}
     * @memberof Kingdom
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Kingdom
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Kingdom
     */
    'slug': string;
    /**
     * 
     * @type {KingdomLinks}
     * @memberof Kingdom
     */
    'links': KingdomLinks;
}
/**
 * 
 * @export
 * @interface KingdomLinks
 */
export interface KingdomLinks {
    /**
     * 
     * @type {string}
     * @memberof KingdomLinks
     */
    'self': string;
}
/**
 * 
 * @export
 * @interface ListCorrections200Response
 */
export interface ListCorrections200Response {
    /**
     * 
     * @type {Array<Correction>}
     * @memberof ListCorrections200Response
     */
    'data'?: Array<Correction>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListCorrections200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListCorrections200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListDistributions200Response
 */
export interface ListDistributions200Response {
    /**
     * 
     * @type {Array<Zone>}
     * @memberof ListDistributions200Response
     */
    'data'?: Array<Zone>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListDistributions200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListDistributions200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListDivisionClasses200Response
 */
export interface ListDivisionClasses200Response {
    /**
     * 
     * @type {Array<DivisionClass>}
     * @memberof ListDivisionClasses200Response
     */
    'data'?: Array<DivisionClass>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListDivisionClasses200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListDivisionClasses200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListDivisionOrders200Response
 */
export interface ListDivisionOrders200Response {
    /**
     * 
     * @type {Array<DivisionOrder>}
     * @memberof ListDivisionOrders200Response
     */
    'data'?: Array<DivisionOrder>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListDivisionOrders200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListDivisionOrders200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListDivisions200Response
 */
export interface ListDivisions200Response {
    /**
     * 
     * @type {Array<Division>}
     * @memberof ListDivisions200Response
     */
    'data'?: Array<Division>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListDivisions200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListDivisions200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListFamilies200Response
 */
export interface ListFamilies200Response {
    /**
     * 
     * @type {Array<Family>}
     * @memberof ListFamilies200Response
     */
    'data'?: Array<Family>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListFamilies200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListFamilies200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListGenus200Response
 */
export interface ListGenus200Response {
    /**
     * 
     * @type {Array<Genus>}
     * @memberof ListGenus200Response
     */
    'data'?: Array<Genus>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListGenus200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListGenus200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListKingdoms200Response
 */
export interface ListKingdoms200Response {
    /**
     * 
     * @type {Array<Kingdom>}
     * @memberof ListKingdoms200Response
     */
    'data'?: Array<Kingdom>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListKingdoms200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListKingdoms200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListKingdoms200ResponseLinks
 */
export interface ListKingdoms200ResponseLinks {
    /**
     * A link to the current page of the collection
     * @type {string}
     * @memberof ListKingdoms200ResponseLinks
     */
    'self': string;
    /**
     * A link to the first page of the collection
     * @type {string}
     * @memberof ListKingdoms200ResponseLinks
     */
    'first'?: string;
    /**
     * A link to the next page of the collection
     * @type {string}
     * @memberof ListKingdoms200ResponseLinks
     */
    'next'?: string;
    /**
     * A link to the previous page of the collection
     * @type {string}
     * @memberof ListKingdoms200ResponseLinks
     */
    'prev'?: string;
    /**
     * A link to the last page of the collection
     * @type {string}
     * @memberof ListKingdoms200ResponseLinks
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface ListKingdoms200ResponseMeta
 */
export interface ListKingdoms200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof ListKingdoms200ResponseMeta
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ListPlants200Response
 */
export interface ListPlants200Response {
    /**
     * 
     * @type {Array<SpeciesLight>}
     * @memberof ListPlants200Response
     */
    'data'?: Array<SpeciesLight>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListPlants200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListPlants200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ListSubkingdoms200Response
 */
export interface ListSubkingdoms200Response {
    /**
     * 
     * @type {Array<Subkingdom>}
     * @memberof ListSubkingdoms200Response
     */
    'data'?: Array<Subkingdom>;
    /**
     * 
     * @type {ListKingdoms200ResponseLinks}
     * @memberof ListSubkingdoms200Response
     */
    'links'?: ListKingdoms200ResponseLinks;
    /**
     * 
     * @type {ListKingdoms200ResponseMeta}
     * @memberof ListSubkingdoms200Response
     */
    'meta'?: ListKingdoms200ResponseMeta;
}
/**
 * 
 * @export
 * @interface Plant
 */
export interface Plant {
    /**
     * 
     * @type {number}
     * @memberof Plant
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'common_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'scientific_name': string;
    /**
     * 
     * @type {number}
     * @memberof Plant
     */
    'year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'family_common_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Plant
     */
    'genus_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Plant
     */
    'main_species_id'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Plant
     */
    'vegetable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Plant
     */
    'observations'?: string | null;
    /**
     * 
     * @type {Species}
     * @memberof Plant
     */
    'main_species'?: Species;
    /**
     * 
     * @type {Array<Source>}
     * @memberof Plant
     */
    'sources'?: Array<Source>;
    /**
     * 
     * @type {PlantLinks}
     * @memberof Plant
     */
    'links': PlantLinks;
}
/**
 * 
 * @export
 * @interface PlantLight
 */
export interface PlantLight {
    /**
     * 
     * @type {number}
     * @memberof PlantLight
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'common_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'scientific_name': string;
    /**
     * 
     * @type {number}
     * @memberof PlantLight
     */
    'year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'bibliography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'family_common_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlantLight
     */
    'genus_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlantLight
     */
    'main_species_id'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlantLight
     */
    'vegetable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PlantLight
     */
    'observations'?: string | null;
    /**
     * 
     * @type {PlantLinks}
     * @memberof PlantLight
     */
    'links': PlantLinks;
}
/**
 * 
 * @export
 * @interface PlantLinks
 */
export interface PlantLinks {
    /**
     * 
     * @type {string}
     * @memberof PlantLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof PlantLinks
     */
    'genus': string;
    /**
     * 
     * @type {string}
     * @memberof PlantLinks
     */
    'species': string;
}
/**
 * 
 * @export
 * @interface RangesPlants
 */
export interface RangesPlants {
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'atmospheric_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'average_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'frost_free_days_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'ground_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'images_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'light'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'maximum_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'maximum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'maximum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'maximum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'minimum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'minimum_root_depth_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'minimum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'minimum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'ph_maximum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'ph_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'planting_days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'planting_row_spacing_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'planting_spread_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'soil_nutriments'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'soil_salinity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'soil_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'sources_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'synonyms_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'toxicity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesPlants
     */
    'year'?: string;
}
/**
 * 
 * @export
 * @interface RangesSpecies
 */
export interface RangesSpecies {
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'atmospheric_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'average_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'frost_free_days_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'ground_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'images_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'light'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'maximum_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'maximum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'maximum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'maximum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'minimum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'minimum_root_depth_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'minimum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'minimum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'ph_maximum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'ph_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'planting_days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'planting_row_spacing_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'planting_spread_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'soil_nutriments'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'soil_salinity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'soil_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'sources_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'synonyms_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'toxicity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangesSpecies
     */
    'year'?: string;
}
/**
 * 
 * @export
 * @interface ReportPlants201Response
 */
export interface ReportPlants201Response {
    /**
     * 
     * @type {Correction}
     * @memberof ReportPlants201Response
     */
    'data'?: Correction;
    /**
     * 
     * @type {GetKingdom200ResponseMeta}
     * @memberof ReportPlants201Response
     */
    'meta'?: GetKingdom200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ReportPlantsRequest
 */
export interface ReportPlantsRequest {
    /**
     * An optional note about the incorrect data
     * @type {string}
     * @memberof ReportPlantsRequest
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface RequestBodyCorrection
 */
export interface RequestBodyCorrection {
    /**
     * Some optional notes you can add. They will be visible to everybody
     * @type {string}
     * @memberof RequestBodyCorrection
     */
    'notes'?: string | null;
    /**
     * Where does this data come from ? If \"external\", you\'ll need to provide the \"source_reference\" field with the url or the name of the source, such as a wikipedia article, a publication, etc...
     * @type {string}
     * @memberof RequestBodyCorrection
     */
    'source_type'?: RequestBodyCorrectionSourceTypeEnum | null;
    /**
     * The url of the name of an article or a publication for theses changes
     * @type {string}
     * @memberof RequestBodyCorrection
     */
    'source_reference'?: string | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrection}
     * @memberof RequestBodyCorrection
     */
    'correction'?: RequestBodyCorrectionCorrection;
}

export const RequestBodyCorrectionSourceTypeEnum = {
    External: 'external',
    Observation: 'observation',
    Report: 'report',
    Null: 'null'
} as const;

export type RequestBodyCorrectionSourceTypeEnum = typeof RequestBodyCorrectionSourceTypeEnum[keyof typeof RequestBodyCorrectionSourceTypeEnum];

/**
 * The fields to correct
 * @export
 * @interface RequestBodyCorrectionCorrection
 */
export interface RequestBodyCorrectionCorrection {
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'scientific_name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'rank'?: RequestBodyCorrectionCorrectionRankEnum;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'genus'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'bibliography'?: string | null;
    /**
     * The species common name(s) in english. Several values can be separated with \"|\"
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'common_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'observations'?: string | null;
    /**
     * A description on how the plant usually grows
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_sowing_description'?: string | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionDuration}
     * @memberof RequestBodyCorrectionCorrection
     */
    'duration'?: RequestBodyCorrectionCorrectionDuration;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionFlowerColor}
     * @memberof RequestBodyCorrectionCorrection
     */
    'flower_color'?: RequestBodyCorrectionCorrectionFlowerColor;
    /**
     * 
     * @type {boolean}
     * @memberof RequestBodyCorrectionCorrection
     */
    'flower_conspicuous'?: boolean | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionFoliageColor}
     * @memberof RequestBodyCorrectionCorrection
     */
    'foliage_color'?: RequestBodyCorrectionCorrectionFoliageColor;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'foliage_texture'?: RequestBodyCorrectionCorrectionFoliageTextureEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof RequestBodyCorrectionCorrection
     */
    'leaf_retention'?: boolean | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionFruitColor}
     * @memberof RequestBodyCorrectionCorrection
     */
    'fruit_color'?: RequestBodyCorrectionCorrectionFruitColor;
    /**
     * 
     * @type {boolean}
     * @memberof RequestBodyCorrectionCorrection
     */
    'fruit_conspicuous'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof RequestBodyCorrectionCorrection
     */
    'fruit_seed_persistence'?: boolean | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionFruitMonths}
     * @memberof RequestBodyCorrectionCorrection
     */
    'fruit_months'?: RequestBodyCorrectionCorrectionFruitMonths;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionBloomMonths}
     * @memberof RequestBodyCorrectionCorrection
     */
    'bloom_months'?: RequestBodyCorrectionCorrectionBloomMonths;
    /**
     * Required humidity of the soil, on a scale from 0 (xerophile) to 10 (subaquatic)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'ground_humidity'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'growth_form'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'growth_habit'?: string | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionGrowthMonths}
     * @memberof RequestBodyCorrectionCorrection
     */
    'growth_months'?: RequestBodyCorrectionCorrectionGrowthMonths;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'growth_rate'?: string | null;
    /**
     * 
     * @type {RequestBodyCorrectionCorrectionEdiblePart}
     * @memberof RequestBodyCorrectionCorrection
     */
    'edible_part'?: RequestBodyCorrectionCorrectionEdiblePart;
    /**
     * 
     * @type {boolean}
     * @memberof RequestBodyCorrectionCorrection
     */
    'vegetable'?: boolean | null;
    /**
     * Required amount of light, on a scale from 0 (no light, <= 10 lux) to 10 (very intensive insolation, >= 100 000 lux)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'light'?: number | null;
    /**
     * Required relative humidity in the air, on a scale from 0 (<=10%) to 10 (>= 90%)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'atmospheric_humidity'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'adapted_to_coarse_textured_soils'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'adapted_to_fine_textured_soils'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'adapted_to_medium_textured_soils'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'anaerobic_tolerance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'average_height_unit'?: RequestBodyCorrectionCorrectionAverageHeightUnitEnum | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'average_height_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'maximum_height_unit'?: RequestBodyCorrectionCorrectionMaximumHeightUnitEnum | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'maximum_height_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_row_spacing_unit'?: RequestBodyCorrectionCorrectionPlantingRowSpacingUnitEnum | null;
    /**
     * The minimum spacing between each rows of plants
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_row_spacing_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_spread_unit'?: RequestBodyCorrectionCorrectionPlantingSpreadUnitEnum | null;
    /**
     * The average spreading of the plant
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_spread_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'planting_days_to_harvest'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'maximum_precipitation_unit'?: RequestBodyCorrectionCorrectionMaximumPrecipitationUnitEnum | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'maximum_precipitation_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'minimum_precipitation_unit'?: RequestBodyCorrectionCorrectionMinimumPrecipitationUnitEnum | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'minimum_precipitation_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'minimum_root_depth_unit'?: RequestBodyCorrectionCorrectionMinimumRootDepthUnitEnum | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'minimum_root_depth_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'ph_maximum'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'ph_minimum'?: number | null;
    /**
     * Required quantity of nutriments in the soil, on a scale from 0 (oligotrophic) to 10 (hypereutrophic)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'soil_nutriments'?: number | null;
    /**
     * Tolerance to salinity, on a scale from 0 (untolerant) to 10 (hyperhaline)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'soil_salinity'?: number | null;
    /**
     * The minimum required temperature in celcius degrees
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'minimum_temperature_deg_c'?: number | null;
    /**
     * The maximum required temperature in celcius degrees
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'maximum_temperature_deg_c'?: number | null;
    /**
     * Required texture of the soil, on a scale from 0 (clay) to 10 (rock)
     * @type {number}
     * @memberof RequestBodyCorrectionCorrection
     */
    'soil_texture'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'ligneous_type'?: RequestBodyCorrectionCorrectionLigneousTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof RequestBodyCorrectionCorrection
     */
    'toxicity'?: RequestBodyCorrectionCorrectionToxicityEnum | null;
}

export const RequestBodyCorrectionCorrectionRankEnum = {
    Species: 'species',
    Ssp: 'ssp',
    Var: 'var',
    Form: 'form',
    Hybrid: 'hybrid',
    Subvar: 'subvar',
    Null: 'null'
} as const;

export type RequestBodyCorrectionCorrectionRankEnum = typeof RequestBodyCorrectionCorrectionRankEnum[keyof typeof RequestBodyCorrectionCorrectionRankEnum];
export const RequestBodyCorrectionCorrectionFoliageTextureEnum = {
    Fine: 'fine',
    Medium: 'medium',
    Coarse: 'coarse',
    Null: 'null'
} as const;

export type RequestBodyCorrectionCorrectionFoliageTextureEnum = typeof RequestBodyCorrectionCorrectionFoliageTextureEnum[keyof typeof RequestBodyCorrectionCorrectionFoliageTextureEnum];
export const RequestBodyCorrectionCorrectionAverageHeightUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionAverageHeightUnitEnum = typeof RequestBodyCorrectionCorrectionAverageHeightUnitEnum[keyof typeof RequestBodyCorrectionCorrectionAverageHeightUnitEnum];
export const RequestBodyCorrectionCorrectionMaximumHeightUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionMaximumHeightUnitEnum = typeof RequestBodyCorrectionCorrectionMaximumHeightUnitEnum[keyof typeof RequestBodyCorrectionCorrectionMaximumHeightUnitEnum];
export const RequestBodyCorrectionCorrectionPlantingRowSpacingUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionPlantingRowSpacingUnitEnum = typeof RequestBodyCorrectionCorrectionPlantingRowSpacingUnitEnum[keyof typeof RequestBodyCorrectionCorrectionPlantingRowSpacingUnitEnum];
export const RequestBodyCorrectionCorrectionPlantingSpreadUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionPlantingSpreadUnitEnum = typeof RequestBodyCorrectionCorrectionPlantingSpreadUnitEnum[keyof typeof RequestBodyCorrectionCorrectionPlantingSpreadUnitEnum];
export const RequestBodyCorrectionCorrectionMaximumPrecipitationUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Mm: 'mm',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionMaximumPrecipitationUnitEnum = typeof RequestBodyCorrectionCorrectionMaximumPrecipitationUnitEnum[keyof typeof RequestBodyCorrectionCorrectionMaximumPrecipitationUnitEnum];
export const RequestBodyCorrectionCorrectionMinimumPrecipitationUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Mm: 'mm',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionMinimumPrecipitationUnitEnum = typeof RequestBodyCorrectionCorrectionMinimumPrecipitationUnitEnum[keyof typeof RequestBodyCorrectionCorrectionMinimumPrecipitationUnitEnum];
export const RequestBodyCorrectionCorrectionMinimumRootDepthUnitEnum = {
    In: 'in',
    Ft: 'ft',
    Cm: 'cm',
    M: 'm'
} as const;

export type RequestBodyCorrectionCorrectionMinimumRootDepthUnitEnum = typeof RequestBodyCorrectionCorrectionMinimumRootDepthUnitEnum[keyof typeof RequestBodyCorrectionCorrectionMinimumRootDepthUnitEnum];
export const RequestBodyCorrectionCorrectionLigneousTypeEnum = {
    Liana: 'liana',
    Subshrub: 'subshrub',
    Shrub: 'shrub',
    Tree: 'tree',
    Parasite: 'parasite',
    Null: 'null'
} as const;

export type RequestBodyCorrectionCorrectionLigneousTypeEnum = typeof RequestBodyCorrectionCorrectionLigneousTypeEnum[keyof typeof RequestBodyCorrectionCorrectionLigneousTypeEnum];
export const RequestBodyCorrectionCorrectionToxicityEnum = {
    None: 'none',
    Low: 'low',
    Medium: 'medium',
    High: 'high',
    Null: 'null'
} as const;

export type RequestBodyCorrectionCorrectionToxicityEnum = typeof RequestBodyCorrectionCorrectionToxicityEnum[keyof typeof RequestBodyCorrectionCorrectionToxicityEnum];

/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionBloomMonths
 */
export interface RequestBodyCorrectionCorrectionBloomMonths {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionDuration
 */
export interface RequestBodyCorrectionCorrectionDuration {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionEdiblePart
 */
export interface RequestBodyCorrectionCorrectionEdiblePart {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionFlowerColor
 */
export interface RequestBodyCorrectionCorrectionFlowerColor {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionFoliageColor
 */
export interface RequestBodyCorrectionCorrectionFoliageColor {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionFruitColor
 */
export interface RequestBodyCorrectionCorrectionFruitColor {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionFruitMonths
 */
export interface RequestBodyCorrectionCorrectionFruitMonths {
}
/**
 * 
 * @export
 * @interface RequestBodyCorrectionCorrectionGrowthMonths
 */
export interface RequestBodyCorrectionCorrectionGrowthMonths {
}
/**
 * 
 * @export
 * @interface SortsFamilies
 */
export interface SortsFamilies {
    /**
     * 
     * @type {string}
     * @memberof SortsFamilies
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsFamilies
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface SortsGenus
 */
export interface SortsGenus {
    /**
     * 
     * @type {string}
     * @memberof SortsGenus
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsGenus
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsGenus
     */
    'family_id'?: string;
}
/**
 * 
 * @export
 * @interface SortsPlants
 */
export interface SortsPlants {
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'atmospheric_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'average_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'bibliography'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'edible'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'family_common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'flower_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'flower_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'foliage_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'foliage_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'frost_free_days_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'fruit_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'fruit_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'fruit_seed_persistence'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'ground_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'growth_form'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'growth_habit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'growth_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'images_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'leaf_retention'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'light'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'ligneous_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'maximum_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'maximum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'maximum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'maximum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'minimum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'minimum_root_depth_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'minimum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'minimum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'ph_maximum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'ph_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'planting_days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'planting_row_spacing_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'planting_spread_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'rank'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'scientific_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'soil_nutriments'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'soil_salinity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'soil_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'sources_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'synonyms_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'toxicity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'vegetable'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsPlants
     */
    'year'?: string;
}
/**
 * 
 * @export
 * @interface SortsSpecies
 */
export interface SortsSpecies {
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'atmospheric_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'average_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'bibliography'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'edible'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'family_common_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'flower_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'flower_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'foliage_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'foliage_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'frost_free_days_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'fruit_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'fruit_conspicuous'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'fruit_seed_persistence'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'ground_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'growth_form'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'growth_habit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'growth_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'images_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'leaf_retention'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'light'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'ligneous_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'maximum_height_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'maximum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'maximum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'maximum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'minimum_precipitation_mm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'minimum_root_depth_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'minimum_temperature_deg_c'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'minimum_temperature_deg_f'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'ph_maximum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'ph_minimum'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'planting_days_to_harvest'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'planting_row_spacing_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'planting_spread_cm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'rank'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'scientific_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'soil_nutriments'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'soil_salinity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'soil_texture'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'sources_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'synonyms_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'toxicity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'vegetable'?: string;
    /**
     * 
     * @type {string}
     * @memberof SortsSpecies
     */
    'year'?: string;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'last_update': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'citation'?: string | null;
}
/**
 * 
 * @export
 * @interface Species
 */
export interface Species {
    /**
     * An unique identifier
     * @type {number}
     * @memberof Species
     */
    'id': number;
    /**
     * The usual common name, in english, of the species (if any).
     * @type {string}
     * @memberof Species
     */
    'common_name'?: string | null;
    /**
     * An unique human-readable identifier (if you can, prefer to use this over id)
     * @type {string}
     * @memberof Species
     */
    'slug': string;
    /**
     * The scientific name follows the [Binomial nomenclature](https://en.wikipedia.org/wiki/Binomial_nomenclature), and represents its genus and its species within the genus, resulting in a single worldwide name for each organism. The scientific name of an infraspecific taxons (ranks below species, such as subspecies, forms, varieties...) is a combination of the name of a species and an infraspecific epithet. A connecting term is used to denote the rank. [See IAPT recommendation](https://www.iapt-taxon.org/nomen/pages/main/art_24.html)
     * @type {string}
     * @memberof Species
     */
    'scientific_name': string;
    /**
     * The first publication year of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {number}
     * @memberof Species
     */
    'year'?: number | null;
    /**
     * The first publication of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {string}
     * @memberof Species
     */
    'bibliography'?: string | null;
    /**
     * The author(s) of the first publication of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {string}
     * @memberof Species
     */
    'author'?: string | null;
    /**
     * The acceptance status of this species by IPNI
     * @type {string}
     * @memberof Species
     */
    'status'?: SpeciesStatusEnum;
    /**
     * The [taxonomic rank](https://en.wikipedia.org/wiki/Taxonomic_rank) of the species
     * @type {string}
     * @memberof Species
     */
    'rank'?: SpeciesRankEnum;
    /**
     * The common name (in english) of the species family
     * @type {string}
     * @memberof Species
     */
    'family_common_name'?: string | null;
    /**
     * The scientific name of the species family
     * @type {string}
     * @memberof Species
     */
    'family'?: string;
    /**
     * The id of the species genus
     * @type {number}
     * @memberof Species
     */
    'genus_id'?: number;
    /**
     * The scientific name of the species genus
     * @type {string}
     * @memberof Species
     */
    'genus'?: string;
    /**
     * A main image url of the species
     * @type {string}
     * @memberof Species
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {SpeciesLinks}
     * @memberof Species
     */
    'links'?: SpeciesLinks;
    /**
     * The plant duration(s), which can be: - Annual: plants that live, reproduce, and die in one growing season. - Biennial: plants that need two growing seasons to complete their life cycle, normally completing vegetative growth the first year and flowering the second year. - Perennial: plants that live for more than two years, with the shoot system dying back to soil level each year. 
     * @type {Array<string>}
     * @memberof Species
     */
    'duration'?: Array<SpeciesDurationEnum> | null;
    /**
     * The plant edible part(s), if any.
     * @type {Array<string>}
     * @memberof Species
     */
    'edible_part'?: Array<SpeciesEdiblePartEnum> | null;
    /**
     * Is the species edible?
     * @type {boolean}
     * @memberof Species
     */
    'edible'?: boolean | null;
    /**
     * Is the species a vegetable?
     * @type {boolean}
     * @memberof Species
     */
    'vegetable'?: boolean | null;
    /**
     * Some habit observations on the species
     * @type {string}
     * @memberof Species
     */
    'observations'?: string | null;
    /**
     * 
     * @type {SpeciesImages}
     * @memberof Species
     */
    'images'?: SpeciesImages;
    /**
     * Common names of the species per language
     * @type {{ [key: string]: Array<string>; }}
     * @memberof Species
     */
    'common_names'?: { [key: string]: Array<string>; };
    /**
     * (Deprecated) Distribution of the species per establishment
     * @type {{ [key: string]: Array<string>; }}
     * @memberof Species
     * @deprecated
     */
    'distribution'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {SpeciesDistributions}
     * @memberof Species
     */
    'distributions'?: SpeciesDistributions;
    /**
     * 
     * @type {SpeciesFlower}
     * @memberof Species
     */
    'flower'?: SpeciesFlower;
    /**
     * 
     * @type {SpeciesFoliage}
     * @memberof Species
     */
    'foliage'?: SpeciesFoliage;
    /**
     * 
     * @type {SpeciesFruitOrSeed}
     * @memberof Species
     */
    'fruit_or_seed'?: SpeciesFruitOrSeed;
    /**
     * 
     * @type {SpeciesSpecifications}
     * @memberof Species
     */
    'specifications'?: SpeciesSpecifications;
    /**
     * 
     * @type {SpeciesGrowth}
     * @memberof Species
     */
    'growth'?: SpeciesGrowth;
    /**
     * The symonyms scientific names and authors
     * @type {Array<SpeciesSynonymsInner>}
     * @memberof Species
     */
    'synonyms'?: Array<SpeciesSynonymsInner>;
    /**
     * The symonyms scientific names and authors
     * @type {Array<SpeciesSourcesInner>}
     * @memberof Species
     */
    'sources'?: Array<SpeciesSourcesInner>;
    /**
     * 
     * @type {any}
     * @memberof Species
     */
    'extras'?: any;
}

export const SpeciesStatusEnum = {
    Accepted: 'accepted',
    Unknown: 'unknown'
} as const;

export type SpeciesStatusEnum = typeof SpeciesStatusEnum[keyof typeof SpeciesStatusEnum];
export const SpeciesRankEnum = {
    Species: 'species',
    Ssp: 'ssp',
    Var: 'var',
    Form: 'form',
    Hybrid: 'hybrid',
    Subvar: 'subvar'
} as const;

export type SpeciesRankEnum = typeof SpeciesRankEnum[keyof typeof SpeciesRankEnum];
export const SpeciesDurationEnum = {
    Annual: 'annual',
    Biennial: 'biennial',
    Perennial: 'perennial',
    Null: 'null'
} as const;

export type SpeciesDurationEnum = typeof SpeciesDurationEnum[keyof typeof SpeciesDurationEnum];
export const SpeciesEdiblePartEnum = {
    Roots: 'roots',
    Stem: 'stem',
    Leaves: 'leaves',
    Flowers: 'flowers',
    Fruits: 'fruits',
    Seeds: 'seeds',
    Tubers: 'tubers',
    Null: 'null'
} as const;

export type SpeciesEdiblePartEnum = typeof SpeciesEdiblePartEnum[keyof typeof SpeciesEdiblePartEnum];

/**
 * Distribution of the species per establishment
 * @export
 * @interface SpeciesDistributions
 */
export interface SpeciesDistributions {
    /**
     * Zones the species is native from
     * @type {Array<SpeciesDistributionsNativeInner>}
     * @memberof SpeciesDistributions
     */
    'native'?: Array<SpeciesDistributionsNativeInner>;
    /**
     * Zones the species has been introduced
     * @type {Array<SpeciesDistributionsNativeInner>}
     * @memberof SpeciesDistributions
     */
    'introduced'?: Array<SpeciesDistributionsNativeInner>;
    /**
     * Zones the species presence is doubtful
     * @type {Array<SpeciesDistributionsNativeInner>}
     * @memberof SpeciesDistributions
     */
    'doubtful'?: Array<SpeciesDistributionsNativeInner>;
    /**
     * Zones the species is absent and has been wrongly recorded
     * @type {Array<SpeciesDistributionsNativeInner>}
     * @memberof SpeciesDistributions
     */
    'absent'?: Array<SpeciesDistributionsNativeInner>;
    /**
     * Zones the species is extinct
     * @type {Array<SpeciesDistributionsNativeInner>}
     * @memberof SpeciesDistributions
     */
    'extinct'?: Array<SpeciesDistributionsNativeInner>;
}
/**
 * 
 * @export
 * @interface SpeciesDistributionsNativeInner
 */
export interface SpeciesDistributionsNativeInner {
    /**
     * An unique identifier
     * @type {number}
     * @memberof SpeciesDistributionsNativeInner
     */
    'id'?: number;
    /**
     * The zone name
     * @type {string}
     * @memberof SpeciesDistributionsNativeInner
     */
    'name'?: string;
    /**
     * An unique, human readable, identifier
     * @type {string}
     * @memberof SpeciesDistributionsNativeInner
     */
    'slug'?: string;
    /**
     * The TDWG zone unique code
     * @type {string}
     * @memberof SpeciesDistributionsNativeInner
     */
    'tdwg_code'?: string;
    /**
     * The TDWG zone level
     * @type {number}
     * @memberof SpeciesDistributionsNativeInner
     */
    'tdwg_level'?: number;
    /**
     * The number of species in this zone
     * @type {number}
     * @memberof SpeciesDistributionsNativeInner
     */
    'species_count'?: number;
    /**
     * 
     * @type {SpeciesDistributionsNativeInnerLinks}
     * @memberof SpeciesDistributionsNativeInner
     */
    'links'?: SpeciesDistributionsNativeInnerLinks;
}
/**
 * 
 * @export
 * @interface SpeciesDistributionsNativeInnerLinks
 */
export interface SpeciesDistributionsNativeInnerLinks {
    /**
     * API endpoint to the zone itself
     * @type {string}
     * @memberof SpeciesDistributionsNativeInnerLinks
     */
    'self'?: string;
    /**
     * API endpoint to the species in this zone
     * @type {string}
     * @memberof SpeciesDistributionsNativeInnerLinks
     */
    'species'?: string;
    /**
     * API endpoint to the plants in this zone
     * @type {string}
     * @memberof SpeciesDistributionsNativeInnerLinks
     */
    'plants'?: string;
}
/**
 * Flower related fields (the reproductive structure found in flowering plants)
 * @export
 * @interface SpeciesFlower
 */
export interface SpeciesFlower {
    /**
     * The flower color(s)
     * @type {Array<string>}
     * @memberof SpeciesFlower
     */
    'color'?: Array<SpeciesFlowerColorEnum> | null;
    /**
     * Is the flower visible?
     * @type {boolean}
     * @memberof SpeciesFlower
     */
    'conspicuous'?: boolean | null;
}

export const SpeciesFlowerColorEnum = {
    White: 'white',
    Red: 'red',
    Brown: 'brown',
    Orange: 'orange',
    Yellow: 'yellow',
    Lime: 'lime',
    Green: 'green',
    Cyan: 'cyan',
    Blue: 'blue',
    Purple: 'purple',
    Magenta: 'magenta',
    Grey: 'grey',
    Black: 'black',
    Null: 'null'
} as const;

export type SpeciesFlowerColorEnum = typeof SpeciesFlowerColorEnum[keyof typeof SpeciesFlowerColorEnum];

/**
 * Foliage (or leaves) related fields
 * @export
 * @interface SpeciesFoliage
 */
export interface SpeciesFoliage {
    /**
     * The general texture of the plants foliage
     * @type {string}
     * @memberof SpeciesFoliage
     */
    'texture'?: SpeciesFoliageTextureEnum | null;
    /**
     * The leaves color(s)
     * @type {Array<string>}
     * @memberof SpeciesFoliage
     */
    'color'?: Array<SpeciesFoliageColorEnum> | null;
    /**
     * Does the leaves stay all year long?
     * @type {boolean}
     * @memberof SpeciesFoliage
     */
    'leaf_retention'?: boolean | null;
}

export const SpeciesFoliageTextureEnum = {
    Fine: 'fine',
    Medium: 'medium',
    Coarse: 'coarse',
    Null: 'null'
} as const;

export type SpeciesFoliageTextureEnum = typeof SpeciesFoliageTextureEnum[keyof typeof SpeciesFoliageTextureEnum];
export const SpeciesFoliageColorEnum = {
    White: 'white',
    Red: 'red',
    Brown: 'brown',
    Orange: 'orange',
    Yellow: 'yellow',
    Lime: 'lime',
    Green: 'green',
    Cyan: 'cyan',
    Blue: 'blue',
    Purple: 'purple',
    Magenta: 'magenta',
    Grey: 'grey',
    Black: 'black',
    Null: 'null'
} as const;

export type SpeciesFoliageColorEnum = typeof SpeciesFoliageColorEnum[keyof typeof SpeciesFoliageColorEnum];

/**
 * Fruit or seed related fields
 * @export
 * @interface SpeciesFruitOrSeed
 */
export interface SpeciesFruitOrSeed {
    /**
     * Is the fruit visible?
     * @type {boolean}
     * @memberof SpeciesFruitOrSeed
     */
    'conspicuous'?: boolean | null;
    /**
     * The fruit color(s)
     * @type {Array<string>}
     * @memberof SpeciesFruitOrSeed
     */
    'color'?: Array<SpeciesFruitOrSeedColorEnum> | null;
    /**
     * Fruit shape
     * @type {string}
     * @memberof SpeciesFruitOrSeed
     */
    'shape'?: string | null;
    /**
     * Are the fruit or seed generally recognized as being persistent on the plant?
     * @type {boolean}
     * @memberof SpeciesFruitOrSeed
     */
    'seed_persistence'?: boolean | null;
}

export const SpeciesFruitOrSeedColorEnum = {
    White: 'white',
    Red: 'red',
    Brown: 'brown',
    Orange: 'orange',
    Yellow: 'yellow',
    Lime: 'lime',
    Green: 'green',
    Cyan: 'cyan',
    Blue: 'blue',
    Purple: 'purple',
    Magenta: 'magenta',
    Grey: 'grey',
    Black: 'black',
    Null: 'null'
} as const;

export type SpeciesFruitOrSeedColorEnum = typeof SpeciesFruitOrSeedColorEnum[keyof typeof SpeciesFruitOrSeedColorEnum];

/**
 * Growing of farming related fields
 * @export
 * @interface SpeciesGrowth
 */
export interface SpeciesGrowth {
    /**
     * The average numbers of days required to from planting to harvest
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'days_to_harvest'?: number | null;
    /**
     * A description on how the plant usually grows
     * @type {string}
     * @memberof SpeciesGrowth
     */
    'description'?: string | null;
    /**
     * A description on how to sow the plant
     * @type {string}
     * @memberof SpeciesGrowth
     */
    'sowing'?: string | null;
    /**
     * The maximum acceptable soil pH (of the top 30 centimeters of soil) for the plant
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'ph_maximum'?: number | null;
    /**
     * The minimum acceptable soil pH (of the top 30 centimeters of soil) for the plant
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'ph_minimum'?: number | null;
    /**
     * Required amount of light, on a scale from 0 (no light, <= 10 lux) to 10 (very intensive insolation, >= 100 000 lux)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'light'?: number | null;
    /**
     * Required relative humidity in the air, on a scale from 0 (<=10%) to 10 (>= 90%)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'atmospheric_humidity'?: number | null;
    /**
     * The most active growth months of the species (usually all year round for perennial plants)
     * @type {Array<string>}
     * @memberof SpeciesGrowth
     */
    'growth_months'?: Array<SpeciesGrowthGrowthMonthsEnum> | null;
    /**
     * The months the species usually blooms
     * @type {Array<string>}
     * @memberof SpeciesGrowth
     */
    'bloom_months'?: Array<SpeciesGrowthBloomMonthsEnum> | null;
    /**
     * The months the species usually produces fruits
     * @type {Array<string>}
     * @memberof SpeciesGrowth
     */
    'fruit_months'?: Array<SpeciesGrowthFruitMonthsEnum> | null;
    /**
     * 
     * @type {SpeciesGrowthRowSpacing}
     * @memberof SpeciesGrowth
     */
    'row_spacing'?: SpeciesGrowthRowSpacing;
    /**
     * 
     * @type {SpeciesGrowthSpread}
     * @memberof SpeciesGrowth
     */
    'spread'?: SpeciesGrowthSpread;
    /**
     * 
     * @type {SpeciesGrowthMinimumPrecipitation}
     * @memberof SpeciesGrowth
     */
    'minimum_precipitation'?: SpeciesGrowthMinimumPrecipitation;
    /**
     * 
     * @type {SpeciesGrowthMaximumPrecipitation}
     * @memberof SpeciesGrowth
     */
    'maximum_precipitation'?: SpeciesGrowthMaximumPrecipitation;
    /**
     * 
     * @type {SpeciesGrowthMinimumRootDepth}
     * @memberof SpeciesGrowth
     */
    'minimum_root_depth'?: SpeciesGrowthMinimumRootDepth;
    /**
     * 
     * @type {SpeciesGrowthMinimumTemperature}
     * @memberof SpeciesGrowth
     */
    'minimum_temperature'?: SpeciesGrowthMinimumTemperature;
    /**
     * 
     * @type {SpeciesGrowthMaximumTemperature}
     * @memberof SpeciesGrowth
     */
    'maximum_temperature'?: SpeciesGrowthMaximumTemperature;
    /**
     * Required quantity of nutriments in the soil, on a scale from 0 (oligotrophic) to 10 (hypereutrophic)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'soil_nutriments'?: number | null;
    /**
     * Tolerance to salinity, on a scale from 0 (untolerant) to 10 (hyperhaline)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'soil_salinity'?: number | null;
    /**
     * Required texture of the soil, on a scale from 0 (clay) to 10 (rock)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'soil_texture'?: number | null;
    /**
     * Required humidity of the soil, on a scale from 0 (xerophile) to 10 (subaquatic)
     * @type {number}
     * @memberof SpeciesGrowth
     */
    'soil_humidity'?: number | null;
}

export const SpeciesGrowthGrowthMonthsEnum = {
    Jan: 'jan',
    Feb: 'feb',
    Mar: 'mar',
    Apr: 'apr',
    May: 'may',
    Jun: 'jun',
    Jul: 'jul',
    Aug: 'aug',
    Sep: 'sep',
    Oct: 'oct',
    Nov: 'nov',
    Dec: 'dec',
    Null: 'null'
} as const;

export type SpeciesGrowthGrowthMonthsEnum = typeof SpeciesGrowthGrowthMonthsEnum[keyof typeof SpeciesGrowthGrowthMonthsEnum];
export const SpeciesGrowthBloomMonthsEnum = {
    Jan: 'jan',
    Feb: 'feb',
    Mar: 'mar',
    Apr: 'apr',
    May: 'may',
    Jun: 'jun',
    Jul: 'jul',
    Aug: 'aug',
    Sep: 'sep',
    Oct: 'oct',
    Nov: 'nov',
    Dec: 'dec',
    Null: 'null'
} as const;

export type SpeciesGrowthBloomMonthsEnum = typeof SpeciesGrowthBloomMonthsEnum[keyof typeof SpeciesGrowthBloomMonthsEnum];
export const SpeciesGrowthFruitMonthsEnum = {
    Jan: 'jan',
    Feb: 'feb',
    Mar: 'mar',
    Apr: 'apr',
    May: 'may',
    Jun: 'jun',
    Jul: 'jul',
    Aug: 'aug',
    Sep: 'sep',
    Oct: 'oct',
    Nov: 'nov',
    Dec: 'dec',
    Null: 'null'
} as const;

export type SpeciesGrowthFruitMonthsEnum = typeof SpeciesGrowthFruitMonthsEnum[keyof typeof SpeciesGrowthFruitMonthsEnum];

/**
 * Maximum precipitation per year, in milimeters per year
 * @export
 * @interface SpeciesGrowthMaximumPrecipitation
 */
export interface SpeciesGrowthMaximumPrecipitation {
    /**
     * Maximum precipitation per year, in milimeters per year
     * @type {number}
     * @memberof SpeciesGrowthMaximumPrecipitation
     */
    'mm'?: number | null;
}
/**
 * The maximum tolerable temperature for the species. In celsius or fahrenheit degrees
 * @export
 * @interface SpeciesGrowthMaximumTemperature
 */
export interface SpeciesGrowthMaximumTemperature {
    /**
     * The maximum tolerable temperature for the species. In fahrenheit degrees
     * @type {number}
     * @memberof SpeciesGrowthMaximumTemperature
     */
    'deg_f'?: number | null;
    /**
     * The maximum tolerable temperature for the species. In celsius degrees
     * @type {number}
     * @memberof SpeciesGrowthMaximumTemperature
     */
    'deg_c'?: number | null;
}
/**
 * Minimum precipitation per year, in milimeters per year
 * @export
 * @interface SpeciesGrowthMinimumPrecipitation
 */
export interface SpeciesGrowthMinimumPrecipitation {
    /**
     * Minimum precipitation per year, in milimeters per year
     * @type {number}
     * @memberof SpeciesGrowthMinimumPrecipitation
     */
    'mm'?: number | null;
}
/**
 * Minimum depth of soil required for the species, in centimeters. Plants that do not have roots such as rootless aquatic plants have 0
 * @export
 * @interface SpeciesGrowthMinimumRootDepth
 */
export interface SpeciesGrowthMinimumRootDepth {
    /**
     * Minimum depth of soil required for the species, in centimeters. Plants that do not have roots such as rootless aquatic plants have 0
     * @type {number}
     * @memberof SpeciesGrowthMinimumRootDepth
     */
    'cm'?: number | null;
}
/**
 * The minimum tolerable temperature for the species. In celsius or fahrenheit degrees
 * @export
 * @interface SpeciesGrowthMinimumTemperature
 */
export interface SpeciesGrowthMinimumTemperature {
    /**
     * The minimum tolerable temperature for the species. In fahrenheit degrees
     * @type {number}
     * @memberof SpeciesGrowthMinimumTemperature
     */
    'deg_f'?: number | null;
    /**
     * The minimum tolerable temperature for the species. In celsius degrees
     * @type {number}
     * @memberof SpeciesGrowthMinimumTemperature
     */
    'deg_c'?: number | null;
}
/**
 * The minimum spacing between each rows of plants, in centimeters
 * @export
 * @interface SpeciesGrowthRowSpacing
 */
export interface SpeciesGrowthRowSpacing {
    /**
     * The minimum spacing between each rows of plants, in centimeters
     * @type {number}
     * @memberof SpeciesGrowthRowSpacing
     */
    'cm'?: number | null;
}
/**
 * The average spreading of the plant, in centimeters
 * @export
 * @interface SpeciesGrowthSpread
 */
export interface SpeciesGrowthSpread {
    /**
     * The average spreading of the plant, in centimeters
     * @type {number}
     * @memberof SpeciesGrowthSpread
     */
    'cm'?: number | null;
}
/**
 * 
 * @export
 * @interface SpeciesImages
 */
export interface SpeciesImages {
    /**
     * Image(s) of the species flower
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'flower'?: Array<SpeciesImagesFlowerInner>;
    /**
     * Image(s) of the species leaf
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'leaf'?: Array<SpeciesImagesFlowerInner>;
    /**
     * Image(s) of the species habit
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'habit'?: Array<SpeciesImagesFlowerInner>;
    /**
     * Image(s) of the species fruit
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'fruit'?: Array<SpeciesImagesFlowerInner>;
    /**
     * Image(s) of the species bark
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'bark'?: Array<SpeciesImagesFlowerInner>;
    /**
     * Image(s) of the species other 
     * @type {Array<SpeciesImagesFlowerInner>}
     * @memberof SpeciesImages
     */
    'other'?: Array<SpeciesImagesFlowerInner>;
}
/**
 * 
 * @export
 * @interface SpeciesImagesFlowerInner
 */
export interface SpeciesImagesFlowerInner {
    /**
     * An unique identifier
     * @type {number}
     * @memberof SpeciesImagesFlowerInner
     */
    'id'?: number;
    /**
     * The url of the image
     * @type {string}
     * @memberof SpeciesImagesFlowerInner
     */
    'image_url'?: string;
    /**
     * A copyright (if any) for the image. Don\'t forget to properly credit the author if you\'re using them
     * @type {string}
     * @memberof SpeciesImagesFlowerInner
     */
    'copyright'?: string | null;
}
/**
 * The symonyms scientific names
 * @export
 * @interface SpeciesLight
 */
export interface SpeciesLight {
    /**
     * An unique identifier
     * @type {number}
     * @memberof SpeciesLight
     */
    'id': number;
    /**
     * The usual common name, in english, of the species (if any).
     * @type {string}
     * @memberof SpeciesLight
     */
    'common_name'?: string | null;
    /**
     * An unique human-readable identifier (if you can, prefer to use this over id)
     * @type {string}
     * @memberof SpeciesLight
     */
    'slug': string;
    /**
     * The scientific name follows the [Binomial nomenclature](https://en.wikipedia.org/wiki/Binomial_nomenclature), and represents its genus and its species within the genus, resulting in a single worldwide name for each organism. The scientific name of an infraspecific taxons (ranks below species, such as subspecies, forms, varieties...) is a combination of the name of a species and an infraspecific epithet. A connecting term is used to denote the rank. [See IAPT recommendation](https://www.iapt-taxon.org/nomen/pages/main/art_24.html)
     * @type {string}
     * @memberof SpeciesLight
     */
    'scientific_name': string;
    /**
     * The first publication year of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {number}
     * @memberof SpeciesLight
     */
    'year'?: number | null;
    /**
     * The first publication of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {string}
     * @memberof SpeciesLight
     */
    'bibliography'?: string | null;
    /**
     * The author(s) of the first publication of a valid name of this species. [See author citation](https://en.wikipedia.org/wiki/Author_citation_(botany))
     * @type {string}
     * @memberof SpeciesLight
     */
    'author'?: string | null;
    /**
     * The acceptance status of this species by IPNI
     * @type {string}
     * @memberof SpeciesLight
     */
    'status': SpeciesLightStatusEnum;
    /**
     * The [taxonomic rank](https://en.wikipedia.org/wiki/Taxonomic_rank) of the species
     * @type {string}
     * @memberof SpeciesLight
     */
    'rank': SpeciesLightRankEnum;
    /**
     * The common name (in english) of the species family
     * @type {string}
     * @memberof SpeciesLight
     */
    'family_common_name'?: string | null;
    /**
     * The scientific name of the species family
     * @type {string}
     * @memberof SpeciesLight
     */
    'family': string;
    /**
     * The id of the species genus
     * @type {number}
     * @memberof SpeciesLight
     */
    'genus_id': number;
    /**
     * The scientific name of the species genus
     * @type {string}
     * @memberof SpeciesLight
     */
    'genus': string;
    /**
     * A main image url of the species
     * @type {string}
     * @memberof SpeciesLight
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {SpeciesLinks}
     * @memberof SpeciesLight
     */
    'links': SpeciesLinks;
    /**
     * The symonyms scientific names
     * @type {Array<string>}
     * @memberof SpeciesLight
     */
    'synonyms'?: Array<string>;
}

export const SpeciesLightStatusEnum = {
    Accepted: 'accepted',
    Unknown: 'unknown'
} as const;

export type SpeciesLightStatusEnum = typeof SpeciesLightStatusEnum[keyof typeof SpeciesLightStatusEnum];
export const SpeciesLightRankEnum = {
    Species: 'species',
    Ssp: 'ssp',
    Var: 'var',
    Form: 'form',
    Hybrid: 'hybrid',
    Subvar: 'subvar'
} as const;

export type SpeciesLightRankEnum = typeof SpeciesLightRankEnum[keyof typeof SpeciesLightRankEnum];

/**
 * API endpoints to related resources
 * @export
 * @interface SpeciesLinks
 */
export interface SpeciesLinks {
    /**
     * API endpoint to the species itself
     * @type {string}
     * @memberof SpeciesLinks
     */
    'self': string;
    /**
     * API endpoint to the species genus
     * @type {string}
     * @memberof SpeciesLinks
     */
    'genus': string;
    /**
     * API endpoint to the species plant
     * @type {string}
     * @memberof SpeciesLinks
     */
    'plant': string;
}
/**
 * 
 * @export
 * @interface SpeciesSourcesInner
 */
export interface SpeciesSourcesInner {
    /**
     * An unique identifier from the source
     * @type {string}
     * @memberof SpeciesSourcesInner
     */
    'id'?: string;
    /**
     * The name of the source
     * @type {string}
     * @memberof SpeciesSourcesInner
     */
    'name'?: string;
    /**
     * How to cite the source
     * @type {string}
     * @memberof SpeciesSourcesInner
     */
    'citation'?: string | null;
    /**
     * The link on the source website, or the publication reference
     * @type {string}
     * @memberof SpeciesSourcesInner
     */
    'url'?: string | null;
    /**
     * The last time the source was checked
     * @type {string}
     * @memberof SpeciesSourcesInner
     */
    'last_update'?: string;
}
/**
 * Species\'s main characteristics
 * @export
 * @interface SpeciesSpecifications
 */
export interface SpeciesSpecifications {
    /**
     * The ligneous type of the woody plant
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'ligneous_type'?: SpeciesSpecificationsLigneousTypeEnum | null;
    /**
     * The primary growth form on the landscape in relation to soil stabilization on slopes and streamsides? Each plant species is assigned the single growth form that most enhances its ability to stabilize soil
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'growth_form'?: string | null;
    /**
     * The general appearance, growth form, or architecture of the plant
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'growth_habit'?: string | null;
    /**
     * The relative growth speed of the plant
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'growth_rate'?: string | null;
    /**
     * 
     * @type {SpeciesSpecificationsAverageHeight}
     * @memberof SpeciesSpecifications
     */
    'average_height'?: SpeciesSpecificationsAverageHeight;
    /**
     * 
     * @type {SpeciesSpecificationsMaximumHeight}
     * @memberof SpeciesSpecifications
     */
    'maximum_height'?: SpeciesSpecificationsMaximumHeight;
    /**
     * Capability to fix nitrogen in monoculture
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'nitrogen_fixation'?: string | null;
    /**
     * The predominant shape of the species
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'shape_and_orientation'?: string | null;
    /**
     * Relative toxicity of the species for humans or animals
     * @type {string}
     * @memberof SpeciesSpecifications
     */
    'toxicity'?: SpeciesSpecificationsToxicityEnum | null;
}

export const SpeciesSpecificationsLigneousTypeEnum = {
    Liana: 'liana',
    Subshrub: 'subshrub',
    Shrub: 'shrub',
    Tree: 'tree',
    Parasite: 'parasite',
    Null: 'null'
} as const;

export type SpeciesSpecificationsLigneousTypeEnum = typeof SpeciesSpecificationsLigneousTypeEnum[keyof typeof SpeciesSpecificationsLigneousTypeEnum];
export const SpeciesSpecificationsToxicityEnum = {
    None: 'none',
    Low: 'low',
    Medium: 'medium',
    High: 'high',
    Null: 'null'
} as const;

export type SpeciesSpecificationsToxicityEnum = typeof SpeciesSpecificationsToxicityEnum[keyof typeof SpeciesSpecificationsToxicityEnum];

/**
 * The average height of the species, in centimeters
 * @export
 * @interface SpeciesSpecificationsAverageHeight
 */
export interface SpeciesSpecificationsAverageHeight {
    /**
     * The average height of the species, in centimeters
     * @type {number}
     * @memberof SpeciesSpecificationsAverageHeight
     */
    'cm'?: number | null;
}
/**
 * The maximum height of the species, in centimeters
 * @export
 * @interface SpeciesSpecificationsMaximumHeight
 */
export interface SpeciesSpecificationsMaximumHeight {
    /**
     * The maximum height of the species, in centimeters
     * @type {number}
     * @memberof SpeciesSpecificationsMaximumHeight
     */
    'cm'?: number | null;
}
/**
 * 
 * @export
 * @interface SpeciesSynonymsInner
 */
export interface SpeciesSynonymsInner {
    /**
     * An unique identifier
     * @type {number}
     * @memberof SpeciesSynonymsInner
     */
    'id'?: number;
    /**
     * The scientific name of the symonym
     * @type {string}
     * @memberof SpeciesSynonymsInner
     */
    'name'?: string;
    /**
     * The author of the symonym
     * @type {string}
     * @memberof SpeciesSynonymsInner
     */
    'author'?: string | null;
}
/**
 * 
 * @export
 * @interface Subkingdom
 */
export interface Subkingdom {
    /**
     * 
     * @type {number}
     * @memberof Subkingdom
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Subkingdom
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Subkingdom
     */
    'slug': string;
    /**
     * 
     * @type {Kingdom}
     * @memberof Subkingdom
     */
    'kingdom': Kingdom;
    /**
     * 
     * @type {SubkingdomLinks}
     * @memberof Subkingdom
     */
    'links': SubkingdomLinks;
}
/**
 * 
 * @export
 * @interface SubkingdomLinks
 */
export interface SubkingdomLinks {
    /**
     * 
     * @type {string}
     * @memberof SubkingdomLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof SubkingdomLinks
     */
    'kingdom': string;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * 
     * @type {number}
     * @memberof Zone
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'tdwg_code': string;
    /**
     * 
     * @type {number}
     * @memberof Zone
     */
    'tdwg_level': number;
    /**
     * 
     * @type {number}
     * @memberof Zone
     */
    'species_count': number;
    /**
     * 
     * @type {ZoneLinks}
     * @memberof Zone
     */
    'links': ZoneLinks;
    /**
     * 
     * @type {ZoneParent}
     * @memberof Zone
     */
    'parent'?: ZoneParent | null;
    /**
     * 
     * @type {Array<ZoneChildrenInner>}
     * @memberof Zone
     */
    'children'?: Array<ZoneChildrenInner>;
}
/**
 * 
 * @export
 * @interface ZoneChildrenInner
 */
export interface ZoneChildrenInner {
    /**
     * 
     * @type {number}
     * @memberof ZoneChildrenInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ZoneChildrenInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneChildrenInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneChildrenInner
     */
    'tdwg_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ZoneChildrenInner
     */
    'tdwg_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof ZoneChildrenInner
     */
    'species_count'?: number;
    /**
     * 
     * @type {ZoneLinks}
     * @memberof ZoneChildrenInner
     */
    'links'?: ZoneLinks;
}
/**
 * 
 * @export
 * @interface ZoneLinks
 */
export interface ZoneLinks {
    /**
     * 
     * @type {string}
     * @memberof ZoneLinks
     */
    'self': string;
    /**
     * 
     * @type {string}
     * @memberof ZoneLinks
     */
    'plants': string;
    /**
     * 
     * @type {string}
     * @memberof ZoneLinks
     */
    'species': string;
}
/**
 * 
 * @export
 * @interface ZoneParent
 */
export interface ZoneParent {
    /**
     * 
     * @type {number}
     * @memberof ZoneParent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ZoneParent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneParent
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneParent
     */
    'tdwg_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ZoneParent
     */
    'tdwg_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof ZoneParent
     */
    'species_count'?: number;
    /**
     * 
     * @type {ZoneLinks}
     * @memberof ZoneParent
     */
    'links'?: ZoneLinks;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you need to perform client-side requests, you will have to request a client-side token from you backend, and get a JWT token from this API call in return. This token will be usable on the client side. This call need your secret access token, the url of the website the client side requests will come from and optionally the client IP address. 
         * @summary Request a client-side token
         * @param {ClaimClientSideTokenRequest} [claimClientSideTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimClientSideToken: async (claimClientSideTokenRequest?: ClaimClientSideTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimClientSideTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * If you need to perform client-side requests, you will have to request a client-side token from you backend, and get a JWT token from this API call in return. This token will be usable on the client side. This call need your secret access token, the url of the website the client side requests will come from and optionally the client IP address. 
         * @summary Request a client-side token
         * @param {ClaimClientSideTokenRequest} [claimClientSideTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimClientSideToken(claimClientSideTokenRequest?: ClaimClientSideTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimClientSideToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimClientSideToken(claimClientSideTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.claimClientSideToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * If you need to perform client-side requests, you will have to request a client-side token from you backend, and get a JWT token from this API call in return. This token will be usable on the client side. This call need your secret access token, the url of the website the client side requests will come from and optionally the client IP address. 
         * @summary Request a client-side token
         * @param {ClaimClientSideTokenRequest} [claimClientSideTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimClientSideToken(claimClientSideTokenRequest?: ClaimClientSideTokenRequest, options?: any): AxiosPromise<ClaimClientSideToken200Response> {
            return localVarFp.claimClientSideToken(claimClientSideTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * If you need to perform client-side requests, you will have to request a client-side token from you backend, and get a JWT token from this API call in return. This token will be usable on the client side. This call need your secret access token, the url of the website the client side requests will come from and optionally the client IP address. 
     * @summary Request a client-side token
     * @param {ClaimClientSideTokenRequest} [claimClientSideTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public claimClientSideToken(claimClientSideTokenRequest?: ClaimClientSideTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).claimClientSideToken(claimClientSideTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CorrectionsApi - axios parameter creator
 * @export
 */
export const CorrectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit a new correction for the given species, that will be reviewed and merged into the database. See [Complete our data](/docs/advanced/complete-data) to get started.
         * @summary Submit a correction
         * @param {string} recordId The id or the slug of the requested correction
         * @param {RequestBodyCorrection} [requestBodyCorrection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCorrection: async (recordId: string, requestBodyCorrection?: RequestBodyCorrection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('createCorrection', 'recordId', recordId)
            const localVarPath = `/api/v1/corrections/species/{record_id}`
                .replace(`{${"record_id"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBodyCorrection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a correction
         * @summary Retrieve a correction
         * @param {string} id The id of the requested correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCorrection', 'id', id)
            const localVarPath = `/api/v1/corrections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List corrections
         * @summary Searches corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCorrections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/corrections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorrectionsApi - functional programming interface
 * @export
 */
export const CorrectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CorrectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit a new correction for the given species, that will be reviewed and merged into the database. See [Complete our data](/docs/advanced/complete-data) to get started.
         * @summary Submit a correction
         * @param {string} recordId The id or the slug of the requested correction
         * @param {RequestBodyCorrection} [requestBodyCorrection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCorrection(recordId: string, requestBodyCorrection?: RequestBodyCorrection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportPlants201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCorrection(recordId, requestBodyCorrection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrectionsApi.createCorrection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a correction
         * @summary Retrieve a correction
         * @param {string} id The id of the requested correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorrection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportPlants201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorrection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrectionsApi.getCorrection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List corrections
         * @summary Searches corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCorrections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCorrections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCorrections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrectionsApi.listCorrections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CorrectionsApi - factory interface
 * @export
 */
export const CorrectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CorrectionsApiFp(configuration)
    return {
        /**
         * Submit a new correction for the given species, that will be reviewed and merged into the database. See [Complete our data](/docs/advanced/complete-data) to get started.
         * @summary Submit a correction
         * @param {string} recordId The id or the slug of the requested correction
         * @param {RequestBodyCorrection} [requestBodyCorrection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCorrection(recordId: string, requestBodyCorrection?: RequestBodyCorrection, options?: any): AxiosPromise<ReportPlants201Response> {
            return localVarFp.createCorrection(recordId, requestBodyCorrection, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a correction
         * @summary Retrieve a correction
         * @param {string} id The id of the requested correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrection(id: string, options?: any): AxiosPromise<ReportPlants201Response> {
            return localVarFp.getCorrection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List corrections
         * @summary Searches corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCorrections(options?: any): AxiosPromise<ListCorrections200Response> {
            return localVarFp.listCorrections(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CorrectionsApi - object-oriented interface
 * @export
 * @class CorrectionsApi
 * @extends {BaseAPI}
 */
export class CorrectionsApi extends BaseAPI {
    /**
     * Submit a new correction for the given species, that will be reviewed and merged into the database. See [Complete our data](/docs/advanced/complete-data) to get started.
     * @summary Submit a correction
     * @param {string} recordId The id or the slug of the requested correction
     * @param {RequestBodyCorrection} [requestBodyCorrection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrectionsApi
     */
    public createCorrection(recordId: string, requestBodyCorrection?: RequestBodyCorrection, options?: RawAxiosRequestConfig) {
        return CorrectionsApiFp(this.configuration).createCorrection(recordId, requestBodyCorrection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a correction
     * @summary Retrieve a correction
     * @param {string} id The id of the requested correction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrectionsApi
     */
    public getCorrection(id: string, options?: RawAxiosRequestConfig) {
        return CorrectionsApiFp(this.configuration).getCorrection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List corrections
     * @summary Searches corrections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrectionsApi
     */
    public listCorrections(options?: RawAxiosRequestConfig) {
        return CorrectionsApiFp(this.configuration).listCorrections(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DistributionsApi - axios parameter creator
 * @export
 */
export const DistributionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a zone
         * @summary Retrieve a distribution zone
         * @param {string} id The id or the slug of the requested zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getZone', 'id', id)
            const localVarPath = `/api/v1/distributions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List distributions zones. Zones are following the WGSRPD convention.  WGSRPD provides an agreed system of geographical units at approximately \"country\" level and upwards for use in recording plant distributions. It allows adopting organizations to compare and exchange data with each other without loss of information due to incompatible geographical boundaries.  [Read more on the TDWG website](https://www.tdwg.org/standards/wgsrpd/). 
         * @summary List distributions zones
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDistributions: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/distributions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionsApi - functional programming interface
 * @export
 */
export const DistributionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistributionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a zone
         * @summary Retrieve a distribution zone
         * @param {string} id The id or the slug of the requested zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZone(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetZone200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZone(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DistributionsApi.getZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List distributions zones. Zones are following the WGSRPD convention.  WGSRPD provides an agreed system of geographical units at approximately \"country\" level and upwards for use in recording plant distributions. It allows adopting organizations to compare and exchange data with each other without loss of information due to incompatible geographical boundaries.  [Read more on the TDWG website](https://www.tdwg.org/standards/wgsrpd/). 
         * @summary List distributions zones
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDistributions(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDistributions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDistributions(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DistributionsApi.listDistributions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DistributionsApi - factory interface
 * @export
 */
export const DistributionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistributionsApiFp(configuration)
    return {
        /**
         * Get a zone
         * @summary Retrieve a distribution zone
         * @param {string} id The id or the slug of the requested zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone(id: string, options?: any): AxiosPromise<GetZone200Response> {
            return localVarFp.getZone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List distributions zones. Zones are following the WGSRPD convention.  WGSRPD provides an agreed system of geographical units at approximately \"country\" level and upwards for use in recording plant distributions. It allows adopting organizations to compare and exchange data with each other without loss of information due to incompatible geographical boundaries.  [Read more on the TDWG website](https://www.tdwg.org/standards/wgsrpd/). 
         * @summary List distributions zones
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDistributions(page?: number, options?: any): AxiosPromise<ListDistributions200Response> {
            return localVarFp.listDistributions(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionsApi - object-oriented interface
 * @export
 * @class DistributionsApi
 * @extends {BaseAPI}
 */
export class DistributionsApi extends BaseAPI {
    /**
     * Get a zone
     * @summary Retrieve a distribution zone
     * @param {string} id The id or the slug of the requested zone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsApi
     */
    public getZone(id: string, options?: RawAxiosRequestConfig) {
        return DistributionsApiFp(this.configuration).getZone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List distributions zones. Zones are following the WGSRPD convention.  WGSRPD provides an agreed system of geographical units at approximately \"country\" level and upwards for use in recording plant distributions. It allows adopting organizations to compare and exchange data with each other without loss of information due to incompatible geographical boundaries.  [Read more on the TDWG website](https://www.tdwg.org/standards/wgsrpd/). 
     * @summary List distributions zones
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsApi
     */
    public listDistributions(page?: number, options?: RawAxiosRequestConfig) {
        return DistributionsApiFp(this.configuration).listDistributions(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DivisionClassesApi - axios parameter creator
 * @export
 */
export const DivisionClassesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a division class
         * @summary Retrieve a division class
         * @param {string} id The id or the slug of the requested division class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisionClass: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDivisionClass', 'id', id)
            const localVarPath = `/api/v1/division_classes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List division classes
         * @summary Searches division classes
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisionClasses: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/division_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionClassesApi - functional programming interface
 * @export
 */
export const DivisionClassesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionClassesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a division class
         * @summary Retrieve a division class
         * @param {string} id The id or the slug of the requested division class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivisionClass(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDivisionClass200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivisionClass(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionClassesApi.getDivisionClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List division classes
         * @summary Searches division classes
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDivisionClasses(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDivisionClasses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDivisionClasses(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionClassesApi.listDivisionClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DivisionClassesApi - factory interface
 * @export
 */
export const DivisionClassesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionClassesApiFp(configuration)
    return {
        /**
         * Get a division class
         * @summary Retrieve a division class
         * @param {string} id The id or the slug of the requested division class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisionClass(id: string, options?: any): AxiosPromise<GetDivisionClass200Response> {
            return localVarFp.getDivisionClass(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List division classes
         * @summary Searches division classes
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisionClasses(page?: number, options?: any): AxiosPromise<ListDivisionClasses200Response> {
            return localVarFp.listDivisionClasses(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DivisionClassesApi - object-oriented interface
 * @export
 * @class DivisionClassesApi
 * @extends {BaseAPI}
 */
export class DivisionClassesApi extends BaseAPI {
    /**
     * Get a division class
     * @summary Retrieve a division class
     * @param {string} id The id or the slug of the requested division class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionClassesApi
     */
    public getDivisionClass(id: string, options?: RawAxiosRequestConfig) {
        return DivisionClassesApiFp(this.configuration).getDivisionClass(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List division classes
     * @summary Searches division classes
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionClassesApi
     */
    public listDivisionClasses(page?: number, options?: RawAxiosRequestConfig) {
        return DivisionClassesApiFp(this.configuration).listDivisionClasses(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DivisionOrdersApi - axios parameter creator
 * @export
 */
export const DivisionOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a division order
         * @summary Retrieve a division order
         * @param {string} id The id or the slug of the requested division order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisionOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDivisionOrder', 'id', id)
            const localVarPath = `/api/v1/division_orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List division orders
         * @summary Searches division orders
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisionOrders: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/division_orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionOrdersApi - functional programming interface
 * @export
 */
export const DivisionOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a division order
         * @summary Retrieve a division order
         * @param {string} id The id or the slug of the requested division order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivisionOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDivisionOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivisionOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionOrdersApi.getDivisionOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List division orders
         * @summary Searches division orders
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDivisionOrders(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDivisionOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDivisionOrders(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionOrdersApi.listDivisionOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DivisionOrdersApi - factory interface
 * @export
 */
export const DivisionOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionOrdersApiFp(configuration)
    return {
        /**
         * Get a division order
         * @summary Retrieve a division order
         * @param {string} id The id or the slug of the requested division order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivisionOrder(id: string, options?: any): AxiosPromise<GetDivisionOrder200Response> {
            return localVarFp.getDivisionOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List division orders
         * @summary Searches division orders
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisionOrders(page?: number, options?: any): AxiosPromise<ListDivisionOrders200Response> {
            return localVarFp.listDivisionOrders(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DivisionOrdersApi - object-oriented interface
 * @export
 * @class DivisionOrdersApi
 * @extends {BaseAPI}
 */
export class DivisionOrdersApi extends BaseAPI {
    /**
     * Get a division order
     * @summary Retrieve a division order
     * @param {string} id The id or the slug of the requested division order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionOrdersApi
     */
    public getDivisionOrder(id: string, options?: RawAxiosRequestConfig) {
        return DivisionOrdersApiFp(this.configuration).getDivisionOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List division orders
     * @summary Searches division orders
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionOrdersApi
     */
    public listDivisionOrders(page?: number, options?: RawAxiosRequestConfig) {
        return DivisionOrdersApiFp(this.configuration).listDivisionOrders(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DivisionsApi - axios parameter creator
 * @export
 */
export const DivisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a division
         * @summary Retrieve a division
         * @param {string} id The id or the slug of the requested division
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivision: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDivision', 'id', id)
            const localVarPath = `/api/v1/divisions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List divisions
         * @summary Searches divisions
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisions: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/divisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionsApi - functional programming interface
 * @export
 */
export const DivisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a division
         * @summary Retrieve a division
         * @param {string} id The id or the slug of the requested division
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivision(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDivision200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivision(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionsApi.getDivision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List divisions
         * @summary Searches divisions
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDivisions(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDivisions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDivisions(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DivisionsApi.listDivisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DivisionsApi - factory interface
 * @export
 */
export const DivisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionsApiFp(configuration)
    return {
        /**
         * Get a division
         * @summary Retrieve a division
         * @param {string} id The id or the slug of the requested division
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivision(id: string, options?: any): AxiosPromise<GetDivision200Response> {
            return localVarFp.getDivision(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List divisions
         * @summary Searches divisions
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDivisions(page?: number, options?: any): AxiosPromise<ListDivisions200Response> {
            return localVarFp.listDivisions(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DivisionsApi - object-oriented interface
 * @export
 * @class DivisionsApi
 * @extends {BaseAPI}
 */
export class DivisionsApi extends BaseAPI {
    /**
     * Get a division
     * @summary Retrieve a division
     * @param {string} id The id or the slug of the requested division
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public getDivision(id: string, options?: RawAxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).getDivision(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List divisions
     * @summary Searches divisions
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public listDivisions(page?: number, options?: RawAxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).listDivisions(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FamiliesApi - axios parameter creator
 * @export
 */
export const FamiliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a family
         * @summary Retrieve a family
         * @param {string} id The id or the slug of the requested family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFamily: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFamily', 'id', id)
            const localVarPath = `/api/v1/families/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List families
         * @summary Searches families
         * @param {number} [page] The page to fetch
         * @param {FiltersFamilies} [filter] Filter on values
         * @param {SortsFamilies} [order] Sort on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFamilies: async (page?: number, filter?: FiltersFamilies, order?: SortsFamilies, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/families`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FamiliesApi - functional programming interface
 * @export
 */
export const FamiliesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FamiliesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a family
         * @summary Retrieve a family
         * @param {string} id The id or the slug of the requested family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFamily(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFamily200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFamily(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FamiliesApi.getFamily']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List families
         * @summary Searches families
         * @param {number} [page] The page to fetch
         * @param {FiltersFamilies} [filter] Filter on values
         * @param {SortsFamilies} [order] Sort on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFamilies(page?: number, filter?: FiltersFamilies, order?: SortsFamilies, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFamilies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFamilies(page, filter, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FamiliesApi.listFamilies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FamiliesApi - factory interface
 * @export
 */
export const FamiliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FamiliesApiFp(configuration)
    return {
        /**
         * Get a family
         * @summary Retrieve a family
         * @param {string} id The id or the slug of the requested family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFamily(id: string, options?: any): AxiosPromise<GetFamily200Response> {
            return localVarFp.getFamily(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List families
         * @summary Searches families
         * @param {number} [page] The page to fetch
         * @param {FiltersFamilies} [filter] Filter on values
         * @param {SortsFamilies} [order] Sort on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFamilies(page?: number, filter?: FiltersFamilies, order?: SortsFamilies, options?: any): AxiosPromise<ListFamilies200Response> {
            return localVarFp.listFamilies(page, filter, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FamiliesApi - object-oriented interface
 * @export
 * @class FamiliesApi
 * @extends {BaseAPI}
 */
export class FamiliesApi extends BaseAPI {
    /**
     * Get a family
     * @summary Retrieve a family
     * @param {string} id The id or the slug of the requested family
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FamiliesApi
     */
    public getFamily(id: string, options?: RawAxiosRequestConfig) {
        return FamiliesApiFp(this.configuration).getFamily(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List families
     * @summary Searches families
     * @param {number} [page] The page to fetch
     * @param {FiltersFamilies} [filter] Filter on values
     * @param {SortsFamilies} [order] Sort on values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FamiliesApi
     */
    public listFamilies(page?: number, filter?: FiltersFamilies, order?: SortsFamilies, options?: RawAxiosRequestConfig) {
        return FamiliesApiFp(this.configuration).listFamilies(page, filter, order, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenusApi - axios parameter creator
 * @export
 */
export const GenusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a genus
         * @summary Retrieve a genus
         * @param {string} id The id or the slug of the requested genus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGenus', 'id', id)
            const localVarPath = `/api/v1/genus/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List genus
         * @summary Searches genus
         * @param {FiltersGenus} [filter] Filter on values
         * @param {SortsGenus} [order] Sort on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenus: async (filter?: FiltersGenus, order?: SortsGenus, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/genus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenusApi - functional programming interface
 * @export
 */
export const GenusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenusApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a genus
         * @summary Retrieve a genus
         * @param {string} id The id or the slug of the requested genus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGenus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenusApi.getGenus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List genus
         * @summary Searches genus
         * @param {FiltersGenus} [filter] Filter on values
         * @param {SortsGenus} [order] Sort on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGenus(filter?: FiltersGenus, order?: SortsGenus, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGenus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGenus(filter, order, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenusApi.listGenus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenusApi - factory interface
 * @export
 */
export const GenusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenusApiFp(configuration)
    return {
        /**
         * Get a genus
         * @summary Retrieve a genus
         * @param {string} id The id or the slug of the requested genus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenus(id: string, options?: any): AxiosPromise<GetGenus200Response> {
            return localVarFp.getGenus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List genus
         * @summary Searches genus
         * @param {FiltersGenus} [filter] Filter on values
         * @param {SortsGenus} [order] Sort on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenus(filter?: FiltersGenus, order?: SortsGenus, page?: number, options?: any): AxiosPromise<ListGenus200Response> {
            return localVarFp.listGenus(filter, order, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenusApi - object-oriented interface
 * @export
 * @class GenusApi
 * @extends {BaseAPI}
 */
export class GenusApi extends BaseAPI {
    /**
     * Get a genus
     * @summary Retrieve a genus
     * @param {string} id The id or the slug of the requested genus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenusApi
     */
    public getGenus(id: string, options?: RawAxiosRequestConfig) {
        return GenusApiFp(this.configuration).getGenus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List genus
     * @summary Searches genus
     * @param {FiltersGenus} [filter] Filter on values
     * @param {SortsGenus} [order] Sort on values
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenusApi
     */
    public listGenus(filter?: FiltersGenus, order?: SortsGenus, page?: number, options?: RawAxiosRequestConfig) {
        return GenusApiFp(this.configuration).listGenus(filter, order, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KingdomsApi - axios parameter creator
 * @export
 */
export const KingdomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a kingdom
         * @summary Retrieve a kingdom
         * @param {string} id The id or the slug of the requested kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKingdom: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKingdom', 'id', id)
            const localVarPath = `/api/v1/kingdoms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List kingdoms
         * @summary Searches kingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKingdoms: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/kingdoms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KingdomsApi - functional programming interface
 * @export
 */
export const KingdomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KingdomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a kingdom
         * @summary Retrieve a kingdom
         * @param {string} id The id or the slug of the requested kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKingdom(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKingdom200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKingdom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KingdomsApi.getKingdom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List kingdoms
         * @summary Searches kingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKingdoms(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListKingdoms200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKingdoms(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KingdomsApi.listKingdoms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KingdomsApi - factory interface
 * @export
 */
export const KingdomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KingdomsApiFp(configuration)
    return {
        /**
         * Get a kingdom
         * @summary Retrieve a kingdom
         * @param {string} id The id or the slug of the requested kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKingdom(id: string, options?: any): AxiosPromise<GetKingdom200Response> {
            return localVarFp.getKingdom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List kingdoms
         * @summary Searches kingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKingdoms(page?: number, options?: any): AxiosPromise<ListKingdoms200Response> {
            return localVarFp.listKingdoms(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KingdomsApi - object-oriented interface
 * @export
 * @class KingdomsApi
 * @extends {BaseAPI}
 */
export class KingdomsApi extends BaseAPI {
    /**
     * Get a kingdom
     * @summary Retrieve a kingdom
     * @param {string} id The id or the slug of the requested kingdom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KingdomsApi
     */
    public getKingdom(id: string, options?: RawAxiosRequestConfig) {
        return KingdomsApiFp(this.configuration).getKingdom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List kingdoms
     * @summary Searches kingdoms
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KingdomsApi
     */
    public listKingdoms(page?: number, options?: RawAxiosRequestConfig) {
        return KingdomsApiFp(this.configuration).listKingdoms(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlantsApi - axios parameter creator
 * @export
 */
export const PlantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a plant
         * @summary Retrieve a plant
         * @param {string} id The id or the slug of the requested plant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlant: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlant', 'id', id)
            const localVarPath = `/api/v1/plants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List plants
         * @summary List plants
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlants: async (filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List plants of the requested genus
         * @summary List plants of a genus
         * @param {string} genusId The genus id or slug
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlantsGenus: async (genusId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genusId' is not null or undefined
            assertParamExists('listPlantsGenus', 'genusId', genusId)
            const localVarPath = `/api/v1/genus/{genus_id}/plants`
                .replace(`{${"genus_id"}}`, encodeURIComponent(String(genusId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the plants in the requested zone.
         * @summary List plants in a distribution zone
         * @param {string} zoneId The zone id or twdg code
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlantsZone: async (zoneId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('listPlantsZone', 'zoneId', zoneId)
            const localVarPath = `/api/v1/distributions/{zone_id}/plants`
                .replace(`{${"zone_id"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A short API call to report an error regarding a plant entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlants: async (id: string, reportPlantsRequest?: ReportPlantsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportPlants', 'id', id)
            const localVarPath = `/api/v1/plants/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportPlantsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a plant with the given scientific name, common name, synonym name etc.
         * @summary Search for a plant
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersPlants} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsPlants} [order] Sort on values
         * @param {RangesPlants} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlants: async (q: string, page?: number, filter?: FiltersPlants, filterNot?: FiltersNotSpecies, order?: SortsPlants, range?: RangesPlants, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchPlants', 'q', q)
            const localVarPath = `/api/v1/plants/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlantsApi - functional programming interface
 * @export
 */
export const PlantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a plant
         * @summary Retrieve a plant
         * @param {string} id The id or the slug of the requested plant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlant(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.getPlant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List plants
         * @summary List plants
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlants(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlants(filter, filterNot, order, range, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.listPlants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List plants of the requested genus
         * @summary List plants of a genus
         * @param {string} genusId The genus id or slug
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlantsGenus(genusId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlantsGenus(genusId, filter, filterNot, order, range, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.listPlantsGenus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the plants in the requested zone.
         * @summary List plants in a distribution zone
         * @param {string} zoneId The zone id or twdg code
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlantsZone(zoneId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlantsZone(zoneId, filter, filterNot, order, range, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.listPlantsZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A short API call to report an error regarding a plant entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlants(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportPlants201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportPlants(id, reportPlantsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.reportPlants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for a plant with the given scientific name, common name, synonym name etc.
         * @summary Search for a plant
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersPlants} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsPlants} [order] Sort on values
         * @param {RangesPlants} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlants(q: string, page?: number, filter?: FiltersPlants, filterNot?: FiltersNotSpecies, order?: SortsPlants, range?: RangesPlants, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlants(q, page, filter, filterNot, order, range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlantsApi.searchPlants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlantsApi - factory interface
 * @export
 */
export const PlantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlantsApiFp(configuration)
    return {
        /**
         * Get a plant
         * @summary Retrieve a plant
         * @param {string} id The id or the slug of the requested plant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlant(id: string, options?: any): AxiosPromise<GetPlant200Response> {
            return localVarFp.getPlant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List plants
         * @summary List plants
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlants(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.listPlants(filter, filterNot, order, range, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List plants of the requested genus
         * @summary List plants of a genus
         * @param {string} genusId The genus id or slug
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlantsGenus(genusId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.listPlantsGenus(genusId, filter, filterNot, order, range, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the plants in the requested zone.
         * @summary List plants in a distribution zone
         * @param {string} zoneId The zone id or twdg code
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlantsZone(zoneId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.listPlantsZone(zoneId, filter, filterNot, order, range, page, options).then((request) => request(axios, basePath));
        },
        /**
         * A short API call to report an error regarding a plant entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlants(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: any): AxiosPromise<ReportPlants201Response> {
            return localVarFp.reportPlants(id, reportPlantsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for a plant with the given scientific name, common name, synonym name etc.
         * @summary Search for a plant
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersPlants} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsPlants} [order] Sort on values
         * @param {RangesPlants} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlants(q: string, page?: number, filter?: FiltersPlants, filterNot?: FiltersNotSpecies, order?: SortsPlants, range?: RangesPlants, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.searchPlants(q, page, filter, filterNot, order, range, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlantsApi - object-oriented interface
 * @export
 * @class PlantsApi
 * @extends {BaseAPI}
 */
export class PlantsApi extends BaseAPI {
    /**
     * Get a plant
     * @summary Retrieve a plant
     * @param {string} id The id or the slug of the requested plant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public getPlant(id: string, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).getPlant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List plants
     * @summary List plants
     * @param {FiltersSpecies} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsSpecies} [order] Sort on values
     * @param {RangesSpecies} [range] Range on values
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public listPlants(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).listPlants(filter, filterNot, order, range, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List plants of the requested genus
     * @summary List plants of a genus
     * @param {string} genusId The genus id or slug
     * @param {FiltersSpecies} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsSpecies} [order] Sort on values
     * @param {RangesSpecies} [range] Range on values
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public listPlantsGenus(genusId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).listPlantsGenus(genusId, filter, filterNot, order, range, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the plants in the requested zone.
     * @summary List plants in a distribution zone
     * @param {string} zoneId The zone id or twdg code
     * @param {FiltersSpecies} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsSpecies} [order] Sort on values
     * @param {RangesSpecies} [range] Range on values
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public listPlantsZone(zoneId: string, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).listPlantsZone(zoneId, filter, filterNot, order, range, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A short API call to report an error regarding a plant entry
     * @summary Report an error
     * @param {string} id The id or the slug of the requested species
     * @param {ReportPlantsRequest} [reportPlantsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public reportPlants(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).reportPlants(id, reportPlantsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for a plant with the given scientific name, common name, synonym name etc.
     * @summary Search for a plant
     * @param {string} q The string to search
     * @param {number} [page] The page to fetch
     * @param {FiltersPlants} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsPlants} [order] Sort on values
     * @param {RangesPlants} [range] Range on values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlantsApi
     */
    public searchPlants(q: string, page?: number, filter?: FiltersPlants, filterNot?: FiltersNotSpecies, order?: SortsPlants, range?: RangesPlants, options?: RawAxiosRequestConfig) {
        return PlantsApiFp(this.configuration).searchPlants(q, page, filter, filterNot, order, range, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpeciesApi - axios parameter creator
 * @export
 */
export const SpeciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a species
         * @summary Retrieve a species
         * @param {string} id The id or the slug of the requested species
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecies: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpecies', 'id', id)
            const localVarPath = `/api/v1/species/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List species
         * @summary List species
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecies: async (filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/species`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A short API call to report an error regarding a species entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSpecies: async (id: string, reportPlantsRequest?: ReportPlantsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportSpecies', 'id', id)
            const localVarPath = `/api/v1/species/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportPlantsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a species with the given scientific name, common name, synonym name etc.
         * @summary Search for a species
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSpecies: async (q: string, page?: number, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchSpecies', 'q', q)
            const localVarPath = `/api/v1/species/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (filter !== undefined) {
                for (const [key, value] of Object.entries(filter)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (filterNot !== undefined) {
                for (const [key, value] of Object.entries(filterNot)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (order !== undefined) {
                for (const [key, value] of Object.entries(order)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (range !== undefined) {
                for (const [key, value] of Object.entries(range)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpeciesApi - functional programming interface
 * @export
 */
export const SpeciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpeciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a species
         * @summary Retrieve a species
         * @param {string} id The id or the slug of the requested species
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecies(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSpecies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecies(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpeciesApi.getSpecies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List species
         * @summary List species
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpecies(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpecies(filter, filterNot, order, range, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpeciesApi.listSpecies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A short API call to report an error regarding a species entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSpecies(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportPlants201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportSpecies(id, reportPlantsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpeciesApi.reportSpecies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for a species with the given scientific name, common name, synonym name etc.
         * @summary Search for a species
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSpecies(q: string, page?: number, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSpecies(q, page, filter, filterNot, order, range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpeciesApi.searchSpecies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpeciesApi - factory interface
 * @export
 */
export const SpeciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpeciesApiFp(configuration)
    return {
        /**
         * Get a species
         * @summary Retrieve a species
         * @param {string} id The id or the slug of the requested species
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecies(id: string, options?: any): AxiosPromise<GetSpecies200Response> {
            return localVarFp.getSpecies(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List species
         * @summary List species
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpecies(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.listSpecies(filter, filterNot, order, range, page, options).then((request) => request(axios, basePath));
        },
        /**
         * A short API call to report an error regarding a species entry
         * @summary Report an error
         * @param {string} id The id or the slug of the requested species
         * @param {ReportPlantsRequest} [reportPlantsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSpecies(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: any): AxiosPromise<ReportPlants201Response> {
            return localVarFp.reportSpecies(id, reportPlantsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for a species with the given scientific name, common name, synonym name etc.
         * @summary Search for a species
         * @param {string} q The string to search
         * @param {number} [page] The page to fetch
         * @param {FiltersSpecies} [filter] Filter on values
         * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
         * @param {SortsSpecies} [order] Sort on values
         * @param {RangesSpecies} [range] Range on values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSpecies(q: string, page?: number, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, options?: any): AxiosPromise<ListPlants200Response> {
            return localVarFp.searchSpecies(q, page, filter, filterNot, order, range, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpeciesApi - object-oriented interface
 * @export
 * @class SpeciesApi
 * @extends {BaseAPI}
 */
export class SpeciesApi extends BaseAPI {
    /**
     * Get a species
     * @summary Retrieve a species
     * @param {string} id The id or the slug of the requested species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeciesApi
     */
    public getSpecies(id: string, options?: RawAxiosRequestConfig) {
        return SpeciesApiFp(this.configuration).getSpecies(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List species
     * @summary List species
     * @param {FiltersSpecies} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsSpecies} [order] Sort on values
     * @param {RangesSpecies} [range] Range on values
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeciesApi
     */
    public listSpecies(filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, page?: number, options?: RawAxiosRequestConfig) {
        return SpeciesApiFp(this.configuration).listSpecies(filter, filterNot, order, range, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A short API call to report an error regarding a species entry
     * @summary Report an error
     * @param {string} id The id or the slug of the requested species
     * @param {ReportPlantsRequest} [reportPlantsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeciesApi
     */
    public reportSpecies(id: string, reportPlantsRequest?: ReportPlantsRequest, options?: RawAxiosRequestConfig) {
        return SpeciesApiFp(this.configuration).reportSpecies(id, reportPlantsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for a species with the given scientific name, common name, synonym name etc.
     * @summary Search for a species
     * @param {string} q The string to search
     * @param {number} [page] The page to fetch
     * @param {FiltersSpecies} [filter] Filter on values
     * @param {FiltersNotSpecies} [filterNot] Exclude results matching null values
     * @param {SortsSpecies} [order] Sort on values
     * @param {RangesSpecies} [range] Range on values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeciesApi
     */
    public searchSpecies(q: string, page?: number, filter?: FiltersSpecies, filterNot?: FiltersNotSpecies, order?: SortsSpecies, range?: RangesSpecies, options?: RawAxiosRequestConfig) {
        return SpeciesApiFp(this.configuration).searchSpecies(q, page, filter, filterNot, order, range, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubkingdomsApi - axios parameter creator
 * @export
 */
export const SubkingdomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a subkingdom
         * @summary Retrieve a subkingdom
         * @param {string} id The id or the slug of the requested sub-kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubkingdom: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubkingdom', 'id', id)
            const localVarPath = `/api/v1/subkingdoms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List subkingdoms
         * @summary Searches subkingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubkingdoms: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/subkingdoms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubkingdomsApi - functional programming interface
 * @export
 */
export const SubkingdomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubkingdomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a subkingdom
         * @summary Retrieve a subkingdom
         * @param {string} id The id or the slug of the requested sub-kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubkingdom(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubkingdom200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubkingdom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubkingdomsApi.getSubkingdom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List subkingdoms
         * @summary Searches subkingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubkingdoms(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSubkingdoms200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubkingdoms(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubkingdomsApi.listSubkingdoms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubkingdomsApi - factory interface
 * @export
 */
export const SubkingdomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubkingdomsApiFp(configuration)
    return {
        /**
         * Get a subkingdom
         * @summary Retrieve a subkingdom
         * @param {string} id The id or the slug of the requested sub-kingdom
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubkingdom(id: string, options?: any): AxiosPromise<GetSubkingdom200Response> {
            return localVarFp.getSubkingdom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List subkingdoms
         * @summary Searches subkingdoms
         * @param {number} [page] The page to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubkingdoms(page?: number, options?: any): AxiosPromise<ListSubkingdoms200Response> {
            return localVarFp.listSubkingdoms(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubkingdomsApi - object-oriented interface
 * @export
 * @class SubkingdomsApi
 * @extends {BaseAPI}
 */
export class SubkingdomsApi extends BaseAPI {
    /**
     * Get a subkingdom
     * @summary Retrieve a subkingdom
     * @param {string} id The id or the slug of the requested sub-kingdom
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubkingdomsApi
     */
    public getSubkingdom(id: string, options?: RawAxiosRequestConfig) {
        return SubkingdomsApiFp(this.configuration).getSubkingdom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List subkingdoms
     * @summary Searches subkingdoms
     * @param {number} [page] The page to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubkingdomsApi
     */
    public listSubkingdoms(page?: number, options?: RawAxiosRequestConfig) {
        return SubkingdomsApiFp(this.configuration).listSubkingdoms(page, options).then((request) => request(this.axios, this.basePath));
    }
}



