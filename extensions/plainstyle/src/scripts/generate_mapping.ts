import fs from "fs";
import path from "path";

// 型定義
interface LetterSetConfig {
  name: string;
  description: string;
  constantName: string;
  outputName: string;
}

// 文字種の定義
const letterSets: LetterSetConfig[] = [
  {
    name: "Serif Bold",
    description: "Bold serif font style",
    constantName: "SERIF_BOLD",
    outputName: "serif_bold",
  },
  {
    name: "Serif Italic",
    description: "Italic serif font style",
    constantName: "SERIF_ITALIC",
    outputName: "serif_italic",
  },
  {
    name: "Serif Bold Italic",
    description: "Bold italic serif font style",
    constantName: "SERIF_BOLD_ITALIC",
    outputName: "serif_bold_italic",
  },
  {
    name: "Sans Serif",
    description: "Sans serif font style",
    constantName: "SANS_SERIF",
    outputName: "sans_serif",
  },
  {
    name: "Sans Serif Bold",
    description: "Bold sans serif font style",
    constantName: "SANS_SERIF_BOLD",
    outputName: "sans_serif_bold",
  },
  {
    name: "Sans Serif Italic",
    description: "Italic sans serif font style",
    constantName: "SANS_SERIF_ITALIC",
    outputName: "sans_serif_italic",
  },
  {
    name: "Sans Serif Bold Italic",
    description: "Bold italic sans serif font style",
    constantName: "SANS_SERIF_BOLD_ITALIC",
    outputName: "sans_serif_bold_italic",
  },
  {
    name: "Script",
    description: "Script font style",
    constantName: "SCRIPT",
    outputName: "script",
  },
  {
    name: "Script Bold",
    description: "Bold script font style",
    constantName: "SCRIPT_BOLD",
    outputName: "script_bold",
  },
  {
    name: "Monospace",
    description: "Monospace font style",
    constantName: "MONOSPACE",
    outputName: "monospace",
  },
  {
    name: "Fraktur",
    description: "Fraktur font style",
    constantName: "FRAKTUR",
    outputName: "fraktur",
  },
  {
    name: "Double Struck",
    description: "Double struck font style",
    constantName: "DOUBLE_STRUCK",
    outputName: "double_struck",
  },
  {
    name: "Wide",
    description: "Wide font style",
    constantName: "WIDE",
    outputName: "wide",
  },
  {
    name: "Circled White",
    description: "White circled font style",
    constantName: "CIRCLED_WHITE",
    outputName: "circled_white",
  },
  {
    name: "Circled Black",
    description: "Black circled font style",
    constantName: "CIRCLED_BLACK",
    outputName: "circled_black",
  },
  {
    name: "Double Circled",
    description: "Double circled font style",
    constantName: "DOUBLE_CIRCLED",
    outputName: "double_circled",
  },
  {
    name: "Parenthesized",
    description: "Parenthesized font style",
    constantName: "PARENTHESIZED",
    outputName: "parenthesized",
  },
  {
    name: "Squared Black",
    description: "Black squared font style",
    constantName: "SQUARED_BLACK",
    outputName: "squared_black",
  },
  {
    name: "Squared White",
    description: "White squared font style",
    constantName: "SQUARED_WHITE",
    outputName: "squared_white",
  },
];

// 定数
const WORKSPACE_ROOT = process.cwd();
const CONSTANTS_PATH = path.join(WORKSPACE_ROOT, "src/lib/__tests__/cases.ts");
const OUTPUT_DIR = path.join(WORKSPACE_ROOT, "src/lib/sets");

// constants.tsから定義を取得
const constants = fs.readFileSync(CONSTANTS_PATH, "utf8");

// REGULARの文字列を抽出
const regularMatch = constants.match(/export const REGULAR =\s*"([^"]+)"/);
if (!regularMatch) {
  console.error("REGULAR文字列の定義が見つかりませんでした");
  process.exit(1);
}
const regular = regularMatch[1];
const regularChars = [...regular];

// 出力ディレクトリが存在することを確認
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// 各文字種に対してマッピングファイルを生成
for (const letterSet of letterSets) {
  // 文字列を抽出
  const match = constants.match(new RegExp(`export const ${letterSet.constantName} =\\s*"([^"]+)"`));
  if (!match) {
    console.error(`${letterSet.constantName}文字列の定義が見つかりませんでした`);
    continue;
  }

  // マッピングオブジェクトを作成
  const mapping: Record<string, string> = {};
  const chars = [...match[1]];

  for (let i = 0; i < regularChars.length; i++) {
    if (i < chars.length && regularChars[i] !== chars[i]) {
      mapping[regularChars[i]] = chars[i];
    }
  }

  // TypeScriptオブジェクトとして出力
  let tsContent = "// Autogenerated file. Do not edit directly.\n\n";
  tsContent += 'import { LetterSet } from "../../schema";\n\n';
  tsContent += `export const ${letterSet.outputName}: LetterSet = {\n`;
  tsContent += `  name: "${letterSet.name}",\n`;
  tsContent += `  description: "${letterSet.description}",\n`;
  tsContent += "  characters: {\n";
  for (const [key, value] of Object.entries(mapping)) {
    tsContent += `    "${key}": "${value}",\n`;
  }
  tsContent += "  },\n";
  tsContent += "};\n";

  // ファイルに書き出し
  const outputPath = path.join(OUTPUT_DIR, `${letterSet.outputName}.ts`);
  fs.writeFileSync(outputPath, tsContent, "utf8");
  console.log(`マッピングファイルが生成されました: ${path.relative(WORKSPACE_ROOT, outputPath)}`);
}

// インデックスファイルを生成
let indexContent = "// Autogenerated file. Do not edit directly.\n\n";
indexContent += letterSets.map((set) => `export { ${set.outputName} } from "./${set.outputName}";\n`).join("");

const indexPath = path.join(OUTPUT_DIR, "index.ts");
fs.writeFileSync(indexPath, indexContent, "utf8");
console.log(`インデックスファイルが生成されました: ${path.relative(WORKSPACE_ROOT, indexPath)}`);
