{
  "bashFunctions": {
    "_activatePkgs":" \n    local hostOffset targetOffset;\n    local pkg;\n    for hostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local pkgsVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n        for targetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( hostOffset <= targetOffset )) || continue;\n            local pkgsRef=\"${pkgsVar}[$targetOffset - $hostOffset]\";\n            local pkgsSlice=\"${!pkgsRef}[@]\";\n            for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n            do\n                activatePackage \"$pkg\" \"$hostOffset\" \"$targetOffset\";\n            done;\n        done;\n    done\n",
    "_addRpathPrefix":" \n    if [ \"${NIX_NO_SELF_RPATH:-0}\" != 1 ]; then\n        export NIX_LDFLAGS=\"-rpath $1/lib ${NIX_LDFLAGS-}\";\n    fi\n",
    "_addToEnv":" \n    local depHostOffset depTargetOffset;\n    local pkg;\n    for depHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local hookVar=\"${pkgHookVarVars[depHostOffset + 1]}\";\n        local pkgsVar=\"${pkgAccumVarVars[depHostOffset + 1]}\";\n        for depTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( depHostOffset <= depTargetOffset )) || continue;\n            local hookRef=\"${hookVar}[$depTargetOffset - $depHostOffset]\";\n            if [[ -z \"${strictDeps-}\" ]]; then\n                local visitedPkgs=\"\";\n                for pkg in \"${pkgsBuildBuild[@]}\" \"${pkgsBuildHost[@]}\" \"${pkgsBuildTarget[@]}\" \"${pkgsHostHost[@]}\" \"${pkgsHostTarget[@]}\" \"${pkgsTargetTarget[@]}\";\n                do\n                    if [[ \"$visitedPkgs\" = *\"$pkg\"* ]]; then\n                        continue;\n                    fi;\n                    runHook \"${!hookRef}\" \"$pkg\";\n                    visitedPkgs+=\" $pkg\";\n                done;\n            else\n                local pkgsRef=\"${pkgsVar}[$depTargetOffset - $depHostOffset]\";\n                local pkgsSlice=\"${!pkgsRef}[@]\";\n                for pkg in ${!pkgsSlice+\"${!pkgsSlice}\"};\n                do\n                    runHook \"${!hookRef}\" \"$pkg\";\n                done;\n            fi;\n        done;\n    done\n",
    "_allFlags":" \n    export system pname name version;\n    while IFS='' read -r varName; do\n        nixTalkativeLog \"@${varName}@ -> ${!varName}\";\n        args+=(\"--subst-var\" \"$varName\");\n    done < <(awk 'BEGIN { for (v in ENVIRON) if (v ~ /^[a-z][a-zA-Z0-9_]*$/) print v }')\n",
    "_assignFirst":" \n    local varName=\"$1\";\n    local _var;\n    local REMOVE=REMOVE;\n    shift;\n    for _var in \"$@\";\n    do\n        if [ -n \"${!_var-}\" ]; then\n            eval \"${varName}\"=\"${_var}\";\n            return;\n        fi;\n    done;\n    echo;\n    echo \"error: _assignFirst: could not find a non-empty variable whose name to assign to ${varName}.\";\n    echo \"       The following variables were all unset or empty:\";\n    echo \"           $*\";\n    if [ -z \"${out:-}\" ]; then\n        echo '       If you do not want an \"out\" output in your derivation, make sure to define';\n        echo '       the other specific required outputs. This can be achieved by picking one';\n        echo \"       of the above as an output.\";\n        echo '       You do not have to remove \"out\" if you want to have a different default';\n        echo '       output, because the first output is taken as a default.';\n        echo;\n    fi;\n    return 1\n",
    "_callImplicitHook":" \n    local def=\"$1\";\n    local hookName=\"$2\";\n    if declare -F \"$hookName\" > /dev/null; then\n        nixTalkativeLog \"calling implicit '$hookName' function hook\";\n        \"$hookName\";\n    else\n        if type -p \"$hookName\" > /dev/null; then\n            nixTalkativeLog \"sourcing implicit '$hookName' script hook\";\n            source \"$hookName\";\n        else\n            if [ -n \"${!hookName:-}\" ]; then\n                nixTalkativeLog \"evaling implicit '$hookName' string hook\";\n                eval \"${!hookName}\";\n            else\n                return \"$def\";\n            fi;\n        fi;\n    fi\n",
    "_defaultUnpack":" \n    local fn=\"$1\";\n    local destination;\n    if [ -d \"$fn\" ]; then\n        destination=\"$(stripHash \"$fn\")\";\n        if [ -e \"$destination\" ]; then\n            echo \"Cannot copy $fn to $destination: destination already exists!\";\n            echo \"Did you specify two \\\"srcs\\\" with the same \\\"name\\\"?\";\n            return 1;\n        fi;\n        cp -r --preserve=mode,timestamps --reflink=auto -- \"$fn\" \"$destination\";\n    else\n        case \"$fn\" in \n            *.tar.xz | *.tar.lzma | *.txz)\n                ( XZ_OPT=\"--threads=$NIX_BUILD_CORES\" xz -d < \"$fn\";\n                true ) | tar xf - --mode=+w --warning=no-timestamp\n            ;;\n            *.tar | *.tar.* | *.tgz | *.tbz2 | *.tbz)\n                tar xf \"$fn\" --mode=+w --warning=no-timestamp\n            ;;\n            *)\n                return 1\n            ;;\n        esac;\n    fi\n",
    "_doStrip":" \n    local -ra flags=(dontStripHost dontStripTarget);\n    local -ra debugDirs=(stripDebugList stripDebugListTarget);\n    local -ra allDirs=(stripAllList stripAllListTarget);\n    local -ra stripCmds=(STRIP STRIP_FOR_TARGET);\n    local -ra ranlibCmds=(RANLIB RANLIB_FOR_TARGET);\n    stripDebugList=${stripDebugList[*]:-lib lib32 lib64 libexec bin sbin Applications Library/Frameworks};\n    stripDebugListTarget=${stripDebugListTarget[*]:-};\n    stripAllList=${stripAllList[*]:-};\n    stripAllListTarget=${stripAllListTarget[*]:-};\n    local i;\n    for i in ${!stripCmds[@]};\n    do\n        local -n flag=\"${flags[$i]}\";\n        local -n debugDirList=\"${debugDirs[$i]}\";\n        local -n allDirList=\"${allDirs[$i]}\";\n        local -n stripCmd=\"${stripCmds[$i]}\";\n        local -n ranlibCmd=\"${ranlibCmds[$i]}\";\n        if [[ -n \"${dontStrip-}\" || -n \"${flag-}\" ]] || ! type -f \"${stripCmd-}\" 2> /dev/null 1>&2; then\n            continue;\n        fi;\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$debugDirList\" \"${stripDebugFlags[*]:--S -p}\";\n        stripDirs \"$stripCmd\" \"$ranlibCmd\" \"$allDirList\" \"${stripAllFlags[*]:--s -p}\";\n    done\n",
    "_eval":" \n    if declare -F \"$1\" > /dev/null 2>&1; then\n        \"$@\";\n    else\n        eval \"$1\";\n    fi\n",
    "_logHook":" \n    if [[ -z ${NIX_LOG_FD-} ]]; then\n        return;\n    fi;\n    local hookKind=\"$1\";\n    local hookExpr=\"$2\";\n    shift 2;\n    if declare -F \"$hookExpr\" > /dev/null 2>&1; then\n        nixTalkativeLog \"calling '$hookKind' function hook '$hookExpr'\" \"$@\";\n    else\n        if type -p \"$hookExpr\" > /dev/null; then\n            nixTalkativeLog \"sourcing '$hookKind' script hook '$hookExpr'\";\n        else\n            if [[ \"$hookExpr\" != \"_callImplicitHook\"* ]]; then\n                local exprToOutput;\n                if [[ ${NIX_DEBUG:-0} -ge 5 ]]; then\n                    exprToOutput=\"$hookExpr\";\n                else\n                    local hookExprLine;\n                    while IFS= read -r hookExprLine; do\n                        hookExprLine=\"${hookExprLine#\"${hookExprLine%%[![:space:]]*}\"}\";\n                        if [[ -n \"$hookExprLine\" ]]; then\n                            exprToOutput+=\"$hookExprLine\\\\n \";\n                        fi;\n                    done <<< \"$hookExpr\";\n                    exprToOutput=\"${exprToOutput%%\\\\n }\";\n                fi;\n                nixTalkativeLog \"evaling '$hookKind' string hook '$exprToOutput'\";\n            fi;\n        fi;\n    fi\n",
    "_makeSymlinksRelative":" \n    local symlinkTarget;\n    if [ \"${dontRewriteSymlinks-}\" ] || [ ! -e \"$prefix\" ]; then\n        return;\n    fi;\n    while IFS= read -r -d '' f; do\n        symlinkTarget=$(readlink \"$f\");\n        if [[ \"$symlinkTarget\"/ != \"$prefix\"/* ]]; then\n            continue;\n        fi;\n        if [ ! -e \"$symlinkTarget\" ]; then\n            echo \"the symlink $f is broken, it points to $symlinkTarget (which is missing)\";\n        fi;\n        echo \"rewriting symlink $f to be relative to $prefix\";\n        ln -snrf \"$symlinkTarget\" \"$f\";\n    done < <(find $prefix -type l -print0)\n",
    "_makeSymlinksRelativeInAllOutputs":" \n    local output;\n    for output in $(getAllOutputNames);\n    do\n        prefix=\"${!output}\" _makeSymlinksRelative;\n    done\n",
    "_moveLib64":" \n    if [ \"${dontMoveLib64-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/lib64\" -o -L \"$prefix/lib64\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/lib64/* to $prefix/lib\";\n    mkdir -p $prefix/lib;\n    shopt -s dotglob;\n    for i in $prefix/lib64/*;\n    do\n        mv --no-clobber \"$i\" $prefix/lib;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/lib64;\n    ln -s lib $prefix/lib64\n",
    "_moveSbin":" \n    if [ \"${dontMoveSbin-}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"$prefix/sbin\" -o -L \"$prefix/sbin\" ]; then\n        return;\n    fi;\n    echo \"moving $prefix/sbin/* to $prefix/bin\";\n    mkdir -p $prefix/bin;\n    shopt -s dotglob;\n    for i in $prefix/sbin/*;\n    do\n        mv \"$i\" $prefix/bin;\n    done;\n    shopt -u dotglob;\n    rmdir $prefix/sbin;\n    ln -s bin $prefix/sbin\n",
    "_moveSystemdUserUnits":" \n    if [ \"${dontMoveSystemdUserUnits:-0}\" = 1 ]; then\n        return;\n    fi;\n    if [ ! -e \"${prefix:?}/lib/systemd/user\" ]; then\n        return;\n    fi;\n    local source=\"$prefix/lib/systemd/user\";\n    local target=\"$prefix/share/systemd/user\";\n    echo \"moving $source/* to $target\";\n    mkdir -p \"$target\";\n    ( shopt -s dotglob;\n    for i in \"$source\"/*;\n    do\n        mv \"$i\" \"$target\";\n    done );\n    rmdir \"$source\";\n    ln -s \"$target\" \"$source\"\n",
    "_moveToShare":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        if [ -z \"${forceShare-}\" ]; then\n            forceShare=(man doc info);\n        fi;\n    else\n        forceShare=(${forceShare:-man doc info});\n    fi;\n    if [[ -z \"$out\" ]]; then\n        return;\n    fi;\n    for d in \"${forceShare[@]}\";\n    do\n        if [ -d \"$out/$d\" ]; then\n            if [ -d \"$out/share/$d\" ]; then\n                echo \"both $d/ and share/$d/ exist!\";\n            else\n                echo \"moving $out/$d to $out/share/$d\";\n                mkdir -p $out/share;\n                mv $out/$d $out/share/;\n            fi;\n        fi;\n    done\n",
    "_multioutConfig":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${setOutputFlags-1}\" ]; then\n        return;\n    fi;\n    if [ -z \"${shareDocName:-}\" ]; then\n        local confScript=\"${configureScript:-}\";\n        if [ -z \"$confScript\" ] && [ -x ./configure ]; then\n            confScript=./configure;\n        fi;\n        if [ -f \"$confScript\" ]; then\n            local shareDocName=\"$(sed -n \"s/^PACKAGE_TARNAME='\\(.*\\)'$/\\1/p\" < \"$confScript\")\";\n        fi;\n        if [ -z \"$shareDocName\" ] || echo \"$shareDocName\" | grep -q '[^a-zA-Z0-9_-]'; then\n            shareDocName=\"$(echo \"$name\" | sed 's/-[^a-zA-Z].*//')\";\n        fi;\n    fi;\n    prependToVar configureFlags --bindir=\"${!outputBin}\"/bin --sbindir=\"${!outputBin}\"/sbin --includedir=\"${!outputInclude}\"/include --mandir=\"${!outputMan}\"/share/man --infodir=\"${!outputInfo}\"/share/info --docdir=\"${!outputDoc}\"/share/doc/\"${shareDocName}\" --libdir=\"${!outputLib}\"/lib --libexecdir=\"${!outputLib}\"/libexec --localedir=\"${!outputLib}\"/share/locale;\n    prependToVar installFlags pkgconfigdir=\"${!outputDev}\"/lib/pkgconfig m4datadir=\"${!outputDev}\"/share/aclocal aclocaldir=\"${!outputDev}\"/share/aclocal\n",
    "_multioutDevs":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ] || [ -z \"${moveToDev-1}\" ]; then\n        return;\n    fi;\n    moveToOutput include \"${!outputInclude}\";\n    moveToOutput lib/pkgconfig \"${!outputDev}\";\n    moveToOutput share/pkgconfig \"${!outputDev}\";\n    moveToOutput lib/cmake \"${!outputDev}\";\n    moveToOutput share/aclocal \"${!outputDev}\";\n    for f in \"${!outputDev}\"/{lib,share}/pkgconfig/*.pc;\n    do\n        echo \"Patching '$f' includedir to output ${!outputInclude}\";\n        sed -i \"/^includedir=/s,=\\${prefix},=${!outputInclude},\" \"$f\";\n    done\n",
    "_multioutDocs":" \n    local REMOVE=REMOVE;\n    moveToOutput share/info \"${!outputInfo}\";\n    moveToOutput share/doc \"${!outputDoc}\";\n    moveToOutput share/gtk-doc \"${!outputDevdoc}\";\n    moveToOutput share/devhelp/books \"${!outputDevdoc}\";\n    moveToOutput share/man \"${!outputMan}\";\n    moveToOutput share/man/man3 \"${!outputDevman}\"\n",
    "_multioutPropagateDev":" \n    if [ \"$(getAllOutputNames)\" = \"out\" ]; then\n        return;\n    fi;\n    local outputFirst;\n    for outputFirst in $(getAllOutputNames);\n    do\n        break;\n    done;\n    local propagaterOutput=\"$outputDev\";\n    if [ -z \"$propagaterOutput\" ]; then\n        propagaterOutput=\"$outputFirst\";\n    fi;\n    if [ -z \"${propagatedBuildOutputs+1}\" ]; then\n        local po_dirty=\"$outputBin $outputInclude $outputLib\";\n        set +o pipefail;\n        propagatedBuildOutputs=`echo \"$po_dirty\"             | tr -s ' ' '\\n' | grep -v -F \"$propagaterOutput\"             | sort -u | tr '\\n' ' ' `;\n        set -o pipefail;\n    fi;\n    if [ -z \"$propagatedBuildOutputs\" ]; then\n        return;\n    fi;\n    mkdir -p \"${!propagaterOutput}\"/nix-support;\n    for output in $propagatedBuildOutputs;\n    do\n        echo -n \" ${!output}\" >> \"${!propagaterOutput}\"/nix-support/propagated-build-inputs;\n    done\n",
    "_nixLogWithLevel":" \n    [[ -z ${NIX_LOG_FD-} || ${NIX_DEBUG:-0} -lt ${1:?} ]] && return 0;\n    local logLevel;\n    case \"${1:?}\" in \n        0)\n            logLevel=ERROR\n        ;;\n        1)\n            logLevel=WARN\n        ;;\n        2)\n            logLevel=NOTICE\n        ;;\n        3)\n            logLevel=INFO\n        ;;\n        4)\n            logLevel=TALKATIVE\n        ;;\n        5)\n            logLevel=CHATTY\n        ;;\n        6)\n            logLevel=DEBUG\n        ;;\n        7)\n            logLevel=VOMIT\n        ;;\n        *)\n            echo \"_nixLogWithLevel: called with invalid log level: ${1:?}\" >&\"$NIX_LOG_FD\";\n            return 1\n        ;;\n    esac;\n    local callerName=\"${FUNCNAME[2]}\";\n    if [[ $callerName == \"_callImplicitHook\" ]]; then\n        callerName=\"${hookName:?}\";\n    fi;\n    printf \"%s: %s: %s\\n\" \"$logLevel\" \"$callerName\" \"${2:?}\" >&\"$NIX_LOG_FD\"\n",
    "_overrideFirst":" \n    if [ -z \"${!1-}\" ]; then\n        _assignFirst \"$@\";\n    fi\n",
    "_pruneLibtoolFiles":" \n    if [ \"${dontPruneLibtoolFiles-}\" ] || [ ! -e \"$prefix\" ]; then\n        return;\n    fi;\n    find \"$prefix\" -type f -name '*.la' -exec grep -q '^# Generated by .*libtool' {} \\; -exec grep -q \"^old_library=''\" {} \\; -exec sed -i {} -e \"/^dependency_libs='[^']/ c dependency_libs='' #pruned\" \\;\n",
    "_updateSourceDateEpochFromSourceRoot":" \n    if [ -n \"$sourceRoot\" ]; then\n        updateSourceDateEpoch \"$sourceRoot\";\n    fi\n",
    "activatePackage":" \n    local pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit 1;\n    if [ -f \"$pkg\" ]; then\n        nixTalkativeLog \"sourcing setup hook '$pkg'\";\n        source \"$pkg\";\n    fi;\n    if [[ -z \"${strictDeps-}\" || \"$hostOffset\" -le -1 ]]; then\n        addToSearchPath _PATH \"$pkg/bin\";\n    fi;\n    if (( hostOffset <= -1 )); then\n        addToSearchPath _XDG_DATA_DIRS \"$pkg/share\";\n    fi;\n    if [[ \"$hostOffset\" -eq 0 && -d \"$pkg/bin\" ]]; then\n        addToSearchPath _HOST_PATH \"$pkg/bin\";\n    fi;\n    if [[ -f \"$pkg/nix-support/setup-hook\" ]]; then\n        nixTalkativeLog \"sourcing setup hook '$pkg/nix-support/setup-hook'\";\n        source \"$pkg/nix-support/setup-hook\";\n    fi\n",
    "addEnvHooks":" \n    local depHostOffset=\"$1\";\n    shift;\n    local pkgHookVarsSlice=\"${pkgHookVarVars[$depHostOffset + 1]}[@]\";\n    local pkgHookVar;\n    for pkgHookVar in \"${!pkgHookVarsSlice}\";\n    do\n        eval \"${pkgHookVar}s\"'+=(\"$@\")';\n    done\n",
    "addNodePath":" \n    addToSearchPath NODE_PATH \"$1/lib/node_modules\"\n",
    "addToSearchPath":" \n    addToSearchPathWithCustomDelimiter \":\" \"$@\"\n",
    "addToSearchPathWithCustomDelimiter":" \n    local delimiter=\"$1\";\n    local varName=\"$2\";\n    local dir=\"$3\";\n    if [[ -d \"$dir\" && \"${!varName:+${delimiter}${!varName}${delimiter}}\" != *\"${delimiter}${dir}${delimiter}\"* ]]; then\n        export \"${varName}=${!varName:+${!varName}${delimiter}}${dir}\";\n    fi\n",
    "appendToVar":" \n    local -n nameref=\"$1\";\n    local useArray type;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if type=$(declare -p \"$1\" 2> /dev/null); then\n        case \"${type#* }\" in \n            -A*)\n                echo \"appendToVar(): ERROR: trying to use appendToVar on an associative array, use variable+=([\\\"X\\\"]=\\\"Y\\\") instead.\" 1>&2;\n                return 1\n            ;;\n            -a*)\n                useArray=true\n            ;;\n            *)\n                useArray=false\n            ;;\n        esac;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(${nameref+\"${nameref[@]}\"} \"$@\");\n    else\n        nameref=\"${nameref-} $*\";\n    fi\n",
    "auditTmpdir":" \n    local dir=\"$1\";\n    [ -e \"$dir\" ] || return 0;\n    echo \"checking for references to $TMPDIR/ in $dir...\";\n    local i;\n    find \"$dir\" -type f -print0 | while IFS= read -r -d '' i; do\n        if [[ \"$i\" =~ .build-id ]]; then\n            continue;\n        fi;\n        if isELF \"$i\"; then\n            if { \n                printf :;\n                patchelf --print-rpath \"$i\"\n            } | grep -q -F \":$TMPDIR/\"; then\n                echo \"RPATH of binary $i contains a forbidden reference to $TMPDIR/\";\n                exit 1;\n            fi;\n        fi;\n        if isScript \"$i\"; then\n            if [ -e \"$(dirname \"$i\")/.$(basename \"$i\")-wrapped\" ]; then\n                if grep -q -F \"$TMPDIR/\" \"$i\"; then\n                    echo \"wrapper script $i contains a forbidden reference to $TMPDIR/\";\n                    exit 1;\n                fi;\n            fi;\n        fi;\n    done\n",
    "bintoolsWrapper_addLDVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [[ -d \"$1/lib64\" && ! -L \"$1/lib64\" ]]; then\n        export NIX_LDFLAGS${role_post}+=\" -L$1/lib64\";\n    fi;\n    if [[ -d \"$1/lib\" ]]; then\n        local -a glob=($1/lib/lib*);\n        if [ \"${#glob[*]}\" -gt 0 ]; then\n            export NIX_LDFLAGS${role_post}+=\" -L$1/lib\";\n        fi;\n    fi\n",
    "buildPhase":" \n    runHook preBuild;\n    if [[ -z \"${makeFlags-}\" && -z \"${makefile:-}\" && ! ( -e Makefile || -e makefile || -e GNUmakefile ) ]]; then\n        echo \"no Makefile or custom buildPhase, doing nothing\";\n    else\n        foundMakefile=1;\n        local flagsArray=(${enableParallelBuilding:+-j${NIX_BUILD_CORES}} SHELL=\"$SHELL\");\n        concatTo flagsArray makeFlags makeFlagsArray buildFlags buildFlagsArray;\n        echoCmd 'build flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postBuild\n",
    "ccWrapper_addCVars":" \n    local role_post;\n    getHostRoleEnvHook;\n    if [ -d \"$1/include\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -isystem $1/include\";\n    fi;\n    if [ -d \"$1/Library/Frameworks\" ]; then\n        export NIX_CFLAGS_COMPILE${role_post}+=\" -iframework $1/Library/Frameworks\";\n    fi\n",
    "checkPhase":" \n    runHook preCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom checkPhase, doing nothing\";\n        runHook postCheck;\n        return;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        if make -n ${makefile:+-f $makefile} check > /dev/null 2>&1; then\n            checkTarget=\"check\";\n        else\n            if make -n ${makefile:+-f $makefile} test > /dev/null 2>&1; then\n                checkTarget=\"test\";\n            fi;\n        fi;\n    fi;\n    if [[ -z \"${checkTarget:-}\" ]]; then\n        echo \"no check/test target in ${makefile:-Makefile}, doing nothing\";\n    else\n        local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=\"$SHELL\");\n        concatTo flagsArray makeFlags makeFlagsArray checkFlags=VERBOSE=y checkFlagsArray checkTarget;\n        echoCmd 'check flags' \"${flagsArray[@]}\";\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n        unset flagsArray;\n    fi;\n    runHook postCheck\n",
    "compressManPages":" \n    local dir=\"$1\";\n    if [ -L \"$dir\"/share ] || [ -L \"$dir\"/share/man ] || [ ! -d \"$dir/share/man\" ]; then\n        return;\n    fi;\n    echo \"gzipping man pages under $dir/share/man/\";\n    find \"$dir\"/share/man/ -type f -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | while IFS= read -r -d '' f; do\n        if gzip -c -n \"$f\" > \"$f\".gz; then\n            rm \"$f\";\n        else\n            rm \"$f\".gz;\n        fi;\n    done;\n    find \"$dir\"/share/man/ -type l -a '!' -regex '.*\\.\\(bz2\\|gz\\|xz\\)$' -print0 | sort -z | while IFS= read -r -d '' f; do\n        local target;\n        target=\"$(readlink -f \"$f\")\";\n        if [ -f \"$target\".gz ]; then\n            ln -sf \"$target\".gz \"$f\".gz && rm \"$f\";\n        fi;\n    done\n",
    "concatStringsSep":" \n    local sep=\"$1\";\n    local name=\"$2\";\n    local type oldifs;\n    if type=$(declare -p \"$name\" 2> /dev/null); then\n        local -n nameref=\"$name\";\n        case \"${type#* }\" in \n            -A*)\n                echo \"concatStringsSep(): ERROR: trying to use concatStringsSep on an associative array.\" 1>&2;\n                return 1\n            ;;\n            -a*)\n                local IFS=\"$(printf '\\036')\"\n            ;;\n            *)\n                local IFS=\" \"\n            ;;\n        esac;\n        local ifs_separated=\"${nameref[*]}\";\n        echo -n \"${ifs_separated//\"$IFS\"/\"$sep\"}\";\n    fi\n",
    "concatTo":" \n    local -;\n    set -o noglob;\n    local -n targetref=\"$1\";\n    shift;\n    local arg default name type;\n    for arg in \"$@\";\n    do\n        IFS=\"=\" read -r name default <<< \"$arg\";\n        local -n nameref=\"$name\";\n        if [[ -z \"${nameref[*]}\" && -n \"$default\" ]]; then\n            targetref+=(\"$default\");\n        else\n            if type=$(declare -p \"$name\" 2> /dev/null); then\n                case \"${type#* }\" in \n                    -A*)\n                        echo \"concatTo(): ERROR: trying to use concatTo on an associative array.\" 1>&2;\n                        return 1\n                    ;;\n                    -a*)\n                        targetref+=(\"${nameref[@]}\")\n                    ;;\n                    *)\n                        if [[ \"$name\" = *\"Array\" ]]; then\n                            nixErrorLog \"concatTo(): $name is not declared as array, treating as a singleton. This will become an error in future\";\n                            targetref+=(${nameref+\"${nameref[@]}\"});\n                        else\n                            targetref+=(${nameref-});\n                        fi\n                    ;;\n                esac;\n            fi;\n        fi;\n    done\n",
    "configurePhase":" \n    runHook preConfigure;\n    : \"${configureScript=}\";\n    if [[ -z \"$configureScript\" && -x ./configure ]]; then\n        configureScript=./configure;\n    fi;\n    if [ -z \"${dontFixLibtool:-}\" ]; then\n        export lt_cv_deplibs_check_method=\"${lt_cv_deplibs_check_method-pass_all}\";\n        local i;\n        find . -iname \"ltmain.sh\" -print0 | while IFS='' read -r -d '' i; do\n            echo \"fixing libtool script $i\";\n            fixLibtool \"$i\";\n        done;\n        CONFIGURE_MTIME_REFERENCE=$(mktemp configure.mtime.reference.XXXXXX);\n        find . -executable -type f -name configure -exec grep -l 'GNU Libtool is free software; you can redistribute it and/or modify' {} \\; -exec touch -r {} \"$CONFIGURE_MTIME_REFERENCE\" \\; -exec sed -i s_/usr/bin/file_file_g {} \\; -exec touch -r \"$CONFIGURE_MTIME_REFERENCE\" {} \\;;\n        rm -f \"$CONFIGURE_MTIME_REFERENCE\";\n    fi;\n    if [[ -z \"${dontAddPrefix:-}\" && -n \"$prefix\" ]]; then\n        prependToVar configureFlags \"${prefixKey:---prefix=}$prefix\";\n    fi;\n    if [[ -f \"$configureScript\" ]]; then\n        if [ -z \"${dontAddDisableDepTrack:-}\" ]; then\n            if grep -q dependency-tracking \"$configureScript\"; then\n                prependToVar configureFlags --disable-dependency-tracking;\n            fi;\n        fi;\n        if [ -z \"${dontDisableStatic:-}\" ]; then\n            if grep -q enable-static \"$configureScript\"; then\n                prependToVar configureFlags --disable-static;\n            fi;\n        fi;\n        if [ -z \"${dontPatchShebangsInConfigure:-}\" ]; then\n            patchShebangs --build \"$configureScript\";\n        fi;\n    fi;\n    if [ -n \"$configureScript\" ]; then\n        local -a flagsArray;\n        concatTo flagsArray configureFlags configureFlagsArray;\n        echoCmd 'configure flags' \"${flagsArray[@]}\";\n        $configureScript \"${flagsArray[@]}\";\n        unset flagsArray;\n    else\n        echo \"no configure script, doing nothing\";\n    fi;\n    runHook postConfigure\n",
    "consumeEntire":" \n    if IFS='' read -r -d '' \"$1\"; then\n        echo \"consumeEntire(): ERROR: Input null bytes, won't process\" 1>&2;\n        return 1;\n    fi\n",
    "distPhase":" \n    runHook preDist;\n    local flagsArray=();\n    concatTo flagsArray distFlags distFlagsArray distTarget=dist;\n    echo 'dist flags: %q' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    if [ \"${dontCopyDist:-0}\" != 1 ]; then\n        mkdir -p \"$out/tarballs\";\n        cp -pvd ${tarballs[*]:-*.tar.gz} \"$out/tarballs\";\n    fi;\n    runHook postDist\n",
    "dumpVars":" \n    if [ \"${noDumpEnvVars:-0}\" != 1 ]; then\n        { \n            install -m 0600 /dev/null \"$NIX_BUILD_TOP/env-vars\" && export 2> /dev/null >| \"$NIX_BUILD_TOP/env-vars\"\n        } || true;\n    fi\n",
    "echoCmd":" \n    printf \"%s:\" \"$1\";\n    shift;\n    printf ' %q' \"$@\";\n    echo\n",
    "exitHandler":" \n    exitCode=\"$?\";\n    set +e;\n    if [ -n \"${showBuildStats:-}\" ]; then\n        read -r -d '' -a buildTimes < <(times);\n        echo \"build times:\";\n        echo \"user time for the shell             ${buildTimes[0]}\";\n        echo \"system time for the shell           ${buildTimes[1]}\";\n        echo \"user time for all child processes   ${buildTimes[2]}\";\n        echo \"system time for all child processes ${buildTimes[3]}\";\n    fi;\n    if (( \"$exitCode\" != 0 )); then\n        runHook failureHook;\n        if [ -n \"${succeedOnFailure:-}\" ]; then\n            echo \"build failed with exit code $exitCode (ignored)\";\n            mkdir -p \"$out/nix-support\";\n            printf \"%s\" \"$exitCode\" > \"$out/nix-support/failed\";\n            exit 0;\n        fi;\n    else\n        runHook exitHook;\n    fi;\n    return \"$exitCode\"\n",
    "findInputs":" \n    local -r pkg=\"$1\";\n    local -r hostOffset=\"$2\";\n    local -r targetOffset=\"$3\";\n    (( hostOffset <= targetOffset )) || exit 1;\n    local varVar=\"${pkgAccumVarVars[hostOffset + 1]}\";\n    local varRef=\"$varVar[$((targetOffset - hostOffset))]\";\n    local var=\"${!varRef}\";\n    unset -v varVar varRef;\n    local varSlice=\"$var[*]\";\n    case \" ${!varSlice-} \" in \n        *\" $pkg \"*)\n            return 0\n        ;;\n    esac;\n    unset -v varSlice;\n    eval \"$var\"'+=(\"$pkg\")';\n    if ! [ -e \"$pkg\" ]; then\n        echo \"build input $pkg does not exist\" 1>&2;\n        exit 1;\n    fi;\n    function mapOffset () \n    { \n        local -r inputOffset=\"$1\";\n        local -n outputOffset=\"$2\";\n        if (( inputOffset <= 0 )); then\n            outputOffset=$((inputOffset + hostOffset));\n        else\n            outputOffset=$((inputOffset - 1 + targetOffset));\n        fi\n    };\n    local relHostOffset;\n    for relHostOffset in \"${allPlatOffsets[@]}\";\n    do\n        local files=\"${propagatedDepFilesVars[relHostOffset + 1]}\";\n        local hostOffsetNext;\n        mapOffset \"$relHostOffset\" hostOffsetNext;\n        (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n        local relTargetOffset;\n        for relTargetOffset in \"${allPlatOffsets[@]}\";\n        do\n            (( \"$relHostOffset\" <= \"$relTargetOffset\" )) || continue;\n            local fileRef=\"${files}[$relTargetOffset - $relHostOffset]\";\n            local file=\"${!fileRef}\";\n            unset -v fileRef;\n            local targetOffsetNext;\n            mapOffset \"$relTargetOffset\" targetOffsetNext;\n            (( -1 <= hostOffsetNext && hostOffsetNext <= 1 )) || continue;\n            [[ -f \"$pkg/nix-support/$file\" ]] || continue;\n            local pkgNext;\n            read -r -d '' pkgNext < \"$pkg/nix-support/$file\" || true;\n            for pkgNext in $pkgNext;\n            do\n                findInputs \"$pkgNext\" \"$hostOffsetNext\" \"$targetOffsetNext\";\n            done;\n        done;\n    done\n",
    "fixLibtool":" \n    local search_path;\n    for flag in $NIX_LDFLAGS;\n    do\n        case $flag in \n            -L*)\n                search_path+=\" ${flag#-L}\"\n            ;;\n        esac;\n    done;\n    sed -i \"$1\" -e \"s^eval \\(sys_lib_search_path=\\).*^\\1'${search_path:-}'^\" -e 's^eval sys_lib_.+search_path=.*^^'\n",
    "fixupPhase":" \n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ -e \"${!output}\" ]; then\n            chmod -R u+w,u-s,g-s \"${!output}\";\n        fi;\n    done;\n    runHook preFixup;\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        prefix=\"${!output}\" runHook fixupOutput;\n    done;\n    recordPropagatedDependencies;\n    if [ -n \"${setupHook:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        substituteAll \"$setupHook\" \"${!outputDev}/nix-support/setup-hook\";\n    fi;\n    if [ -n \"${setupHooks:-}\" ]; then\n        mkdir -p \"${!outputDev}/nix-support\";\n        local hook;\n        for hook in ${setupHooks[@]};\n        do\n            local content;\n            consumeEntire content < \"$hook\";\n            substituteAllStream content \"file '$hook'\" >> \"${!outputDev}/nix-support/setup-hook\";\n            unset -v content;\n        done;\n        unset -v hook;\n    fi;\n    if [ -n \"${propagatedUserEnvPkgs[*]:-}\" ]; then\n        mkdir -p \"${!outputBin}/nix-support\";\n        printWords \"${propagatedUserEnvPkgs[@]}\" > \"${!outputBin}/nix-support/propagated-user-env-packages\";\n    fi;\n    runHook postFixup\n",
    "genericBuild":" \n    export GZIP_NO_TIMESTAMPS=1;\n    if [ -f \"${buildCommandPath:-}\" ]; then\n        source \"$buildCommandPath\";\n        return;\n    fi;\n    if [ -n \"${buildCommand:-}\" ]; then\n        eval \"$buildCommand\";\n        return;\n    fi;\n    if [ -z \"${phases[*]:-}\" ]; then\n        phases=\"${prePhases[*]:-} unpackPhase patchPhase ${preConfigurePhases[*]:-}             configurePhase ${preBuildPhases[*]:-} buildPhase checkPhase             ${preInstallPhases[*]:-} installPhase ${preFixupPhases[*]:-} fixupPhase installCheckPhase             ${preDistPhases[*]:-} distPhase ${postPhases[*]:-}\";\n    fi;\n    for curPhase in ${phases[*]};\n    do\n        runPhase \"$curPhase\";\n    done\n",
    "getAllOutputNames":" \n    if [ -n \"$__structuredAttrs\" ]; then\n        echo \"${!outputs[*]}\";\n    else\n        echo \"$outputs\";\n    fi\n",
    "getHostRole":" \n    getRole \"$hostOffset\"\n",
    "getHostRoleEnvHook":" \n    getRole \"$depHostOffset\"\n",
    "getRole":" \n    case $1 in \n        -1)\n            role_post='_FOR_BUILD'\n        ;;\n        0)\n            role_post=''\n        ;;\n        1)\n            role_post='_FOR_TARGET'\n        ;;\n        *)\n            echo \"apple-sdk-11.3: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "getTargetRole":" \n    getRole \"$targetOffset\"\n",
    "getTargetRoleEnvHook":" \n    getRole \"$depTargetOffset\"\n",
    "getTargetRoleWrapper":" \n    case $targetOffset in \n        -1)\n            export NIX_@wrapperName@_TARGET_BUILD_@suffixSalt@=1\n        ;;\n        0)\n            export NIX_@wrapperName@_TARGET_HOST_@suffixSalt@=1\n        ;;\n        1)\n            export NIX_@wrapperName@_TARGET_TARGET_@suffixSalt@=1\n        ;;\n        *)\n            echo \"apple-sdk-11.3: used as improper sort of dependency\" 1>&2;\n            return 1\n        ;;\n    esac\n",
    "installCheckPhase":" \n    runHook preInstallCheck;\n    if [[ -z \"${foundMakefile:-}\" ]]; then\n        echo \"no Makefile or custom installCheckPhase, doing nothing\";\n    else\n        if [[ -z \"${installCheckTarget:-}\" ]] && ! make -n ${makefile:+-f $makefile} \"${installCheckTarget:-installcheck}\" > /dev/null 2>&1; then\n            echo \"no installcheck target in ${makefile:-Makefile}, doing nothing\";\n        else\n            local flagsArray=(${enableParallelChecking:+-j${NIX_BUILD_CORES}} SHELL=\"$SHELL\");\n            concatTo flagsArray makeFlags makeFlagsArray installCheckFlags installCheckFlagsArray installCheckTarget=installcheck;\n            echoCmd 'installcheck flags' \"${flagsArray[@]}\";\n            make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n            unset flagsArray;\n        fi;\n    fi;\n    runHook postInstallCheck\n",
    "installPhase":" \n    runHook preInstall;\n    if [[ -z \"${makeFlags-}\" && -z \"${makefile:-}\" && ! ( -e Makefile || -e makefile || -e GNUmakefile ) ]]; then\n        echo \"no Makefile or custom installPhase, doing nothing\";\n        runHook postInstall;\n        return;\n    else\n        foundMakefile=1;\n    fi;\n    if [ -n \"$prefix\" ]; then\n        mkdir -p \"$prefix\";\n    fi;\n    local flagsArray=(${enableParallelInstalling:+-j${NIX_BUILD_CORES}} SHELL=\"$SHELL\");\n    concatTo flagsArray makeFlags makeFlagsArray installFlags installFlagsArray installTargets=install;\n    echoCmd 'install flags' \"${flagsArray[@]}\";\n    make ${makefile:+-f $makefile} \"${flagsArray[@]}\";\n    unset flagsArray;\n    runHook postInstall\n",
    "isELF":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [ \"$magic\" = 'ELF' ]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "isMachO":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 4 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xcf\") || \"$magic\" = $(echo -ne \"\\xcf\\xfa\\xed\\xfe\") ]]; then\n        return 0;\n    else\n        if [[ \"$magic\" = $(echo -ne \"\\xfe\\xed\\xfa\\xce\") || \"$magic\" = $(echo -ne \"\\xce\\xfa\\xed\\xfe\") ]]; then\n            return 0;\n        else\n            if [[ \"$magic\" = $(echo -ne \"\\xca\\xfe\\xba\\xbe\") || \"$magic\" = $(echo -ne \"\\xbe\\xba\\xfe\\xca\") ]]; then\n                return 0;\n            else\n                return 1;\n            fi;\n        fi;\n    fi\n",
    "isScript":" \n    local fn=\"$1\";\n    local fd;\n    local magic;\n    exec {fd}< \"$fn\";\n    read -r -n 2 -u \"$fd\" magic;\n    exec {fd}>&-;\n    if [[ \"$magic\" =~ \\#! ]]; then\n        return 0;\n    else\n        return 1;\n    fi\n",
    "mapOffset":" \n    local -r inputOffset=\"$1\";\n    local -n outputOffset=\"$2\";\n    if (( inputOffset <= 0 )); then\n        outputOffset=$((inputOffset + hostOffset));\n    else\n        outputOffset=$((inputOffset - 1 + targetOffset));\n    fi\n",
    "moveToOutput":" \n    local patt=\"$1\";\n    local dstOut=\"$2\";\n    local output;\n    for output in $(getAllOutputNames);\n    do\n        if [ \"${!output}\" = \"$dstOut\" ]; then\n            continue;\n        fi;\n        local srcPath;\n        for srcPath in \"${!output}\"/$patt;\n        do\n            if [ ! -e \"$srcPath\" ] && [ ! -L \"$srcPath\" ]; then\n                continue;\n            fi;\n            if [ \"$dstOut\" = REMOVE ]; then\n                echo \"Removing $srcPath\";\n                rm -r \"$srcPath\";\n            else\n                local dstPath=\"$dstOut${srcPath#${!output}}\";\n                echo \"Moving $srcPath to $dstPath\";\n                if [ -d \"$dstPath\" ] && [ -d \"$srcPath\" ]; then\n                    rmdir \"$srcPath\" --ignore-fail-on-non-empty;\n                    if [ -d \"$srcPath\" ]; then\n                        mv -t \"$dstPath\" \"$srcPath\"/*;\n                        rmdir \"$srcPath\";\n                    fi;\n                else\n                    mkdir -p \"$(readlink -m \"$dstPath/..\")\";\n                    mv \"$srcPath\" \"$dstPath\";\n                fi;\n            fi;\n            local srcParent=\"$(readlink -m \"$srcPath/..\")\";\n            if [ -n \"$(find \"$srcParent\" -maxdepth 0 -type d -empty 2> /dev/null)\" ]; then\n                echo \"Removing empty $srcParent/ and (possibly) its parents\";\n                rmdir -p --ignore-fail-on-non-empty \"$srcParent\" 2> /dev/null || true;\n            fi;\n        done;\n    done\n",
    "nixChattyLog":" \n    _nixLogWithLevel 5 \"$*\"\n",
    "nixDebugLog":" \n    _nixLogWithLevel 6 \"$*\"\n",
    "nixErrorLog":" \n    _nixLogWithLevel 0 \"$*\"\n",
    "nixInfoLog":" \n    _nixLogWithLevel 3 \"$*\"\n",
    "nixLog":" \n    [[ -z ${NIX_LOG_FD-} ]] && return 0;\n    local callerName=\"${FUNCNAME[1]}\";\n    if [[ $callerName == \"_callImplicitHook\" ]]; then\n        callerName=\"${hookName:?}\";\n    fi;\n    printf \"%s: %s\\n\" \"$callerName\" \"$*\" >&\"$NIX_LOG_FD\"\n",
    "nixNoticeLog":" \n    _nixLogWithLevel 2 \"$*\"\n",
    "nixTalkativeLog":" \n    _nixLogWithLevel 4 \"$*\"\n",
    "nixVomitLog":" \n    _nixLogWithLevel 7 \"$*\"\n",
    "nixWarnLog":" \n    _nixLogWithLevel 1 \"$*\"\n",
    "noBrokenSymlinks":" \n    local -r output=\"${1:?}\";\n    local path;\n    local pathParent;\n    local symlinkTarget;\n    local -i numDanglingSymlinks=0;\n    local -i numReflexiveSymlinks=0;\n    local -i numUnreadableSymlinks=0;\n    if [[ ! -e $output ]]; then\n        nixWarnLog \"skipping non-existent output $output\";\n        return 0;\n    fi;\n    nixInfoLog \"running on $output\";\n    while IFS= read -r -d '' path; do\n        pathParent=\"$(dirname \"$path\")\";\n        if ! symlinkTarget=\"$(readlink \"$path\")\"; then\n            nixErrorLog \"the symlink $path is unreadable\";\n            numUnreadableSymlinks+=1;\n            continue;\n        fi;\n        if [[ $symlinkTarget == /* ]]; then\n            nixInfoLog \"symlink $path points to absolute target $symlinkTarget\";\n        else\n            nixInfoLog \"symlink $path points to relative target $symlinkTarget\";\n            symlinkTarget=\"$(realpath --no-symlinks --canonicalize-missing \"$pathParent/$symlinkTarget\")\";\n        fi;\n        if [[ $symlinkTarget != \"$NIX_STORE\"/* ]]; then\n            nixInfoLog \"symlink $path points outside the Nix store; ignoring\";\n            continue;\n        fi;\n        if [[ $path == \"$symlinkTarget\" ]]; then\n            nixErrorLog \"the symlink $path is reflexive\";\n            numReflexiveSymlinks+=1;\n        else\n            if [[ ! -e $symlinkTarget ]]; then\n                nixErrorLog \"the symlink $path points to a missing target: $symlinkTarget\";\n                numDanglingSymlinks+=1;\n            else\n                nixDebugLog \"the symlink $path is irreflexive and points to a target which exists\";\n            fi;\n        fi;\n    done < <(find \"$output\" -type l -print0);\n    if ((numDanglingSymlinks > 0 || numReflexiveSymlinks > 0 || numUnreadableSymlinks > 0)); then\n        nixErrorLog \"found $numDanglingSymlinks dangling symlinks, $numReflexiveSymlinks reflexive symlinks and $numUnreadableSymlinks unreadable symlinks\";\n        exit 1;\n    fi;\n    return 0\n",
    "noBrokenSymlinksInAllOutputs":" \n    if [[ -z ${dontCheckForBrokenSymlinks-} ]]; then\n        for output in $(getAllOutputNames);\n        do\n            noBrokenSymlinks \"${!output}\";\n        done;\n    fi\n",
    "patchPhase":" \n    runHook prePatch;\n    local -a patchesArray;\n    concatTo patchesArray patches;\n    for i in \"${patchesArray[@]}\";\n    do\n        echo \"applying patch $i\";\n        local uncompress=cat;\n        case \"$i\" in \n            *.gz)\n                uncompress=\"gzip -d\"\n            ;;\n            *.bz2)\n                uncompress=\"bzip2 -d\"\n            ;;\n            *.xz)\n                uncompress=\"xz -d\"\n            ;;\n            *.lzma)\n                uncompress=\"lzma -d\"\n            ;;\n        esac;\n        local -a flagsArray;\n        concatTo flagsArray patchFlags=-p1;\n        $uncompress < \"$i\" 2>&1 | patch \"${flagsArray[@]}\";\n    done;\n    runHook postPatch\n",
    "patchShebangs":" \n    local pathName;\n    local update=false;\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in \n            --host)\n                pathName=HOST_PATH;\n                shift\n            ;;\n            --build)\n                pathName=PATH;\n                shift\n            ;;\n            --update)\n                update=true;\n                shift\n            ;;\n            --)\n                shift;\n                break\n            ;;\n            -* | --*)\n                echo \"Unknown option $1 supplied to patchShebangs\" 1>&2;\n                return 1\n            ;;\n            *)\n                break\n            ;;\n        esac;\n    done;\n    echo \"patching script interpreter paths in $@\";\n    local f;\n    local oldPath;\n    local newPath;\n    local arg0;\n    local args;\n    local oldInterpreterLine;\n    local newInterpreterLine;\n    if [[ $# -eq 0 ]]; then\n        echo \"No arguments supplied to patchShebangs\" 1>&2;\n        return 0;\n    fi;\n    local f;\n    while IFS= read -r -d '' f; do\n        isScript \"$f\" || continue;\n        read -r oldInterpreterLine < \"$f\" || [ \"$oldInterpreterLine\" ];\n        read -r oldPath arg0 args <<< \"${oldInterpreterLine:2}\";\n        if [[ -z \"${pathName:-}\" ]]; then\n            if [[ -n $strictDeps && $f == \"$NIX_STORE\"* ]]; then\n                pathName=HOST_PATH;\n            else\n                pathName=PATH;\n            fi;\n        fi;\n        if [[ \"$oldPath\" == *\"/bin/env\" ]]; then\n            if [[ $arg0 == \"-S\" ]]; then\n                arg0=${args%% *};\n                [[ \"$args\" == *\" \"* ]] && args=${args#* } || args=;\n                newPath=\"$(PATH=\"${!pathName}\" type -P \"env\" || true)\";\n                args=\"-S $(PATH=\"${!pathName}\" type -P \"$arg0\" || true) $args\";\n            else\n                if [[ $arg0 == \"-\"* || $arg0 == *\"=\"* ]]; then\n                    echo \"$f: unsupported interpreter directive \\\"$oldInterpreterLine\\\" (set dontPatchShebangs=1 and handle shebang patching yourself)\" 1>&2;\n                    exit 1;\n                else\n                    newPath=\"$(PATH=\"${!pathName}\" type -P \"$arg0\" || true)\";\n                fi;\n            fi;\n        else\n            if [[ -z $oldPath ]]; then\n                oldPath=\"/bin/sh\";\n            fi;\n            newPath=\"$(PATH=\"${!pathName}\" type -P \"$(basename \"$oldPath\")\" || true)\";\n            args=\"$arg0 $args\";\n        fi;\n        newInterpreterLine=\"$newPath $args\";\n        newInterpreterLine=${newInterpreterLine%${newInterpreterLine##*[![:space:]]}};\n        if [[ -n \"$oldPath\" && ( \"$update\" == true || \"${oldPath:0:${#NIX_STORE}}\" != \"$NIX_STORE\" ) ]]; then\n            if [[ -n \"$newPath\" && \"$newPath\" != \"$oldPath\" ]]; then\n                echo \"$f: interpreter directive changed from \\\"$oldInterpreterLine\\\" to \\\"$newInterpreterLine\\\"\";\n                escapedInterpreterLine=${newInterpreterLine//\\\\/\\\\\\\\};\n                timestamp=$(stat --printf \"%y\" \"$f\");\n                sed -i -e \"1 s|.*|#\\!$escapedInterpreterLine|\" \"$f\";\n                touch --date \"$timestamp\" \"$f\";\n            fi;\n        fi;\n    done < <(find \"$@\" -type f -perm -0100 -print0)\n",
    "patchShebangsAuto":" \n    if [[ -z \"${dontPatchShebangs-}\" && -e \"$prefix\" ]]; then\n        if [[ \"$output\" != out && \"$output\" = \"$outputDev\" ]]; then\n            patchShebangs --build \"$prefix\";\n        else\n            patchShebangs --host \"$prefix\";\n        fi;\n    fi\n",
    "prependToVar":" \n    local -n nameref=\"$1\";\n    local useArray type;\n    if [ -n \"$__structuredAttrs\" ]; then\n        useArray=true;\n    else\n        useArray=false;\n    fi;\n    if type=$(declare -p \"$1\" 2> /dev/null); then\n        case \"${type#* }\" in \n            -A*)\n                echo \"prependToVar(): ERROR: trying to use prependToVar on an associative array.\" 1>&2;\n                return 1\n            ;;\n            -a*)\n                useArray=true\n            ;;\n            *)\n                useArray=false\n            ;;\n        esac;\n    fi;\n    shift;\n    if $useArray; then\n        nameref=(\"$@\" ${nameref+\"${nameref[@]}\"});\n    else\n        nameref=\"$* ${nameref-}\";\n    fi\n",
    "printLines":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s\\n' \"$@\"\n",
    "printWords":" \n    (( \"$#\" > 0 )) || return 0;\n    printf '%s ' \"$@\"\n",
    "recordPropagatedDependencies":" \n    declare -ra flatVars=(depsBuildBuildPropagated propagatedNativeBuildInputs depsBuildTargetPropagated depsHostHostPropagated propagatedBuildInputs depsTargetTargetPropagated);\n    declare -ra flatFiles=(\"${propagatedBuildDepFiles[@]}\" \"${propagatedHostDepFiles[@]}\" \"${propagatedTargetDepFiles[@]}\");\n    local propagatedInputsIndex;\n    for propagatedInputsIndex in \"${!flatVars[@]}\";\n    do\n        local propagatedInputsSlice=\"${flatVars[$propagatedInputsIndex]}[@]\";\n        local propagatedInputsFile=\"${flatFiles[$propagatedInputsIndex]}\";\n        [[ -n \"${!propagatedInputsSlice}\" ]] || continue;\n        mkdir -p \"${!outputDev}/nix-support\";\n        printWords ${!propagatedInputsSlice} > \"${!outputDev}/nix-support/$propagatedInputsFile\";\n    done\n",
    "runHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook;\n    for hook in \"_callImplicitHook 0 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        _logHook \"$hookName\" \"$hook\" \"$@\";\n        _eval \"$hook\" \"$@\";\n    done;\n    return 0\n",
    "runOneHook":" \n    local hookName=\"$1\";\n    shift;\n    local hooksSlice=\"${hookName%Hook}Hooks[@]\";\n    local hook ret=1;\n    for hook in \"_callImplicitHook 1 $hookName\" ${!hooksSlice+\"${!hooksSlice}\"};\n    do\n        _logHook \"$hookName\" \"$hook\" \"$@\";\n        if _eval \"$hook\" \"$@\"; then\n            ret=0;\n            break;\n        fi;\n    done;\n    return \"$ret\"\n",
    "runPhase":" \n    local curPhase=\"$*\";\n    if [[ \"$curPhase\" = unpackPhase && -n \"${dontUnpack:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = patchPhase && -n \"${dontPatch:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = configurePhase && -n \"${dontConfigure:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = buildPhase && -n \"${dontBuild:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = checkPhase && -z \"${doCheck:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = installPhase && -n \"${dontInstall:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = fixupPhase && -n \"${dontFixup:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = installCheckPhase && -z \"${doInstallCheck:-}\" ]]; then\n        return;\n    fi;\n    if [[ \"$curPhase\" = distPhase && -z \"${doDist:-}\" ]]; then\n        return;\n    fi;\n    showPhaseHeader \"$curPhase\";\n    dumpVars;\n    local startTime endTime;\n    startTime=$(date +\"%s\");\n    eval \"${!curPhase:-$curPhase}\";\n    endTime=$(date +\"%s\");\n    showPhaseFooter \"$curPhase\" \"$startTime\" \"$endTime\";\n    if [ \"$curPhase\" = unpackPhase ]; then\n        [ -n \"${sourceRoot:-}\" ] && chmod +x -- \"${sourceRoot}\";\n        cd -- \"${sourceRoot:-.}\";\n    fi\n",
    "showPhaseFooter":" \n    local phase=\"$1\";\n    local startTime=\"$2\";\n    local endTime=\"$3\";\n    local delta=$(( endTime - startTime ));\n    (( delta < 30 )) && return;\n    local H=$((delta/3600));\n    local M=$((delta%3600/60));\n    local S=$((delta%60));\n    echo -n \"$phase completed in \";\n    (( H > 0 )) && echo -n \"$H hours \";\n    (( M > 0 )) && echo -n \"$M minutes \";\n    echo \"$S seconds\"\n",
    "showPhaseHeader":" \n    local phase=\"$1\";\n    echo \"Running phase: $phase\";\n    if [[ -z ${NIX_LOG_FD-} ]]; then\n        return;\n    fi;\n    printf \"@nix { \\\"action\\\": \\\"setPhase\\\", \\\"phase\\\": \\\"%s\\\" }\\n\" \"$phase\" >&\"$NIX_LOG_FD\"\n",
    "stripDirs":" \n    local cmd=\"$1\";\n    local ranlibCmd=\"$2\";\n    local paths=\"$3\";\n    local stripFlags=\"$4\";\n    local excludeFlags=();\n    local pathsNew=;\n    [ -z \"$cmd\" ] && echo \"stripDirs: Strip command is empty\" 1>&2 && exit 1;\n    [ -z \"$ranlibCmd\" ] && echo \"stripDirs: Ranlib command is empty\" 1>&2 && exit 1;\n    local pattern;\n    if [ -n \"${stripExclude:-}\" ]; then\n        for pattern in \"${stripExclude[@]}\";\n        do\n            excludeFlags+=(-a '!' '(' -name \"$pattern\" -o -wholename \"$prefix/$pattern\" ')');\n        done;\n    fi;\n    local p;\n    for p in ${paths};\n    do\n        if [ -e \"$prefix/$p\" ]; then\n            pathsNew=\"${pathsNew} $prefix/$p\";\n        fi;\n    done;\n    paths=${pathsNew};\n    if [ -n \"${paths}\" ]; then\n        echo \"stripping (with command $cmd and flags $stripFlags) in $paths\";\n        local striperr;\n        striperr=\"$(mktemp --tmpdir=\"$TMPDIR\" 'striperr.XXXXXX')\";\n        find $paths -type f \"${excludeFlags[@]}\" -a '!' -path \"$prefix/lib/debug/*\" -printf '%D-%i,%p\\0' | sort -t, -k1,1 -u -z | cut -d, -f2- -z | xargs -r -0 -n1 -P \"$NIX_BUILD_CORES\" -- $cmd $stripFlags 2> \"$striperr\" || exit_code=$?;\n        [[ \"$exit_code\" = 123 || -z \"$exit_code\" ]] || ( cat \"$striperr\" 1>&2 && exit 1 );\n        rm \"$striperr\";\n        find $paths -name '*.a' -type f -exec $ranlibCmd '{}' \\; 2> /dev/null;\n    fi\n",
    "stripHash":" \n    local strippedName casematchOpt=0;\n    strippedName=\"$(basename -- \"$1\")\";\n    shopt -q nocasematch && casematchOpt=1;\n    shopt -u nocasematch;\n    if [[ \"$strippedName\" =~ ^[a-z0-9]{32}- ]]; then\n        echo \"${strippedName:33}\";\n    else\n        echo \"$strippedName\";\n    fi;\n    if (( casematchOpt )); then\n        shopt -s nocasematch;\n    fi\n",
    "substitute":" \n    local input=\"$1\";\n    local output=\"$2\";\n    shift 2;\n    if [ ! -f \"$input\" ]; then\n        echo \"substitute(): ERROR: file '$input' does not exist\" 1>&2;\n        return 1;\n    fi;\n    local content;\n    consumeEntire content < \"$input\";\n    if [ -e \"$output\" ]; then\n        chmod +w \"$output\";\n    fi;\n    substituteStream content \"file '$input'\" \"$@\" > \"$output\"\n",
    "substituteAll":" \n    local input=\"$1\";\n    local output=\"$2\";\n    local -a args=();\n    _allFlags;\n    substitute \"$input\" \"$output\" \"${args[@]}\"\n",
    "substituteAllInPlace":" \n    local fileName=\"$1\";\n    shift;\n    substituteAll \"$fileName\" \"$fileName\" \"$@\"\n",
    "substituteAllStream":" \n    local -a args=();\n    _allFlags;\n    substituteStream \"$1\" \"$2\" \"${args[@]}\"\n",
    "substituteInPlace":" \n    local -a fileNames=();\n    for arg in \"$@\";\n    do\n        if [[ \"$arg\" = \"--\"* ]]; then\n            break;\n        fi;\n        fileNames+=(\"$arg\");\n        shift;\n    done;\n    if ! [[ \"${#fileNames[@]}\" -gt 0 ]]; then\n        echo \"substituteInPlace called without any files to operate on (files must come before options!)\" 1>&2;\n        return 1;\n    fi;\n    for file in \"${fileNames[@]}\";\n    do\n        substitute \"$file\" \"$file\" \"$@\";\n    done\n",
    "substituteStream":" \n    local var=$1;\n    local description=$2;\n    shift 2;\n    while (( \"$#\" )); do\n        local replace_mode=\"$1\";\n        case \"$1\" in \n            --replace)\n                if ! \"$_substituteStream_has_warned_replace_deprecation\"; then\n                    echo \"substituteStream() in derivation $name: WARNING: '--replace' is deprecated, use --replace-{fail,warn,quiet}. ($description)\" 1>&2;\n                    _substituteStream_has_warned_replace_deprecation=true;\n                fi;\n                replace_mode='--replace-warn'\n            ;&\n            --replace-quiet | --replace-warn | --replace-fail)\n                pattern=\"$2\";\n                replacement=\"$3\";\n                shift 3;\n                if ! [[ \"${!var}\" == *\"$pattern\"* ]]; then\n                    if [ \"$replace_mode\" == --replace-warn ]; then\n                        printf \"substituteStream() in derivation $name: WARNING: pattern %q doesn't match anything in %s\\n\" \"$pattern\" \"$description\" 1>&2;\n                    else\n                        if [ \"$replace_mode\" == --replace-fail ]; then\n                            printf \"substituteStream() in derivation $name: ERROR: pattern %q doesn't match anything in %s\\n\" \"$pattern\" \"$description\" 1>&2;\n                            return 1;\n                        fi;\n                    fi;\n                fi;\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}'\n            ;;\n            --subst-var)\n                local varName=\"$2\";\n                shift 2;\n                if ! [[ \"$varName\" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then\n                    echo \"substituteStream() in derivation $name: ERROR: substitution variables must be valid Bash names, \\\"$varName\\\" isn't.\" 1>&2;\n                    return 1;\n                fi;\n                if [ -z ${!varName+x} ]; then\n                    echo \"substituteStream() in derivation $name: ERROR: variable \\$$varName is unset\" 1>&2;\n                    return 1;\n                fi;\n                pattern=\"@$varName@\";\n                replacement=\"${!varName}\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}'\n            ;;\n            --subst-var-by)\n                pattern=\"@$2@\";\n                replacement=\"$3\";\n                eval \"$var\"'=${'\"$var\"'//\"$pattern\"/\"$replacement\"}';\n                shift 3\n            ;;\n            *)\n                echo \"substituteStream() in derivation $name: ERROR: Invalid command line argument: $1\" 1>&2;\n                return 1\n            ;;\n        esac;\n    done;\n    printf \"%s\" \"${!var}\"\n",
    "unpackFile":" \n    curSrc=\"$1\";\n    echo \"unpacking source archive $curSrc\";\n    if ! runOneHook unpackCmd \"$curSrc\"; then\n        echo \"do not know how to unpack source archive $curSrc\";\n        exit 1;\n    fi\n",
    "unpackPhase":" \n    runHook preUnpack;\n    if [ -z \"${srcs:-}\" ]; then\n        if [ -z \"${src:-}\" ]; then\n            echo 'variable $src or $srcs should point to the source';\n            exit 1;\n        fi;\n        srcs=\"$src\";\n    fi;\n    local -a srcsArray;\n    concatTo srcsArray srcs;\n    local dirsBefore=\"\";\n    for i in *;\n    do\n        if [ -d \"$i\" ]; then\n            dirsBefore=\"$dirsBefore $i \";\n        fi;\n    done;\n    for i in \"${srcsArray[@]}\";\n    do\n        unpackFile \"$i\";\n    done;\n    : \"${sourceRoot=}\";\n    if [ -n \"${setSourceRoot:-}\" ]; then\n        runOneHook setSourceRoot;\n    else\n        if [ -z \"$sourceRoot\" ]; then\n            for i in *;\n            do\n                if [ -d \"$i\" ]; then\n                    case $dirsBefore in \n                        *\\ $i\\ *)\n\n                        ;;\n                        *)\n                            if [ -n \"$sourceRoot\" ]; then\n                                echo \"unpacker produced multiple directories\";\n                                exit 1;\n                            fi;\n                            sourceRoot=\"$i\"\n                        ;;\n                    esac;\n                fi;\n            done;\n        fi;\n    fi;\n    if [ -z \"$sourceRoot\" ]; then\n        echo \"unpacker appears to have produced no directories\";\n        exit 1;\n    fi;\n    echo \"source root is $sourceRoot\";\n    if [ \"${dontMakeSourcesWritable:-0}\" != 1 ]; then\n        chmod -R u+w -- \"$sourceRoot\";\n    fi;\n    runHook postUnpack\n",
    "updateAutotoolsGnuConfigScriptsPhase":" \n    if [ -n \"${dontUpdateAutotoolsGnuConfigScripts-}\" ]; then\n        return;\n    fi;\n    for script in config.sub config.guess;\n    do\n        for f in $(find . -type f -name \"$script\");\n        do\n            echo \"Updating Autotools / GNU config script to a newer upstream version: $f\";\n            cp -f \"/nix/store/2kk8q52163n8c4plc2yw1nfypm9drm02-gnu-config-2024-01-01/$script\" \"$f\";\n        done;\n    done\n",
    "updateSourceDateEpoch":" \n    local path=\"$1\";\n    [[ $path == -* ]] && path=\"./$path\";\n    local -a res=($(find \"$path\" -type f -not -newer \"$NIX_BUILD_TOP/..\" -printf '%T@ \"%p\"\\0' | sort -n --zero-terminated | tail -n1 --zero-terminated | head -c -1));\n    local time=\"${res[0]//\\.[0-9]*/}\";\n    local newestFile=\"${res[1]}\";\n    if [ \"${time:-0}\" -gt \"$SOURCE_DATE_EPOCH\" ]; then\n        echo \"setting SOURCE_DATE_EPOCH to timestamp $time of file $newestFile\";\n        export SOURCE_DATE_EPOCH=\"$time\";\n        local now=\"$(date +%s)\";\n        if [ \"$time\" -gt $((now - 60)) ]; then\n            echo \"warning: file $newestFile may be generated; SOURCE_DATE_EPOCH may be non-deterministic\";\n        fi;\n    fi\n"
  },
  "variables": {
    "AR": {"type": "exported", "value": "ar"},
    "AS": {"type": "exported", "value": "as"},
    "BASH": {"type": "var", "value": "/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin/bash"},
    "BASHOPTS": {"type": "unknown"},
    "BASHPID": {"type": "unknown"},
    "CC": {"type": "exported", "value": "clang"},
    "CONFIG_SHELL": {"type": "exported", "value": "/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin/bash"},
    "CXX": {"type": "exported", "value": "clang++"},
    "DEVELOPER_DIR": {"type": "exported", "value": "/nix/store/afinrggjfrk7q9pb7rv50l50cj0y0l63-apple-sdk-11.3"},
    "HOME": {"type": "exported", "value": "/homeless-shelter"},
    "HOSTTYPE": {"type": "var", "value": "aarch64"},
    "HOST_PATH": {"type": "exported", "value": "/nix/store/0ccvgwg4cpgf9jwwc98rz7wxafsmsf44-libiconv-109/bin:/nix/store/r9y8p97lcpm3kn03jsp157qr3kjhbxyh-coreutils-9.6/bin:/nix/store/i79f6sf3nq4n3n435pjrp0782kc395id-findutils-4.10.0/bin:/nix/store/asydkkql8fmcc2jjpiybljk87fb5iwkd-diffutils-3.10/bin:/nix/store/yfk1iriif0acn91as6qg96nwz6hs93si-gnused-4.9/bin:/nix/store/vyfs7l798mabb0kqw5v7xk87mzjn3d3x-gnugrep-3.11/bin:/nix/store/w7m7ys9nqgwqf0h2rwcw50vhgyysqhv0-gawk-5.3.1/bin:/nix/store/rphdiw3w4s7cy16z1y0slryjgaw3xal6-gnutar-1.35/bin:/nix/store/j9ibqjfcya1hf9x5522biyvzj6srsd2q-gzip-1.13/bin:/nix/store/r1pisnlfd4s197gf4r3h4x0i7lrfa790-bzip2-1.0.8-bin/bin:/nix/store/shwsndmpjz2nc236q64cl89rhn6rgy1r-gnumake-4.4.1/bin:/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin:/nix/store/ikbp0808bn0ydvgx0ivaz5w6i1jzjsp5-patch-2.7.6/bin:/nix/store/96j0xfm60pzczgbqbw1qbn1l1gxlfps7-xz-5.8.1-bin/bin:/nix/store/vify5yqsg42blv631021bd45xbihdhzw-file-5.46/bin"},
    "IFS": {"type": "var", "value": " \t\n"},
    "IN_NIX_SHELL": {"type": "exported", "value": "impure"},
    "LD": {"type": "exported", "value": "ld"},
    "LD_DYLD_PATH": {"type": "exported", "value": "/usr/lib/dyld"},
    "LINENO": {"type": "var", "value": "76"},
    "MACHTYPE": {"type": "var", "value": "aarch64-apple-darwin24.4.0"},
    "MACOSX_DEPLOYMENT_TARGET": {"type": "exported", "value": "11.3"},
    "NIX_APPLE_SDK_VERSION": {"type": "exported", "value": "110300"},
    "NIX_BINTOOLS": {"type": "exported", "value": "/nix/store/1mrg8k5bprv5m9sxam91cbbx3ng5g158-cctools-binutils-darwin-wrapper-1010.6"},
    "NIX_BINTOOLS_WRAPPER_TARGET_HOST_arm64_apple_darwin": {"type": "exported", "value": "1"},
    "NIX_BUILD_CORES": {"type": "exported", "value": "8"},
    "NIX_BUILD_TOP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "NIX_CC": {"type": "exported", "value": "/nix/store/xpja3ad45p55aryvgng6g9grp8yivvsd-clang-wrapper-19.1.7"},
    "NIX_CC_WRAPPER_TARGET_HOST_arm64_apple_darwin": {"type": "exported", "value": "1"},
    "NIX_CFLAGS_COMPILE": {"type": "exported", "value": " -frandom-seed=g6v3ya0yi3 -isystem /nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0/include -isystem /nix/store/gm5q6ny432c7hg7n29ir4j6xykl9m5fn-libcxx-19.1.7-dev/include -isystem /nix/store/dzv2mymsklzzndanzv4c5qlppsckg0ly-compiler-rt-libc-19.1.7-dev/include -isystem /nix/store/9szgbdimq2rfdi23l60hz185si754vx7-libiconv-109-dev/include -isystem /nix/store/gzkq7qb8g6v5xvx4zik7qi80ksdf57bm-libresolv-83-dev/include -isystem /nix/store/67mvdyn4fzm37x7nqqy2ssh5lfmwmfgf-libsbuf-14.1.0-dev/include -isystem /nix/store/19k3q3rk37llqjlakr1gy6l7pcrschln-cups-headers-2.4.11/include -isystem /nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0/include -isystem /nix/store/gm5q6ny432c7hg7n29ir4j6xykl9m5fn-libcxx-19.1.7-dev/include -isystem /nix/store/dzv2mymsklzzndanzv4c5qlppsckg0ly-compiler-rt-libc-19.1.7-dev/include -isystem /nix/store/9szgbdimq2rfdi23l60hz185si754vx7-libiconv-109-dev/include -isystem /nix/store/gzkq7qb8g6v5xvx4zik7qi80ksdf57bm-libresolv-83-dev/include -isystem /nix/store/67mvdyn4fzm37x7nqqy2ssh5lfmwmfgf-libsbuf-14.1.0-dev/include -isystem /nix/store/19k3q3rk37llqjlakr1gy6l7pcrschln-cups-headers-2.4.11/include"},
    "NIX_DONT_SET_RPATH": {"type": "exported", "value": "1"},
    "NIX_DONT_SET_RPATH_FOR_BUILD": {"type": "exported", "value": "1"},
    "NIX_ENFORCE_NO_NATIVE": {"type": "exported", "value": "1"},
    "NIX_ENFORCE_PURITY": {"type": "exported", "value": "1"},
    "NIX_HARDENING_ENABLE": {"type": "exported", "value": "bindnow format fortify fortify3 pic relro stackclashprotection stackprotector strictoverflow zerocallusedregs"},
    "NIX_IGNORE_LD_THROUGH_GCC": {"type": "exported", "value": "1"},
    "NIX_LDFLAGS": {"type": "exported", "value": " -L/nix/store/b1a3d7b0kvr03q7mgy6may69m1c3k76a-libcxx-19.1.7/lib -L/nix/store/cfzl4zn0n2mqglfx1x757rssi84w0z1v-compiler-rt-libc-19.1.7/lib -L/nix/store/0ccvgwg4cpgf9jwwc98rz7wxafsmsf44-libiconv-109/lib -L/nix/store/w4xszq1syyk2av5qdv59bv4yxba4qgpc-libresolv-83/lib -L/nix/store/isrdkn6nry8ia3rhwzxyx65d83racwhj-libsbuf-14.1.0/lib -L/nix/store/y2m4cb8kk92cn3x0jr842ip1024br266-libutil-72/lib -L/nix/store/b1a3d7b0kvr03q7mgy6may69m1c3k76a-libcxx-19.1.7/lib -L/nix/store/cfzl4zn0n2mqglfx1x757rssi84w0z1v-compiler-rt-libc-19.1.7/lib -L/nix/store/0ccvgwg4cpgf9jwwc98rz7wxafsmsf44-libiconv-109/lib -L/nix/store/w4xszq1syyk2av5qdv59bv4yxba4qgpc-libresolv-83/lib -L/nix/store/isrdkn6nry8ia3rhwzxyx65d83racwhj-libsbuf-14.1.0/lib -L/nix/store/y2m4cb8kk92cn3x0jr842ip1024br266-libutil-72/lib"},
    "NIX_LOG_FD": {"type": "exported", "value": "2"},
    "NIX_NO_SELF_RPATH": {"type": "exported", "value": "1"},
    "NIX_STORE": {"type": "exported", "value": "/nix/store"},
    "NM": {"type": "exported", "value": "nm"},
    "NODE_PATH": {"type": "exported", "value": "/nix/store/2j2dc9xiwcywic82xqq14vqgvhdyyv2h-node2nix-1.11.0/lib/node_modules:/nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0/lib/node_modules"},
    "OBJCOPY": {"type": "exported", "value": "objcopy"},
    "OBJDUMP": {"type": "exported", "value": "objdump"},
    "OLDPWD": {"type": "exported", "value": ""},
    "OPTERR": {"type": "var", "value": "1"},
    "OPTIND": {"type": "unknown"},
    "OSTYPE": {"type": "var", "value": "darwin24.4.0"},
    "PATH": {"type": "exported", "value": "/nix/store/2j2dc9xiwcywic82xqq14vqgvhdyyv2h-node2nix-1.11.0/bin:/nix/store/zbr4fi11j897pa9jikqpviz57kagvizv-nodejs-22.14.0-dev/bin:/nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0/bin:/nix/store/mv25m6irsd4ljhwihfv82d8gk62czpr3-pnpm-10.10.0/bin:/nix/store/2ii4afii0xlaljyzd8lm5y5n7xdj836j-yarn-1.22.22/bin:/nix/store/xpja3ad45p55aryvgng6g9grp8yivvsd-clang-wrapper-19.1.7/bin:/nix/store/k6828vnjgvg78ypjqij39rqs6m3fqjvq-clang-19.1.7/bin:/nix/store/r9y8p97lcpm3kn03jsp157qr3kjhbxyh-coreutils-9.6/bin:/nix/store/1mrg8k5bprv5m9sxam91cbbx3ng5g158-cctools-binutils-darwin-wrapper-1010.6/bin:/nix/store/19jgcqbfg1bgknq7g8cfiflfn5sz494d-cctools-binutils-darwin-1010.6/bin:/nix/store/sd6ii9z7h0bwkcfp21fmggb5fxdb7a99-xcbuild-0.1.1-unstable-2019-11-20-xcrun/bin:/nix/store/0ccvgwg4cpgf9jwwc98rz7wxafsmsf44-libiconv-109/bin:/nix/store/r9y8p97lcpm3kn03jsp157qr3kjhbxyh-coreutils-9.6/bin:/nix/store/i79f6sf3nq4n3n435pjrp0782kc395id-findutils-4.10.0/bin:/nix/store/asydkkql8fmcc2jjpiybljk87fb5iwkd-diffutils-3.10/bin:/nix/store/yfk1iriif0acn91as6qg96nwz6hs93si-gnused-4.9/bin:/nix/store/vyfs7l798mabb0kqw5v7xk87mzjn3d3x-gnugrep-3.11/bin:/nix/store/w7m7ys9nqgwqf0h2rwcw50vhgyysqhv0-gawk-5.3.1/bin:/nix/store/rphdiw3w4s7cy16z1y0slryjgaw3xal6-gnutar-1.35/bin:/nix/store/j9ibqjfcya1hf9x5522biyvzj6srsd2q-gzip-1.13/bin:/nix/store/r1pisnlfd4s197gf4r3h4x0i7lrfa790-bzip2-1.0.8-bin/bin:/nix/store/shwsndmpjz2nc236q64cl89rhn6rgy1r-gnumake-4.4.1/bin:/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin:/nix/store/ikbp0808bn0ydvgx0ivaz5w6i1jzjsp5-patch-2.7.6/bin:/nix/store/96j0xfm60pzczgbqbw1qbn1l1gxlfps7-xz-5.8.1-bin/bin:/nix/store/vify5yqsg42blv631021bd45xbihdhzw-file-5.46/bin"},
    "PATH_LOCALE": {"type": "exported", "value": "/nix/store/g05ixiavspfyf1fxn1h2x3mq3jhdfrnm-locale-118/share/locale"},
    "PS4": {"type": "var", "value": "+ "},
    "RANLIB": {"type": "exported", "value": "ranlib"},
    "SDKROOT": {"type": "exported", "value": "/nix/store/afinrggjfrk7q9pb7rv50l50cj0y0l63-apple-sdk-11.3/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"},
    "SHELL": {"type": "exported", "value": "/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin/bash"},
    "SHELLOPTS": {"type": "unknown"},
    "SIZE": {"type": "exported", "value": "size"},
    "SOURCE_DATE_EPOCH": {"type": "exported", "value": "315532800"},
    "SRANDOM": {"type": "unknown"},
    "STRINGS": {"type": "exported", "value": "strings"},
    "STRIP": {"type": "exported", "value": "strip"},
    "TEMP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TEMPDIR": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TERM": {"type": "exported", "value": "xterm-256color"},
    "TMP": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TMPDIR": {"type": "exported", "value": "/private/tmp/nix-build-nix-shell-env.drv-0"},
    "TZ": {"type": "exported", "value": "UTC"},
    "XDG_DATA_DIRS": {"type": "exported", "value": "/nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0/share:/nix/store/mv25m6irsd4ljhwihfv82d8gk62czpr3-pnpm-10.10.0/share:/nix/store/2ii4afii0xlaljyzd8lm5y5n7xdj836j-yarn-1.22.22/share"},
    "ZERO_AR_DATE": {"type": "exported", "value": "1"},
    "__darwinAllowLocalNetworking": {"type": "exported", "value": ""},
    "__impureHostDeps": {"type": "exported", "value": "/bin/sh /usr/lib/libSystem.B.dylib /usr/lib/system/libunc.dylib /dev/zero /dev/random /dev/urandom /bin/sh"},
    "__propagatedImpureHostDeps": {"type": "exported", "value": ""},
    "__propagatedSandboxProfile": {"type": "exported", "value": ""},
    "__sandboxProfile": {"type": "exported", "value": ""},
    "__structuredAttrs": {"type": "exported", "value": ""},
    "_substituteStream_has_warned_replace_deprecation": {"type": "var", "value": "false"},
    "buildInputs": {"type": "exported", "value": ""},
    "buildPhase": {"type": "exported", "value": "{ echo \"------------------------------------------------------------\";\n  echo \" WARNING: the existence of this path is not guaranteed.\";\n  echo \" It is an internal implementation detail for pkgs.mkShell.\";\n  echo \"------------------------------------------------------------\";\n  echo;\n  # Record all build inputs as runtime dependencies\n  export;\n} >> \"$out\"\n"},
    "builder": {"type": "exported", "value": "/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin/bash"},
    "cmakeFlags": {"type": "exported", "value": ""},
    "configureFlags": {"type": "exported", "value": ""},
    "defaultBuildInputs": {"type": "var", "value": "/nix/store/afinrggjfrk7q9pb7rv50l50cj0y0l63-apple-sdk-11.3"},
    "defaultNativeBuildInputs": {"type": "var", "value": "/nix/store/nxzmgd6sbzdzw7mz1ff0fnxsq77d9nyh-update-autotools-gnu-config-scripts-hook /nix/store/jjhw2phnaip4kg0qjas3x3fsaifi8y0w-no-broken-symlinks.sh /nix/store/h9lc1dpi14z7is86ffhl3ld569138595-audit-tmpdir.sh /nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh /nix/store/wgrbkkaldkrlrni33ccvm3b6vbxzb656-make-symlinks-relative.sh /nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh /nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh /nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh /nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh /nix/store/cmzya9irvxzlkh7lfy6i82gbp0saxqj3-multiple-outputs.sh /nix/store/hxv896faph0rqxjq2ycxpcrbnngc95sz-patch-shebangs.sh /nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh /nix/store/xyff06pkhki3qy1ls77w10s0v79c9il0-reproducible-builds.sh /nix/store/z7k98578dfzi6l3hsvbivzm7hfqlk0zc-set-source-date-epoch-to-latest.sh /nix/store/pilsssjjdxvdphlg2h19p0bfx5q0jzkn-strip.sh /nix/store/xpja3ad45p55aryvgng6g9grp8yivvsd-clang-wrapper-19.1.7"},
    "depsBuildBuild": {"type": "exported", "value": ""},
    "depsBuildBuildPropagated": {"type": "exported", "value": ""},
    "depsBuildTarget": {"type": "exported", "value": ""},
    "depsBuildTargetPropagated": {"type": "exported", "value": ""},
    "depsHostHost": {"type": "exported", "value": ""},
    "depsHostHostPropagated": {"type": "exported", "value": ""},
    "depsTargetTarget": {"type": "exported", "value": ""},
    "depsTargetTargetPropagated": {"type": "exported", "value": ""},
    "doCheck": {"type": "exported", "value": ""},
    "doInstallCheck": {"type": "exported", "value": ""},
    "dontAddDisableDepTrack": {"type": "exported", "value": "1"},
    "envBuildBuildHooks": {"type": "array", "value": ["addNodePath" ]},
    "envBuildHostHooks": {"type": "array", "value": ["addNodePath" ]},
    "envBuildTargetHooks": {"type": "array", "value": ["addNodePath" ]},
    "envHostHostHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" ]},
    "envHostTargetHooks": {"type": "array", "value": ["ccWrapper_addCVars" , "bintoolsWrapper_addLDVars" ]},
    "envTargetTargetHooks": {"type": "array", "value": []},
    "fixupOutputHooks": {"type": "array", "value": ["if [[ -z \"${noAuditTmpdir-}\" && -e \"$prefix\" ]]; then auditTmpdir \"$prefix\"; fi" , "if [ -z \"${dontGzipMan-}\" ]; then compressManPages \"$prefix\"; fi" , "_moveLib64" , "_moveSbin" , "_moveSystemdUserUnits" , "patchShebangsAuto" , "_pruneLibtoolFiles" , "_doStrip" ]},
    "initialPath": {"type": "var", "value": "/nix/store/r9y8p97lcpm3kn03jsp157qr3kjhbxyh-coreutils-9.6 /nix/store/i79f6sf3nq4n3n435pjrp0782kc395id-findutils-4.10.0 /nix/store/asydkkql8fmcc2jjpiybljk87fb5iwkd-diffutils-3.10 /nix/store/yfk1iriif0acn91as6qg96nwz6hs93si-gnused-4.9 /nix/store/vyfs7l798mabb0kqw5v7xk87mzjn3d3x-gnugrep-3.11 /nix/store/w7m7ys9nqgwqf0h2rwcw50vhgyysqhv0-gawk-5.3.1 /nix/store/rphdiw3w4s7cy16z1y0slryjgaw3xal6-gnutar-1.35 /nix/store/j9ibqjfcya1hf9x5522biyvzj6srsd2q-gzip-1.13 /nix/store/r1pisnlfd4s197gf4r3h4x0i7lrfa790-bzip2-1.0.8-bin /nix/store/shwsndmpjz2nc236q64cl89rhn6rgy1r-gnumake-4.4.1 /nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37 /nix/store/ikbp0808bn0ydvgx0ivaz5w6i1jzjsp5-patch-2.7.6 /nix/store/96j0xfm60pzczgbqbw1qbn1l1gxlfps7-xz-5.8.1-bin /nix/store/vify5yqsg42blv631021bd45xbihdhzw-file-5.46"},
    "mesonFlags": {"type": "exported", "value": ""},
    "name": {"type": "exported", "value": "nix-shell-env"},
    "nativeBuildInputs": {"type": "exported", "value": "/nix/store/2j2dc9xiwcywic82xqq14vqgvhdyyv2h-node2nix-1.11.0 /nix/store/zbr4fi11j897pa9jikqpviz57kagvizv-nodejs-22.14.0-dev /nix/store/mv25m6irsd4ljhwihfv82d8gk62czpr3-pnpm-10.10.0 /nix/store/2ii4afii0xlaljyzd8lm5y5n7xdj836j-yarn-1.22.22"},
    "noBrokenSymlinksHookInstalled": {"type": "unknown"},
    "out": {"type": "exported", "value": "/nix/store/g6v3ya0yi3rq0h9sn2glqwvnz6vldly2-nix-shell-env"},
    "outputBin": {"type": "var", "value": "out"},
    "outputDev": {"type": "var", "value": "out"},
    "outputDevdoc": {"type": "var", "value": "REMOVE"},
    "outputDevman": {"type": "var", "value": "out"},
    "outputDoc": {"type": "var", "value": "out"},
    "outputInclude": {"type": "var", "value": "out"},
    "outputInfo": {"type": "var", "value": "out"},
    "outputLib": {"type": "var", "value": "out"},
    "outputMan": {"type": "var", "value": "out"},
    "outputs": {"type": "exported", "value": "out"},
    "patches": {"type": "exported", "value": ""},
    "phases": {"type": "exported", "value": "buildPhase"},
    "pkg": {"type": "var", "value": "/nix/store/afinrggjfrk7q9pb7rv50l50cj0y0l63-apple-sdk-11.3"},
    "pkgsBuildBuild": {"type": "array", "value": []},
    "pkgsBuildHost": {"type": "array", "value": ["/nix/store/2j2dc9xiwcywic82xqq14vqgvhdyyv2h-node2nix-1.11.0" , "/nix/store/zbr4fi11j897pa9jikqpviz57kagvizv-nodejs-22.14.0-dev" , "/nix/store/2ribxb3gi87gj4331m6k0ydn0z90zfi7-nodejs-22.14.0" , "/nix/store/mv25m6irsd4ljhwihfv82d8gk62czpr3-pnpm-10.10.0" , "/nix/store/2ii4afii0xlaljyzd8lm5y5n7xdj836j-yarn-1.22.22" , "/nix/store/nxzmgd6sbzdzw7mz1ff0fnxsq77d9nyh-update-autotools-gnu-config-scripts-hook" , "/nix/store/jjhw2phnaip4kg0qjas3x3fsaifi8y0w-no-broken-symlinks.sh" , "/nix/store/h9lc1dpi14z7is86ffhl3ld569138595-audit-tmpdir.sh" , "/nix/store/m54bmrhj6fqz8nds5zcj97w9s9bckc9v-compress-man-pages.sh" , "/nix/store/wgrbkkaldkrlrni33ccvm3b6vbxzb656-make-symlinks-relative.sh" , "/nix/store/5yzw0vhkyszf2d179m0qfkgxmp5wjjx4-move-docs.sh" , "/nix/store/fyaryjvghbkpfnsyw97hb3lyb37s1pd6-move-lib64.sh" , "/nix/store/kd4xwxjpjxi71jkm6ka0np72if9rm3y0-move-sbin.sh" , "/nix/store/pag6l61paj1dc9sv15l7bm5c17xn5kyk-move-systemd-user-units.sh" , "/nix/store/cmzya9irvxzlkh7lfy6i82gbp0saxqj3-multiple-outputs.sh" , "/nix/store/hxv896faph0rqxjq2ycxpcrbnngc95sz-patch-shebangs.sh" , "/nix/store/cickvswrvann041nqxb0rxilc46svw1n-prune-libtool-files.sh" , "/nix/store/xyff06pkhki3qy1ls77w10s0v79c9il0-reproducible-builds.sh" , "/nix/store/z7k98578dfzi6l3hsvbivzm7hfqlk0zc-set-source-date-epoch-to-latest.sh" , "/nix/store/pilsssjjdxvdphlg2h19p0bfx5q0jzkn-strip.sh" , "/nix/store/xpja3ad45p55aryvgng6g9grp8yivvsd-clang-wrapper-19.1.7" , "/nix/store/1mrg8k5bprv5m9sxam91cbbx3ng5g158-cctools-binutils-darwin-wrapper-1010.6" , "/nix/store/sd6ii9z7h0bwkcfp21fmggb5fxdb7a99-xcbuild-0.1.1-unstable-2019-11-20-xcrun" ]},
    "pkgsBuildTarget": {"type": "array", "value": []},
    "pkgsHostHost": {"type": "array", "value": ["/nix/store/gm5q6ny432c7hg7n29ir4j6xykl9m5fn-libcxx-19.1.7-dev" , "/nix/store/b1a3d7b0kvr03q7mgy6may69m1c3k76a-libcxx-19.1.7" , "/nix/store/dzv2mymsklzzndanzv4c5qlppsckg0ly-compiler-rt-libc-19.1.7-dev" , "/nix/store/cfzl4zn0n2mqglfx1x757rssi84w0z1v-compiler-rt-libc-19.1.7" ]},
    "pkgsHostTarget": {"type": "array", "value": ["/nix/store/afinrggjfrk7q9pb7rv50l50cj0y0l63-apple-sdk-11.3" , "/nix/store/9szgbdimq2rfdi23l60hz185si754vx7-libiconv-109-dev" , "/nix/store/0ccvgwg4cpgf9jwwc98rz7wxafsmsf44-libiconv-109" , "/nix/store/gzkq7qb8g6v5xvx4zik7qi80ksdf57bm-libresolv-83-dev" , "/nix/store/w4xszq1syyk2av5qdv59bv4yxba4qgpc-libresolv-83" , "/nix/store/67mvdyn4fzm37x7nqqy2ssh5lfmwmfgf-libsbuf-14.1.0-dev" , "/nix/store/isrdkn6nry8ia3rhwzxyx65d83racwhj-libsbuf-14.1.0" , "/nix/store/y2m4cb8kk92cn3x0jr842ip1024br266-libutil-72" , "/nix/store/19k3q3rk37llqjlakr1gy6l7pcrschln-cups-headers-2.4.11" ]},
    "pkgsTargetTarget": {"type": "array", "value": []},
    "postFixupHooks": {"type": "array", "value": ["noBrokenSymlinksInAllOutputs" , "_makeSymlinksRelativeInAllOutputs" , "_multioutPropagateDev" ]},
    "postUnpackHooks": {"type": "array", "value": ["_updateSourceDateEpochFromSourceRoot" ]},
    "preConfigureHooks": {"type": "array", "value": ["_multioutConfig" ]},
    "preConfigurePhases": {"type": "var", "value": " updateAutotoolsGnuConfigScriptsPhase"},
    "preFixupHooks": {"type": "array", "value": ["_moveToShare" , "_multioutDocs" , "_multioutDevs" ]},
    "preferLocalBuild": {"type": "exported", "value": "1"},
    "prefix": {"type": "var", "value": "/nix/store/g6v3ya0yi3rq0h9sn2glqwvnz6vldly2-nix-shell-env"},
    "propagatedBuildDepFiles": {"type": "array", "value": ["propagated-build-build-deps" , "propagated-native-build-inputs" , "propagated-build-target-deps" ]},
    "propagatedBuildInputs": {"type": "exported", "value": ""},
    "propagatedHostDepFiles": {"type": "array", "value": ["propagated-host-host-deps" , "propagated-build-inputs" ]},
    "propagatedNativeBuildInputs": {"type": "exported", "value": ""},
    "propagatedTargetDepFiles": {"type": "array", "value": ["propagated-target-target-deps" ]},
    "shell": {"type": "exported", "value": "/nix/store/xhcgnphdwfg81j79nhspm0876cxglyj3-bash-5.2p37/bin/bash"},
    "shellHook": {"type": "exported", "value": ""},
    "stdenv": {"type": "exported", "value": "/nix/store/mrvg4qq09d51w5s95v15y4ym05q009fd-stdenv-darwin"},
    "strictDeps": {"type": "exported", "value": ""},
    "stripDebugFlags": {"type": "var", "value": "-S"},
    "system": {"type": "exported", "value": "aarch64-darwin"},
    "unpackCmdHooks": {"type": "array", "value": ["_defaultUnpack" ]}
  }
}